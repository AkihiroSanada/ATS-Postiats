(* ****** ****** *)

%{
val () = patscode_count_reset()
val () = patscode_prefix_set("TRYIT/libats_ML_string")
%}

(* ****** ****** *)

#decltitle("\
ATSLIB/libats/ML/string\
")

(* ****** ****** *)

#declpreamble("\

The functions declared in this package are primarily for processing
C-style strings in functional programming.

")

(* ****** ****** *)

#declnamesynop("string_append")
#decldescrpt("\

This function, which overload the symbol #dyncode("+"), returns the
concatenation of two given strings.

")
#declexample("\

The following code shows a typical way of combining strings:

#pats2xhtmld_tryit('\
//
staload "libats/ML/SATS/string.sats"
//
implement
main () = 0 where {
  val Hello = "H" + "e" + "l" + "l" + "o"
  val _rest = ", world!\\\n"
  val () = print (Hello + _rest)
} // end of [main]
')\

Note that the evaluation of the expression
#dyncode('"H" + "e" + "l" + "l" + "o"')
generates the following intermediate strings \"H\", \"He\", \"Hel\", and
\"Hell\", which all become garbage once the evaluation returns the string
\"Hello\".

")

#declnamesynop("string_append_ref")
#decldescrpt("\

This function is like #dyncode("string_append") except that the
concatenation of two given strings it returns is mutable.

")

(* ****** ****** *)

#declnamesynop("stringlst_concat")
#decldescrpt("\

Given a list xs of strings, this function returns the concatenation of
xs[0], xs[1], ,,,, xs[n-1], where n is the length of xs and the notation
xs[i] refers element i in xs.  ")

#declexample("\

The following code shows a way to form the string \"Hello\" by
concatenating a list of singleton strings:

#pats2xhtmld_tryit('\
//
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/string.sats"
//
implement
main () = 0 where {
  val Hello = stringlst_concat (
    list0$arrpsz{string} ("H", "e", "l", "l", "o")
  ) // end of [val]
  val _rest = ", world!\\\n"
  val () = print (Hello + _rest)
} // end of [main]
')\

Note that the call to #dyncode("stringlst_concat") constructs the string
\"Hello\" #emph("without") generating any intermediate substrings.

")

#declnamesynop("stringlst_concat_ref")
#decldescrpt("\

This function is like #dyncode("stringlst_concat") except that the
concatenation of a given list of strings it returns is mutable.

")

(* ****** ****** *)

#declnamesynop("substring_copy")
#decldescrpt("\

Given a string str of length n and integers ln and st, this function
returns a string consisting of chars str[ln], str[ln+1], ...,
str[ln+min(n-ln,st)-1] if ln is less than n. Otherwise, it returns the
empty string.

")
#declexample("\

The following code makes a simple use of #dyncode("substring_copy"):

#pats2xhtmld_tryit('\
//
staload "libats/ML/SATS/string.sats"
//
implement
main () = 0 where {
  val str = "abcdefg"
  val str2 = substring_copy (str, g1int2uint(0), string_length(str))
  val () = assert (str = str2)
} // end of [main]
')
")

#declnamesynop("substring_copy_ref")
#decldescrpt("\

This function is like #dyncode("substring_copy") except that the result
it returns is a mutable string.

")

(* ****** ****** *)

#declnamesynop("string_explode")
#decldescrpt("\

Given a string str of length n, this function returns a list consisting
of str[0], str[1], ..., and str[n-1], where each str[i] refers to char i in
str. ")
#declexample("\

The following code checks that the length of the list obtained from calling
#dyncode("string_explode") on a given string equals the length of the string:

#pats2xhtmld_tryit('\
//
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/string.sats"
//
implement
main () = 0 where {
  val str = "abcdefg"
  val cs = string_explode (str)
  val () = assert (string_length (str) = g0int2uint(list0_length (cs)))
} // end of [main]
')
")

#declnamesynop("string_implode")
#decldescrpt("\

Given a list cs of chars, this functions returns a string consisting of
cs[0], cs[1], ..., and cs[n-1], where n is the length of cs and each cs[i]
refers to char i in cs. Note that the length of the returned string is n
only if there is no null char in cs.

")
#declexample("\

The following code checks that the string obtained from calling
#dyncode("string_implode") on the list returned from a call to
#dyncode("string_explode") on a given string equals the given string:

#pats2xhtmld_tryit('\
//
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/string.sats"
//
implement
main () = 0 where {
  val str = "abcdefg"
  val cs = string_explode (str)
  val str2 = string_implode (cs)
  val () = assert (str = str2)
} // end of [main]
')
")

(* ****** ****** *)

(* end of [string.atxt] *)
