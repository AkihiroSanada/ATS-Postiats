#decltitle("\
ATSLIB/libats/ML/list0\
")

(* ****** ****** *)

#declpreamble("\

The functions declared in this package are primarily for supporting
ML-style processing of list-values. The programmer is encouraged to use the
dependent datatype #stacode("list") instead of #stacode("list0") after
gaining familiarity with dependent types.

")

(* ****** ****** *)

#declname("list0")
#declsynopsis2("\

The full name of the list0-type constructor is
#stacode("list0_t0ype_type"), which is given to the datatype declared as
follows:

#pats2xhtmls('\
datatype // t@ype+: covariant
list0_t0ype_type (a: t@ype+) =
  | list0_cons of (a, list0_t0ype_type a)
  | list0_nil of ()
// end of [list0_t0ype_type]
')
")

(* ****** ****** *)

#declnamesynop("list0_of_list")
#decldescript("\
This function casts a list-value of indexed type to a list-value of
unindexed type.
")
#declnamesynop("list0_of_list_vt")
#decldescript("\
This function casts a linear list-value of indexed type to a list-value of
unindexed type.
")
#declnamesynop("list_of_list0")
#decldescript("\
This function casts a list-value of unindexed type to a list-value of
indexed type.
")

(* ****** ****** *)

#declnamesynop("list0_head_exn")
#decldescript("\
This function returns the head of a given list if the list
is non-empty or raises an exception (ListSubscriptExn) if
the list is empty.
")
#declnamesynop("list0_head_opt")
#decldescript("\
This function is the optional version of #dyncode("list0_head_exn").
")

(* ****** ****** *)

#declnamesynop("list0_tail_exn")
#decldescript("\
This function returns the tail of a given list if the list
is non-empty or raises an exception (ListSubscriptExn) if
the list is empty.
")
#declnamesynop("list0_tail_opt")
#decldescript("\
This function is the optional version of #dyncode("list0_tail_exn").
")

(* ****** ****** *)

#declnamesynop("list0_nth_exn")
#decldescript("\

This function returns element i of a given list if i is a natural
number less than the length of the list.  Otherwise, it raises an
exception (ListSubscriptExn).

")
#declnamesynop("list0_nth_opt")
#decldescript("\
This function is the optional version of #dyncode("list0_nth_exn").
")

(* ****** ****** *)

#declnamesynop("list0_app")
#decldescript("\
This function is idential to #dyncode("list0_foreach").
")

(* ****** ****** *)

#declnamesynop("list0_map")
#decldescript("\

This function returns a list consisting of the sequence of results obtained
from applying its second argument f to each element in its first argument xs.
Following is a standard implementation of this function:

#pats2xhtmld("
implement{a}{b}
list0_map (xs, f) = let
in
//
case+ xs of
| list0_cons (x, xs) =>
    list0_cons (f x, list0_map (xs, f))
| list0_nil () => list0_nil ()
//
end // end of [list0_map]
")

However, the implementation of this function in ATSLIB is tail-recursive.\

")

(* ****** ****** *)

#declnamesynop("list0_map2")
#decldescript("\

This function returns a list consisting of the sequence of results obtained
from applying its third argument f to each pair in the zip of the first and
second arguments.

Following is a standard implementation of this function:

#pats2xhtmld("
implement{a1,a2}{b}
list0_map2 (xs1, xs2, f) = let
in
//
case+ xs1 of
| list0_cons (x1, xs1) => (
  case+ xs2 of
  | list0_cons (x2, xs2) =>
      list0_cons (f (x1, x2), list0_map2 (xs1, xs2, f))
  | list0_nil () => list0_nil ()
  )
| list0_nil () => list0_nil ()
//
end // end of [list0_map2]
")

However, the implementation of this function in ATSLIB is tail-recursive.\

")

(* ****** ****** *)

#declnamesynop("list0_foreach")
#decldescript("\

This function applies its second argument to each element in its first
argument.  ")

#declnamesynop("list0_iforeach")
#decldescript("\

This function applies its second argument f to (i, x), where i ranges from
0 to the length of xs minus 1 and x is element i in xs.

")

(* ****** ****** *)

#declnamesynop("list0_exists")
#decldescript("\

This function returns true if and only if there exists an element in its
first argument that satisfies the predicated provided as its second
argument.  ")

#declnamesynop("list0_forall")
#decldescript("\

This function returns true if and only if every element in its first
argument satisfies the predicated provided as its second argument.  ")

(* ****** ****** *)

#declnamesynop("list0_find_exn")
#decldescript("\
This functions returns the first element in its first argument that
satisfies the predicate given as its second argument. In case that such
an element does not exist, the function raises an exception (NotFoundExn).
")
#declnamesynop("list0_find_opt")
#decldescript("\
This function is the optional version of #dyncode("list0_find_exn").
")

(* ****** ****** *)

#declnamesynop("list0_filter")
#decldescript("\

This function returns a list consisting of the sequence of elements in its
first argument that satisfy the predicate provided as its second argument.

Following is a standard implementation of this function:

#pats2xhtmld("
implement{a}
list0_filter (xs, p) = let
in
//
case+ xs of
| list0_cons (x, xs) =>
    if p (x) then
      list0_cons (x, list0_filter<a> (xs, p))
    else
      list0_filter<a> (xs, p)
    // end of [if]
| list0_nil () => list0_nil ()
//
end // end of [list0_filter]
")

However, the implementation of this function in ATSLIB is tail-recursive.\

")

(* ****** ****** *)

#declnamesynop("list0_zip")
#decldescript("\

Given two lists xs and ys of length m and n, respectively, this function
returns a list of pairs (xs[i], ys[i]), where i ranges from 0 until
min(m,n)-1 and xs[i] (ys[i]) refers to element i in xs (ys).\

#pats2xhtmld("
implement
{x,y}
list0_zip (xs, ys) = let
in
//
case+ xs of
| list0_cons (x, xs) => (
  case+ ys of
  | list0_cons (y, ys) =>
      list0_cons (@(x, y), list0_zip<x,y> (xs, ys))
  | list0_nil () => list0_nil ()
  )
| list0_nil () => list0_nil ()
//
end // end of [list0_zip]
")

However, the implementation of this function in ATSLIB is tail-recursive.\

")

(* ****** ****** *)

#declnamesynop("list0_zipwith")
#decldescript("\
This function does the same as #dyncode("list0_map2").
")

(* ****** ****** *)

(* end of [list0.atxt] *)
