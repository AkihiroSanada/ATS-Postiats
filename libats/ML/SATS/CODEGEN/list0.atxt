%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"list0.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/libats/ML/SATS/CODEGEN/list0.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("May, 2012")

#atscode_separator()
//
// HX-2013-01:
// A rule of thumb for effect-annotation is that
// higher-order functions should not be annotated!
//
#atscode_separator()

staload "libats/SATS/ML_basics.sats"

#atscode_separator()

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

#atscode_separator()

typedef cfun (a: t0p, b:t0p) = (a) -<cloref1> b
typedef cfun2 (a1: t0p, a2: t0p, b:t0p) = (a1, a2) -<cloref1> b

#atscode_separator()

castfn
list0_of_list {a:t@ype} (xs: List (INV(a))):<> list0 (a)
castfn
list0_of_list_vt {a:t@ype} (xs: List_vt (INV(a))):<> list0 (a)
castfn
list_of_list0 {a:t@ype} (xs: list0 (INV(a))):<> List0 (a)

#atscode_separator()

fun{a:t0p}
list0_make_elt (n: int, x: a):<!exn> list0 (a)

#atscode_separator()
//
symintr list0_make_intrange
//
fun list0_make_intrange_2 (l: int, r: int):<> list0 (int)
fun list0_make_intrange_3 (l: int, r: int, d: int):<!exn> list0 (int)
overload list0_make_intrange with list0_make_intrange_2
overload list0_make_intrange with list0_make_intrange_3

#atscode_separator()
//
symintr list0
//
fun{a:t0p}
list0_make_arrpsz
  {n:int} (psz: arrpsz (INV(a), n)):<!wrt> list0 (a)
overload list0 with list0_make_arrpsz

#atscode_separator()
(*
// HX: this one is of template style
*)
fun{a:t0p}
fprint_list0_sep (
  out: FILEref, xs: list0 (INV(a)), sep: NSH(string)
) : void // end of [fprint_list0_sep]

#atscode_separator()

fun{a:t0p}
list0_sing (x: a):<> list0 (a)
fun{a:t0p}
list0_pair (x1: a, x2: a):<> list0 (a)

#atscode_separator()

fun{}
list0_is_nil {a:t0p} (xs: list0 a):<> bool
fun{}
list0_is_cons {a:t0p} (xs: list0 a):<> bool

fun{}
list0_is_empty {a:t0p} (xs: list0 a):<> bool
fun{}
list0_isnot_empty {a:t0p} (xs: list0 a):<> bool

#atscode_separator()

fun{a:t0p}
list0_head_exn (xs: list0 (INV(a))):<!exn> a
fun{a:t0p}
list0_head_opt (xs: list0 (INV(a))):<> option0 (a)

fun{a:t0p}
list0_tail_exn
  (xs: SHR(list0 (INV(a)))):<!exn> list0 (a)
fun{a:t0p}
list0_tail_opt
  (xs: SHR(list0 (INV(a)))):<> option0 (list0 (a))
// end of [list0_tail_opt]

#atscode_separator()

fun{a:t0p}
list0_nth_exn (xs: list0 (INV(a)), i: int):<!exn> a
fun{a:t0p}
list0_nth_opt (xs: list0 (INV(a)), i: int):<> option0 (a)

#atscode_separator()

fun{a:t0p}
list0_get_at_exn (xs: list0 (INV(a)), i: int):<!exn> a
overload [] with list0_get_at_exn

fun{a:t0p}
list0_insert_at_exn (
  xs: SHR(list0 (INV(a))), i: int, x: a
) :<!exn> list0 (a) // endfun

fun{a:t0p}
list0_remove_at_exn
  (xs: SHR(list0 (INV(a))), i: int):<!exn> list0 (a)
// end of [list0_remove_at_exn]

#atscode_separator()

fun{a:t0p}
list0_length (xs: list0 (INV(a))):<> int
overload length with list0_length

#atscode_separator()

fun{a:t0p}
list0_append
  (xs: NSH(list0 (INV(a))), ys: SHR(list0 a)):<> list0 (a)
overload + with list0_append

#atscode_separator()

fun{a:t0p}
list0_extend (xs: NSH(list0 (INV(a))), y: a):<> list0 (a)

macdef list0_snoc = list0_extend

#atscode_separator()

fun{a:t0p}
list0_reverse (xs: list0 (INV(a))):<> list0 (a)

fun{a:t0p}
list0_reverse_append
  (xs: list0 (INV(a)), ys: list0 a):<> list0 (a)
// end of [list0_reverse_append]

#atscode_separator()

fun{a:t0p}
list0_concat (xss: NSH(list0 (list0 (INV(a))))):<> list0 (a)

#atscode_separator()

fun{a:t0p}
list0_take_exn
  (xs: NSH(list0 (INV(a))), i: int):<!exn> list0 (a)
// end of [list0_take_exn]

fun{a:t0p}
list0_drop_exn
  (xs: SHR(list0 (INV(a))), i: int):<!exn> list0 (a)
// end of [list0_drop_exn]

#atscode_separator()

fun{a:t0p}
list0_app (xs: list0 (INV(a)), f: cfun (a, void)): void

#atscode_separator()

fun{a:t0p}
list0_foreach (xs: list0 (INV(a)), f: cfun (a, void)): void

fun{a:t0p}
list0_iforeach (xs: list0 (INV(a)), f: cfun2 (int, a, void)): int

#atscode_separator()

fun{a1,a2:t0p}
list0_foreach2 (
  xs1: list0 (INV(a1)), xs2: list0 (INV(a2)), f: cfun2 (a1, a2, void)
) : void // end of [list0_foreach2]

fun{a1,a2:t0p}
list0_foreach2_eq (
  xs1: list0 (INV(a1))
, xs2: list0 (INV(a2))
, f: cfun2 (a1, a2, void)
, sgn: &int? >> int
) : void // end of [list0_foreach2_eq]

#atscode_separator()

fun{
a:t0p}{res:t0p
} list0_foldleft
  (xs: list0 (INV(a)), ini: res, f: cfun2 (res, a, res)): res
fun{
a:t0p}{res:t0p
} list0_ifoldleft
  (xs: list0 (INV(a)), ini: res, f: cfun3 (res, int, a, res)): res
// end of [list0_ifoldleft]

#atscode_separator()

fun{
a1,a2:t0p}{res:t0p
} list0_foldleft2 (
  xs1: list0 (INV(a1))
, xs2: list0 (INV(a2))
, ini: res
, f: cfun3 (res, a1, a2, res)
) : res // end of [list0_foldleft2]

#atscode_separator()

fun{
a:t0p}{res:t0p
} list0_foldright
  (xs: list0 (INV(a)), f: cfun2 (a, res, res), snk: res): res
(*
fun{
a:t0p}{res:t0p
} list0_ifoldright
  (xs: list0 (INV(a)), f: cfun3 (int, a, res, res), snk: res): res
// end of [list0_ifoldright]
*)

#atscode_separator()

fun{a:t0p}
list0_exists
  (xs: list0 (INV(a)), p: cfun (a, bool)): bool
// end of [list0_exists]

fun{a1,a2:t0p}
list0_exists2 (
  xs1: list0 (INV(a1))
, xs2: list0 (INV(a2))
, p: cfun2 (a1, a2, bool)
) : bool // end of [list0_exists2]

#atscode_separator()

fun{a:t0p}
list0_forall (xs: list0 (INV(a)), p: cfun (a, bool)): bool

fun{a1,a2:t0p}
list0_forall2 (
  xs1: list0 (INV(a1))
, xs2: list0 (INV(a2))
, p: cfun2 (a1, a2, bool)
) : bool // end of [list0_forall2]
fun{a1,a2:t0p}
list0_forall2_eq (
  xs1: list0 (INV(a1))
, xs2: list0 (INV(a2))
, p: cfun2 (a1, a2, bool)
, sgn: &int? >> int
) : bool // end of [list0_forall2_eq]

#atscode_separator()

fun{a:t0p}
list0_equal (
  xs1: list0 (INV(a)), xs2: list0 a, eqfn: cfun2 (a, a, bool)
) : bool // end of [list0_equal]

#atscode_separator()

fun{a:t0p}
list0_find_exn (xs: list0 (INV(a)), p: cfun (a, bool)): a
fun{a:t0p}
list0_find_opt (xs: list0 (INV(a)), p: cfun (a, bool)): option0 (a)

#atscode_separator()

fun{
a:t0p}{b:t0p
} list0_map (xs: list0 (INV(a)), f: cfun (a, b)): list0 (b)

fun{
a:t0p}{b:t0p
} list0_imap (xs: list0 (INV(a)), f: cfun2 (int, a, b)): list0 (b)

#atscode_separator()

fun{
a1,a2:t0p}{b:t0p
} list0_map2 (
  xs1: list0 (INV(a1)), xs2: list0 (INV(a2)), f: cfun2 (a1, a2, b)
) : list0 (b) // end of [list0_map2]

#atscode_separator()

fun{a:t0p}
list0_filter
  (xs: list0 (INV(a)), f: cfun (a, bool)): list0 (a)
// end of [list0_filter]

#atscode_separator()

fun{a:t0p}
list0_tabulate (n: int, f: cfun (int, a)): list0 (a)

#atscode_separator()

fun{x,y:t0p}
list0_zip (xs: list0 (INV(x)), ys: list0 (INV(y))):<> list0 @(x, y)

(*
fun{
x,y:t0p}{z:t0p
} list0_zipwith (
  xs: list0 (INV(x)), ys: list0 (INV(y)), f: cfun2 (x, y, z)
) : list0 (z) // end of [list0_zipwith]
*)
macdef list0_zipwith = list0_map2

#atscode_separator()

fun{a:t0p}
list0_quicksort
  (xs: NSH(list0 (INV(a))), cmp: (a, a) -<cloref> int):<> list0 (a)
// end of [list0_quicksort]

#atscode_separator()

fun{a:t0p}
list0_mergesort
  (xs: NSH(list0 (INV(a))), cmp: (a, a) -<cloref> int):<> list0 (a)
// end of [list0_mergesort]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "list0_atxt.txt")
%}\
