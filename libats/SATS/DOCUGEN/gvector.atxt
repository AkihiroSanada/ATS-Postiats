(* ****** ****** *)

%{
implement srcfilename_get () = "../gvector.sats"
%}

(* ****** ****** *)

%{
val () = patscode_count_reset()
val () = patscode_prefix_set("TRYIT/libats_gvector")
%}

(* ****** ****** *)

#decltitle("\
ATSLIB/libats/gvector\
")

(* ****** ****** *)

#declpreamble("\

This package contains various functions for manipulating generic vectors,
that is, one-dimensional arrays.

")

(* ****** ****** *)

#declnamesynop("gvector")
#declnamesynop("gvector_t0ype")
#declnamesynop("gvector_v")
#declnamesynop("GV")

(* ****** ****** *)

#declnamesynop("lemma_gvector_param")
#declnamesynop("lemma_gvector_v_param")

(* ****** ****** *)

#declnamesynop("gvector_v_nil")
#declnamesynop("gvector_v_unnil")
#declnamesynop("gvector_v_unnil_nil")
#declnamesynop("gvector_v_cons")
#declnamesynop("gvector_v_uncons")

(* ****** ****** *)

#declnamesynop("gvector_getref_at")

(* ****** ****** *)

#declnamesynop("fprint_gvector")
#declnamesynop("fprint_gvector$sep")

(* ****** ****** *)

#declnamesynop("multo_scalar_gvector")
#decldescrpt("\

This function scales vector V (2nd argument) by a scalar k (1st argument).

")

#declnamesynop("muladdto_scalar_gvector_gvector")
#decldescrpt("\

This function scales vector V1 (2nd argument) by a scalar k (1st argument)
and then add it to vector V2 (3rd argument).

")

(* ****** ****** *)

#declnamesynop("mul_gvector_gvector_scalar")
#decldescrpt("\

This function computes the inner product (a.k.a. dot product) of two given
vectors.

")

(* ****** ****** *)

(* end of [gvector.atxt] *)
