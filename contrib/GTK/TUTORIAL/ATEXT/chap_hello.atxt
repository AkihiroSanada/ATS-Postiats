%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
#include "./ATEXT/ats2gtk.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_hello.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="hello_example">
#title("A Simple Example: Hello, world!")

#para("\

The first program we present in this tutorial is given as follows:

#atscode('\
//
%{^
typedef char **charptrptr ;
%} ;
abstype charptrptr = $extype"charptrptr"
//
implement
main0 (argc, argv) =
{
//
var argc: int = argc
var argv: charptrptr = $UN.castvwtp1{charptrptr}(argv)
//
val () = $extfcall (void, "gtk_init", addr@(argc), addr@(argv))
//
val win =
  gtk_window_new (GTK_WINDOW_TOPLEVEL)
//
val () = assertloc (ptrcast(win) > 0)
//
val ((*void*)) = gtk_widget_show (win)
//
val ((*void*)) = gtk_main ()
//
val ((*void*)) = gtk_widget_destroy0 (win) // can never be reached!!!
//
} (* end of [main0] *)
//
')

This code probably looks rather peculiar at first. As the function
#dyncode("gtk_init") is currently not included in ATS/GTK, it is called
through the use of #dyncode("$extfcall") (for handling calls to external
functions). In summary, the above code creates a window (which is a type of
GTK-widget), checks that the window is not null, sets some flag to indicate
that the window is to be displayed, and then enters the main loop of GTK.

")

#para("\

It may seem that using GTK functions in ATS is nearly identical to using
them in C (modulo syntatical difference). However, what happens at the
level of typechecking in ATS is far more sophisticated than in C. In
particular, linear types are assigned to GTK objects in ATS to allow them to be tracked
statically, that is, at compile-time, preventing potential mismanagement of
such objects.

")

</chapter>#comment("chapter/hello_example")

#comment(" ****** ****** ")

#comment(" end of [chap_hello.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "chap_hello_atxt.txt")
%}
