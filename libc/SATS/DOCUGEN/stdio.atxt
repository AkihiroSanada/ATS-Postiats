(* ****** ****** *)

%{
val () = patscode_count_reset()
val () = patscode_prefix_set("TRYIT/libc_stdio")
%}

(* ****** ****** *)

#decltitle("\
ATSLIB/libc/stdio\
")

(* ****** ****** *)

#declpreamble("\

The functions declared in this package are mostly the API for
the corresponding libc-functions declared in [stdio.h].

")

(* ****** ****** *)
//
#declnamesynop("FILE_v")
//
#declname("FILEptr")
#declsynopsis2("\
#pats2xhtmls("\
absviewtype
FILEptr_viewtype (addr, file_mode) = ptr
stadef FILEptr = FILEptr_viewtype
")")
//
#declnamesynop("FILEptr0")
//
#declname("FILEptr1")
#declsynopsis2("\
#pats2xhtmls("\
viewtypedef FILEptr1 (m:fm) = [l:agz] FILEptr (l, m)
viewtypedef FILEptr1 (*none*) = [l:agz;m:fm] FILEptr (l, m)
")
")

%{
(*
#declnamesynop("FILEref") // this one is declared in prelude/basic_sta.sats
*)
%}

(* ****** ****** *)

#declnamesynop("FILEptr2ptr")

(* ****** ****** *)

#declnamesynop("FILEptr_encode")
#declnamesynop("FILEptr_decode")

(* ****** ****** *)

#declnamesynop("FILEptr_free_null")

(* ****** ****** *)

#declnamesynop("FILEptr_refize")

(* ****** ****** *)

#declnamesynop("FILEref_get_ptr")
#decldescrpt("\

This cast function is called on a FILEref-value filr to get the linear
FILEptr-value of filr for temporary use.  ")

(* ****** ****** *)

#declnamesynop("fopen_err")
#declexample("\

The following code opens a file of the name \"foo.txt\", writes into it the
string \"Hello, world!\", and then closes it:

#pats2xhtmld_tryit('\
//
staload "libc/SATS/stdio.sats"
//
implement
main () = let
//
val filp = fopen_err ("foo.txt", file_mode_w)
//
in
//
if FILEptr2ptr(filp) != 0 then let
  val _ = fputs_err (file_mode_lte_w_w | "Hello, world!", filp)
  val () = fclose_exn (filp)
in
  0
end else let
  val () = perror ("Can\'t open file")
  val () = FILEptr_free_null (filp)
in
  1
end // end of [if]
//
end // end of [main]
')
")

#declnamesynop("fopen_exn")
#declnamesynop("fopen_ref_exn")

(* ****** ****** *)

#declnamesynop("fclose0_err")
#declnamesynop("fclose1_err")
#declnamesynop("fclose0_exn")
#declnamesynop("fclose1_exn")

(* ****** ****** *)

#declnamesynop("freopen0_err")
#decldescrpt("\
This function directly corresponds to the libc-function of the name
#dyncode("freopen").")
#declnamesynop("freopen1_err")
#decldescrpt("\
This function directly corresponds to the libc-function of the name
#dyncode("freopen").")
#declnamesynop("freopen0_exn")
#decldescrpt("\
This function is a slight variant of #dyncode("freopen0_exn"): It exits
immediately if calling #dyncode("freopen") leads to an error.  ")
#declexample("\

The following code creates a file named foo.txt and writes into it the
string \"Hello, world!\" plus a newline:

#pats2xhtmld_tryit('\
//
staload "libc/SATS/stdio.sats"
//
implement
main () = 0 where {
  val () = freopen0_exn ("foo.txt", file_mode_w, stdout_ref)
  val () = puts_exn ("Hello, world!")
  val () = fclose0_exn (stdout_ref)
} // end of [main]
')
")
%{
(*
#declnamesynop("freopen_stdin")
#declnamesynop("freopen_stdout")
#declnamesynop("freopen_stderr")
*)
%}

(* ****** ****** *)

#declnamesynop("fileno0")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("fileno"). ")
#declexample("\

The following code checks that the file descriptors of the standard input,
the standard output, and the standard error are numbered by default as 0,
1, and 2, respectively:

#pats2xhtmld_tryit('\
//
staload "libc/SATS/stdio.sats"
//
implement
main () = let
  val () = assert (fileno0 (stdin_ref) = 0)
  val () = assert (fileno0 (stdout_ref) = 1)
  val () = assert (fileno0 (stderr_ref) = 2)
in
  0(*normal*)
end // end of [main]
')
")

#declnamesynop("fileno1")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("fileno"). ")

(* ****** ****** *)

#declnamesynop("fdopen_err")
#declnamesynop("fdopen_exn")

(* ****** ****** *)

#declnamesynop("clearerr0")
#declnamesynop("clearerr1")

(* ****** ****** *)

#declnamesynop("feof0")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
feof. It returns a nonzero if and only if the end-of-file indicator for the
stream associated with its argument is set.

")
#declnamesynop("feof1")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
feof. It returns a nonzero if and only if the end-of-file indicator for the
stream associated with its argument is set.

")

(* ****** ****** *)

#declnamesynop("ferror0")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
ferror. ")

#declnamesynop("ferror1")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
ferror. ")

(* ****** ****** *)

#declnamesynop("fflush0_err")
#declnamesynop("fflush1_err")
#declnamesynop("fflush0_exn")

(* ****** ****** *)

#declnamesynop("fgetc0_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
fgetc. ")
#declexample("\

The following code copies chars read from the standard input channel to the
standard output channel:

#pats2xhtmld_tryit('\
//
staload "libc/SATS/stdio.sats"
//
local

fun loop (
  inp: FILEref, out: FILEref
) : void =
  if feof0 (inp) = 0 then let
    val _(*err*) = fputc0_err (fgetc0_err (inp), out) in loop (inp, out)
  end else () // end of [if]
// end of [loop]

in // in of [local]

implement
main () = 0 where {
  val () = loop (stdin_ref, stdout_ref)
} // end of [main]

end // end of [local]
')
")

#declnamesynop("fgetc1_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
fgetc. ")

(* ****** ****** *)

#declnamesynop("getc")
#declnamesynop("getchar0")
#declnamesynop("getchar1")

(* ****** ****** *)

#declnamesynop("fgets0_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
fgets. ")
#declexample("\

The following code copies lines read from the standard input channel to the
standard output channel:

#pats2xhtmld_tryit('\
//
staload
UN="prelude/SATS/unsafe.sats"
staload "libc/SATS/stdio.sats"
//
local

fun loop
  {sz:pos} (
  inp: FILEref
, out: FILEref
, buf: &bytes(sz)? >> _
, sz: int sz
) : void = let
  val p = fgets0_err (buf, sz, inp)
in
  if p > 0 then let // p=addr@(buf) or NULL
    val _(*err*) = fputs0_err ($UN.cast{string}(p), out)
  in
    loop (inp, out, buf, sz)
  end else () // end of [if]
end // end of [loop]

in // in of [local]

implement
main () = 0 where {
  \#define BUFSZ 1024
  var buf = @[byte][BUFSZ]()
  val () = loop (stdin_ref, stdout_ref, buf, BUFSZ)
} // end of [main]

end // end of [local]
')
")

#declnamesynop("fgets1_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
fgets. ")

(* ****** ****** *)

#declnamesynop("fputc0_err")
#declnamesynop("fputc1_err")
#declnamesynop("fputc0_exn")

(* ****** ****** *)

#declnamesynop("putc")
#declnamesynop("putchar0")
#declnamesynop("putchar1")

(* ****** ****** *)

#declnamesynop("fputs0_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("fputs").  ")
#declnamesynop("fputs1_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("fputs").  ")
#declnamesynop("fputs0_exn")

(* ****** ****** *)

#declnamesynop("puts_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("puts").  Note that a call to this function puts a trailing
newline after its argument.
")

#declnamesynop("puts_exn")
#decldescrpt("\

This function is a slight variant of #dyncode("puts_err"): It exits
immediately if calling #dyncode("puts") leads to an error.  ")

(* ****** ****** *)

#declnamesynop("fread0_err")
#declnamesynop("fread1_err")
#declnamesynop("fread0_exn")

#declnamesynop("fwrite0_err")
#declnamesynop("fwrite1_err")
#declnamesynop("fwrite0_exn")

(* ****** ****** *)

#declnamesynop("fgetpos0_err")
#declnamesynop("fgetpos1_err")
#declnamesynop("fgetpos0_exn")

#declnamesynop("fsetpos0_err")
#declnamesynop("fsetpos1_err")
#declnamesynop("fsetpos0_exn")

(* ****** ****** *)

#declnamesynop("fseek0_err")
#declnamesynop("fseek1_err")
#declnamesynop("fseek0_exn")

(* ****** ****** *)

#declnamesynop("ftell0_err")
#declnamesynop("ftell1_err")
#declnamesynop("ftell0_exn")

(* ****** ****** *)

#declnamesynop("perror")
#decldescrpt("\

This function directly corresponds to the libc-function of the same name.
")

(* ****** ****** *)

#declnamesynop("remove_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("remove").  ")

#declnamesynop("remove_exn")
#decldescrpt("\

This function is a slight variant of #dyncode("remove_err"): It exits
immediately if calling #dyncode("remove") leads to an error.  ")

(* ****** ****** *)

#declnamesynop("rename_err")
#decldescrpt("\

This function directly corresponds to the libc-function of the name
#dyncode("rename").  ")

#declnamesynop("rename_exn")
#decldescrpt("\

This function is a slight variant of #dyncode("rename_err"): It exits
immediately if calling #dyncode("rename") leads to an error.  ")
#declexample("\

The following code opens a file handle for a file named foo.txt, writes
into it the string \"Hello, world!\" plus a newline, closes the file handle,
and then renames the file as foo2.txt:

#pats2xhtmld_tryit('\
//
staload "libc/SATS/stdio.sats"
//
implement
main () = 0 where {
  val out =
    fopen_ref_exn ("foo.txt", file_mode_w)
  val () = fputs0_exn ("Hello, world!\\\n", out)
  val () = fclose0_exn (out)
  val () = rename_exn ("foo.txt", "foo2.txt")
} // end of [main]
')
")

(* ****** ****** *)

#declnamesynop("rewind0")
#declnamesynop("rewind1")

(* ****** ****** *)

#declnamesynop("tmpfile_err")
#declnamesynop("tmpfile_exn")
#declnamesynop("tmpfile_ref_exn")

(* ****** ****** *)

#declnamesynop("ungetc0_err")
#declnamesynop("ungetc1_err")
#declnamesynop("ungetc0_exn")

(* ****** ****** *)

(* end of [stdio.atxt] *)
