%{
#include "./../ATEXT/atextfun.hats"
%}

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-hanoi-towers</title>
#patscode_style()
</head>

<body>

<h1>
Effective ATS:<br>Hanoi Towers:<br>
Let's tap into the power of types!
</h1>

#para("\
Types are an extremely powerful notion in programming
as what is behind types is logic itself. However, making
effective use of types in programming is a very difficult
task for many programmers (ranging from novices to experts).
In this article, I will present several solutions to a simple problem,
gradually illustrating certain typical uses of dependent types
and linear types in programming.
")

<h2>
What is Hanoi Towers?
</h2>
The puzzle <u>Hanoi Towers</u> can be described as follows:

#para("\
Given three poles: Pole 1, Pole 2 and Pole 3, there are 64 disks of
distinct sizes stacked on Pole 1 such that no disk is stacked on one
of a lesser size, and both Pole 2 and Pole 3 are empty.  The player is
asked to the task of
moving all the disks from Pole 1 to Pole 2 (while using Pole 3
as a spare): Only one disk can be moved from one pole to another each
time and no disk is ever allowed to be stacked on another one of less
size during the entire process of moving.\
")

#para("\
It will soon be clear that 2<sup>64</sup>-1 moves are needed in order to
accomplish the aforementioned task.
")

<h2>
A Solution of Imperative Style
</h2>

<pre
class="patsyntax">
#pats2xhtml_dats('\
datatype
pole = Pole of
(
  string(*name*), ref(list0(int))(*disks*)
) (* end of [Pole] *)
')</pre>

<pre
class="patsyntax">
#pats2xhtml_dats('\
//
extern
fun
move_1(P1: pole, P2: pole): void
//
implement
move_1(P1, P2) = let
//
val Pole(n1, r1) = P1
val-cons0(x, xs) = !r1
val ((*void*)) = !r1 := xs
//
val Pole(n2, r2) = P2
val ((*void*)) = !r2 := cons0(x, !r2)
//
in
  println! ("Move [", x, "] from [", n1, "] to [", n2, "]")
end // end of [move_1]
//
')</pre>

<h2>
A Solution of Functional Style
</h2>

<pre
class="patsyntax">
#pats2xhtml_dats('\
//
abstype pole(n:int) = ptr
//
extern
fun
move_1{p1,p2:nat | p1 > 0}
(
  P1: pole(p1), P2: pole(p2)
) : (pole(p1-1), pole(p2+1))
//
extern
fun
move_n{n:nat}
{p1,p2,p3:nat | p1 >= n}
(
  n: int(n)
, P1: pole(p1), P2: pole(p2), P3: pole(p3)
) : (pole(p1-n), pole(p2+n), pole(p3))
//
')</pre>

<pre
class="patsyntax">
#pats2xhtml_dats('\
local

datatype
pole_(n:int) =
Pole of
(
  string, list(int, n)
) (* end of [pole_] *)

assume pole(n:int) = pole_(n)

in (* in-of-local *)

implement
move_1(P1, P2) = let
//
  val Pole(n1, r1) = P1
  val+list_cons(x, xs) = r1
  val Pole(n2, r2) = P2
//
  val () =
  println!
  (
    "Move [", x, "] from [", n1, "] to [", n2, "]"
  ) (* end of [val] *)
//
in
  (Pole(n1, xs), Pole(n2, list_cons(x, r2)))
end // end of [move_1]

end // end of [local]
')</pre>

<pre
class="patsyntax">
#pats2xhtml_dats('\
implement
move_n
(
  n, P1, P2, P3
) = (
//
if
n > 0
then
(
  P1, P2, P3
) where
{
  val n1 = n - 1
  val (P1, P3, P2) = move_n(n1, P1, P3, P2)
  val (P1, P2)     = move_1(P1, P2)
  val (P3, P2, P1) = move_n(n1, P3, P2, P1)
}
else (P1, P2, P3)
//
) (* end of [move_n] *)
')</pre>

<h2>
A Solution of Linear Functional Style
</h2>

<pre
class="patsyntax">
#pats2xhtml_dats('\
//
absvtype pole(n:int) = ptr
//
extern
fun
move_1{p1,p2:nat|p1 > 0}
(
  P1: !pole(p1) >> pole(p1-1)
, P2: !pole(p2) >> pole(p2+1)
) : void // end-of-function
//
extern
fun
move_n{n:nat}
{p1,p2,p3:nat | p1 >= n}
(
  n: int(n)
, P1: !pole(p1) >> pole(p1-n), P2: !pole(p2) >> pole(p2+n), P3: !pole(p3)
) : void // end-of-function
//
')</pre>

<pre
class="patsyntax">
#pats2xhtml_dats('\
local
//
datavtype
pole_(n:int) =
Pole(n) of
(
  string, list_vt(int, n)
) (* end of [pole_] *)
//
assume pole(n:int) = pole_(n)
//
in (* in-of-local *)

implement
move_1(P1, P2) = let
//
val+@Pole(n1, rxs) = P1
val n1 = n1
val+~list_vt_cons(x, xs) = rxs
val ((*void*)) = rxs := xs
prval ((*folded*)) = fold@(P1)
//
val+@Pole(n2, rxs) = P2
val n2 = n2
val ((*void*)) = rxs := list_vt_cons(x, rxs)
prval ((*folded*)) = fold@(P2)
//
in
  println! ("Move [", x, "] from [", n1, "] to [", n2, "]")
end // end of [move_1]

end // end of [local]
')</pre>

<pre
class="patsyntax">
#pats2xhtml_dats('\
implement
move_n
(
  n, P1, P2, P3
) = (
//
if
n > 0
then () where
{
//
val n1 = n - 1
val () = move_n(n1, P1, P3, P2)
val () = move_1(P1, P2)
val () = move_n(n1, P3, P2, P1)
//
} (* end of [then] *)
else () // end of [else]
//
) (* end of [move_n] *)
')</pre>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
