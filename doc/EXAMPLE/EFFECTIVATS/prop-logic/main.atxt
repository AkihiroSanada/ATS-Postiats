%{
#include "./../ATEXT/atextfun.hats"
%}

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-prop-logic</title>
#patscode_style()
</head>

<body>

<h1>
Effective ATS:<br>
Encoding Propositional Logic
</h1>

<p>
In this article, I present a direct encoding of propositional
logic in ATS, illustrating through examples a simple form of
formalized theorem-proving.
</p>

<h2>
Encoding Truth Values
</h2>

<p>
The truth values are
encoded as abstract props #stacode("PTRUE") and #stacode("PFALSE"):

<pre
class="patsyntax">
#pats2xhtml_sats('\
absprop PTRUE // for true
absprop PFALSE // for false
')</pre>

There is one introduction rule but no elimimation rule for #dyncode("true"):

<pre
class="patsyntax">
#pats2xhtml_sats('\
praxi true_intr((*void*)): PTRUE
')</pre>

There is no introduction rule but one elimimation rule for #dyncode("false"):

<pre
class="patsyntax">
#pats2xhtml_sats('\
praxi false_elim{A:prop}(pf: PFALSE): A
')</pre>

Clearly, the rule #dyncode("false_elim") states that any proposition can be
derived from a proof of #dyncode("false").
</p>

<h2>
Encoding Negation
</h2>

<p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
absprop PNEG(A: prop) // for negation
propdef ~(A: prop) = PNEG(A) // shorthand
')</pre>

<pre
class="patsyntax">
#pats2xhtml_sats('\
praxi neg_intr{A:prop}(pf: A -> PFALSE): ~A
praxi neg_elim{A:prop}(pf1: A, pf2: ~A): PFALSE
')</pre>

<pre
class="patsyntax">
#pats2xhtml_sats('\
praxi neg_elim2{A:prop}{B:prop}(pf1: A, pf2: ~A): B
')</pre>

</p>

<h2>
Encoding Conjunction
</h2>


<p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
absprop
PCONJ(A: prop, B: prop)
propdef &&(A: prop, B: prop) = PCONJ(A, B)
//
praxi
conj_intr
  {A,B:prop} : (A, B) -> A && B
//
praxi
conj_elim_l{A,B:prop} : (A && B) -> A
praxi
conj_elim_r{A,B:prop} : (A && B) -> B
//
')</pre>

</p>


<h2>
Encoding Disjunction
</h2>

<p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
dataprop
PDISJ(A: prop, B: prop) =
  | disj_intr_l(A, B) of (A)
  | disj_intr_r(A, B) of (B)
//
propdef ||(A: prop, B: prop) = PDISJ(A, B)
//
prfun
disj_elim{A,B:prop}{C:prop}
  (fpf1: A -> C, fpf2: B -> C, pf3: A || B): C
//
')</pre>

</p>

<h2>
Encoding Implication
</h2>

<h2>
Encoding Equivalence
</h2>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
