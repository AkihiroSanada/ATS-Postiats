<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
   "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Effectivats-loop-as-tailrec</title>
</head>

<body>

<h1>
Effective ATS: Loops as Tail-Recursive Functions
</h1>

Although language constructs are available in ATS to support direct
construction of for-loops and while-loops, it is strongly recommended that
loops be implemented as tail-recursive functions. A primary advantage of
doing so is that this style of loop implementation can be readily combined
with theorem-proving as is supported in ATS, thus facilitatting program
verification involving loops.

<h2>
What is tail-recursion?
</h2>

Suppose that [foo] and [bar] are two functions and there is a call to [bar]
in the body of [foo]. This call is a tail-call if what it returns is also
the return value of [foo]. In other words, a function call in the body of
some calling function is a tail-call if the return value of the call is
also the return value of the calling function. For instance, the call to
[bar] is a tail-call in the following code but the call to [baz] is not:

<pre>
fun foo (x: int): int =
  if x > 0 then bar(x) else baz(x)+1
</pre>

By the way, even if [baz(x)+1] is changed into [baz(x)+0], the call to
[baz] is still not considered a tail-call unless [baz(x)+0] can somehow be
translated into [baz(x)].

<p>

If the calling function calls itself in a tail-call, then this tail-call is
often referred to as a tail-recursive call. A function is tail-recursive if
every recursive call in its body is a tail-call. In the following example,
the outside call to [f91] is tail-recursive but the inside one is not:

<pre>
fun f91 (x: int): int =
  if x >= 101 then x-10 else f91(f91(x+11))
</pre>

By definition, [f91] is not a tail-recursive function.

<h2>
Why is tail-recursion desirable?
</h2>

Each tail-recursive function can be readily implemented as a loop.  Assume
that a call stack is employed to implement function calls, which is by far
the most common implementation strategy in practice.  Then calling a
tail-recursive function only requires a fixed amount of stack space. In a
setting where stack space is greatly limited (e.g., low-level embedded
programming), tail-recursion is often the only form of recursion that is
legally allowed.  In short, tail-recursion is desirable because it can be
implemented in a much more efficient manner, both time-wise and
memory-wise, when compared with general recursion.

<h2>
Translating recursion into tail-recursion
</h2>

Given the advantage of tail-recursion, it is natural to encounter the need
for turning a recursive (but not tail-recursive) function into an
equivalent one that is also tail-recursive. While there is a systematic
approach to translating recursion into tail-recursion (CPS-translation),
the approach is in general not what one wants to use if one's focus is on
efficiency. Instead, one mostly relies on ad hoc methods or tricks to
handle each individual function. Let us now take a look at a concrete
example. The following code implements a function [tally] that sums up all
the integers between 1 and a given number n, inclusive:

<pre>
fun tally (n: int): int =
  if n > 0 then n + tally (n-1) else 0
</pre>

Clearly, [tally] is not tail-recursive. If we translate this implementation
of [tally] into C, we essentially obtain the following code:

<pre>
int tally (int n)
{
  return (n > 0) ? n + tally (n-1) : 0 ;
}
</pre>

This implementation of [tally] in C is a bit unusual as a standard one is
expected to be based on a for-loop:

<pre>
int tally2 (int n)
{
  int i ;
  int res = 0 ;
  for (i = n ; i > 0 ; i--) res += i ;
  return res ;
}
</pre>

It should be pointed out that the equivalence between [tally] and [tally2]
relies on the fact that integer addition is <em>associative</em>. If
addition is replaced with subtraction, which is not associative, then these
two implementations are no longer equivalent.

<p>

A straightforward translation of the above implementation of [tally2] in C
into ATS yields the following code:

<pre>
fun tally2
  (n: int): int = let
//
fun loop
  (n: int, res: int): int =
  if n > 0 then loop (n-1, res+n) else res
//
in
  loop (n, 0)
end // end of [tally2]
</pre>

Please note that the inner function [loop] is tail-recursive. The
compiler of ATS (ATS/Postiats) essentially compiles [loop] into
some code in C that is equivalent to the for-loop mentioned above.

<p>

In general, the process of translating a recursive function into a
tail-recursive one hinges on finding an efficient way to encode the stack
generated during the execution of the function. For instance, suppose we
call [tally] on 100; this call generates a recursive call on 99, and then
a recursive call on 98, and so on; when [tally] is called on 50, the call
stack essentially represents the following evaluation context:

<pre>
100 + (99 + (98 + (... + (51 + []) ...)))
</pre>

where the symbol [] is to be replaced with the return value of [tally(50)].
As integer addition is associative, we can use the sum (100+99+98+...+51)
to represent this evaluation context. This is precisely the idea behind the
implementation of the inner function [loop] in the body of [tally2].

<h2>
Mutually tail-recursive functions
</h2>

Sometimes, we need to combine functions together in order to turn mutully
tail-recursive calls into local jumps. For instance, in the following code,
[isevn] and [isodd] are defined mutually recursively:

<pre>
fun isevn (n: int): bool =
  if n > 0 then isodd (n-1) else true
and isodd (n: int): bool =
  if n > 0 then isevn (n-1) else false
</pre>

The call to [isodd] in the body of [isevn] and the call to [isevn] in the
body of [isadd] are both tail-calls. As they are also mutually recursive
calls, they are referred to as mutually tail-recursive calls.

<p>

When compiling this implementation of [isevn] and [isadd], the ATS compiler
(ATS/Postiats) handles [isevn] and [isodd] separately and thus
is <em>unable</em> to turn the call to [isodd] ([isevn]) in the body of
[isevn] ([isodd]) into a local jump. In order to indicate to the compiler
that these two functions need to be combined for compilation, the keyword
[fun] should be replaced with another keywork [fnx]:

<pre>
fnx isevn (n: int): bool =
  if n > 0 then isodd (n-1) else true
and isodd (n: int): bool =
  if n > 0 then isevn (n-1) else false
</pre>

After this change, only the function [isevn] is available for subsequent
use while the function [isodd] is no longer available.

<hr>

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>
