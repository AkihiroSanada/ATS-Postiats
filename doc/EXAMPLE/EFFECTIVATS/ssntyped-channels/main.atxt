%{
#include "./../ATEXT/atextfun.hats"
%}

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-ssntyped-channels</title>
#patscode_style()
</head>

<body>

<h1>
Effective ATS:<br>
Session-typed Channels
</h1>

<p>
In this article, I present a brief introduction to session types.
</p>

<p>
In broad terms, a (dyadic) session is a sequence of interactions between
two concurrently running processes, and a session type is a form of type
for specifying (or classifying) such interactions. As an example, let us
assume that two processes P and Q are connected via a bidirectional
channel. From the perspective of P, the channel may be specified by a term
sequence of the following form: </p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
typedef P_ssn = chsnd(int)::chsnd(int)::chrcv(bool)::chnil
')</pre>

<p>
which means that an integer is to be sent, another integer is to be
sent, a boolean is to be received, and finally the channel is to be
closed.  Clearly, from the perspective of Q, the channel should be
specified by the following term sequence:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
typedef Q_ssn = chrcv(int)::chrcv(int)::chsnd(bool)::chnil
')</pre>

<p>
which means precisely the dual of what the previous term sequence
does.  We may think of P as a client who sends two integers to the
server Q and then receives from Q either true or false depending on
whether or not the first sent integer is less than the second one.
</p>

<p>
There are two endpoints in a channel: a positive end and a negative end;
the end held by the server is positive and the end held by the client is
negative. We introduce two abstract types #stacode("chanpos") and
#stacode("channeg") for positive channels and negative channels,
respectively, where a positive (negative) channel refers to the positive
(negative) end of a channel:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
abstype chanpos(ssn:type)
abstype channeg(ssn:type)
')</pre>

<p>
For instance, the end of the channel held by P is assigned the
type #stacode("channeg(Q_ssn)") (not #stacode("channeg(P_ssn)")) and
the end of the channel held by Q is assigned the type #stacode("chanpos(Q_ssn)").
So the interpretation of a session type is given based on the view of the
positive end (that is, the server).
</p>

<p>
The functions for sending values on channels are given the following types:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
chanpos_send
  {a:vt0p}{ss:type}
(
  chp: !chanpos(chsnd(a)::ss) >> chanpos(ss), x: a
) : void = "mac#%" // end-of-function
//
fun
channeg_recv
  {a:vt0p}{ss:type}
(
  chn: !channeg(chrcv(a)::ss) >> channeg(ss), x: a
) : void = "mac#%" // end-of-function
//
overload channel_send with chanpos_send
overload channel_send with channeg_recv
//
')</pre>

<p>
Note that #dyncode("chanpos_send") is for sending a value on a positive
channel while #dyncode("channeg_recv") is for sending a value on a
negative channel. For convenience, the symbol #dyncode("channel_send") is
overloaded with both of these functions.
</p>

<p>
The functions for receiving values on channels are given the following types:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
chanpos_recv
  {a:vt0p}{ss:type}
  (!chanpos(chrcv(a)::ss) >> chanpos(ss)): a = "mac#%"
//
fun
channeg_send
  {a:vt0p}{ss:type}
  (!channeg(chsnd(a)::ss) >> channeg(ss)): a = "mac#%"
//
overload channel_recv with chanpos_recv
overload channel_recv with channeg_send
//
')</pre>

<p>
Note that #dyncode("chanpos_recv") is for receiving a value on a positive
channel while #dyncode("channeg_send") is for receiving a value on a
negative channel. For convenience, the symbol #dyncode("channel_recv") is
overloaded with both of these functions.
</p>

<pre
class="patsyntax">
#pats2xhtml_dats('\
fun
P (
  chn: channeg(Q_ssn), i1: int, i2: int
) : bool = lt where
{
  val () = channel_send(chn, i1)
  val () = channel_send(chn, i2)
  val lt = channel_recv(chn)
  val () = channel_close(chn)
}

(* ****** ****** *)

fun
Q (
  chp: chanpos(Q_ssn)
) : void =
{
  val i1 = channel_recv(chp)
  val i2 = channel_recv(chp)
  val () = channel_send(chp, i1 < i2)
  val () = channel_close(chp)
}
')</pre>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
