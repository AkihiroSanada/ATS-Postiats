%{
#include "./../ATEXT/atextfun.hats"
%}

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-ssntyped-channels</title>
#patscode_style()
</head>

<body>

<h1>
Effective ATS:<br>
Session-typed Channels
</h1>

<p>
In this article, I present a brief introduction to session types.
</p>

<h2>
Basics on session-typed channels
</h2>

<p>
In broad terms, a (dyadic) session is a sequence of interactions between
two concurrently running processes, and a session type is a form of type
for specifying (or classifying) such interactions. As an example, let us
assume that two processes P and Q are connected via a bidirectional
channel. From the perspective of P, the channel may be specified by a term
sequence of the following form: </p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
typedef P_ssn = chsnd(int)::chsnd(int)::chrcv(bool)::chnil
')</pre>

<p>
which means that an integer is to be sent, another integer is to be
sent, a boolean is to be received, and finally the channel is to be
closed.  Clearly, from the perspective of Q, the channel should be
specified by the following term sequence:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
typedef Q_ssn = chrcv(int)::chrcv(int)::chsnd(bool)::chnil
')</pre>

<p>
which means precisely the dual of what the previous term sequence
does.  We may think of P as a client who sends two integers to the
server Q and then receives from Q either true or false depending on
whether or not the first sent integer is less than the second one.
</p>

<p>
There are two endpoints in a channel: a positive end and a negative end;
the end held by the server is positive and the end held by the client is
negative. We introduce two abstract types #stacode("chanpos") and
#stacode("channeg") for positive channels and negative channels,
respectively, where a positive (negative) channel refers to the positive
(negative) end of a channel:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
abstype chanpos(ssn:type)
abstype channeg(ssn:type)
')</pre>

<p>
For instance, the end of the channel held by P is assigned the
type #stacode("channeg(Q_ssn)") (not #stacode("channeg(P_ssn)")) and
the end of the channel held by Q is assigned the type #stacode("chanpos(Q_ssn)").
So the interpretation of a session type is given based on the view of the
positive end (that is, the server).
</p>

<p>
The functions for sending values on channels are given the following types:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
chanpos_send
  {a:vt0p}{ss:type}
(
  chp: !chanpos(chsnd(a)::ss) >> chanpos(ss), x: a
) : void // end-of-function
//
fun
channeg_recv
  {a:vt0p}{ss:type}
(
  chn: !channeg(chrcv(a)::ss) >> channeg(ss), x: a
) : void // end-of-function
//
overload channel_send with chanpos_send
overload channel_send with channeg_recv
//
')</pre>

<p>
Note that #dyncode("chanpos_send") is for sending a value on a positive
channel while #dyncode("channeg_recv") is for sending a value on a
negative channel. For convenience, the symbol #dyncode("channel_send") is
overloaded with both of these functions.
</p>

<p>
The functions for receiving values on channels are given the following types:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
chanpos_recv
  {a:vt0p}{ss:type}
  (!chanpos(chrcv(a)::ss) >> chanpos(ss)): a
//
fun
channeg_send
  {a:vt0p}{ss:type}
  (!channeg(chsnd(a)::ss) >> channeg(ss)): a
//
overload channel_recv with chanpos_recv
overload channel_recv with channeg_send
//
')</pre>

<p>
Note that #dyncode("chanpos_recv") is for receiving a value on a positive
channel while #dyncode("channeg_send") is for receiving a value on a
negative channel. For convenience, the symbol #dyncode("channel_recv") is
overloaded with both of these functions.
</p>

<p>
The functions for closing channels are given the following types:
</p>

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
chanpos_nil_wait (chp: chanpos(chnil)): void
fun
channeg_nil_close (chn: channeg(chnil)): void
//
overload channel_close with chanpos_nil_wait
overload channel_close with channeg_nil_close
//
')</pre>

<p>
Note that #dyncode("chanpos_nil_wait") is for closing a positive
channel while #dyncode("channeg_nil_close") is for closing a negative
channel. For convenience, the symbol #dyncode("channel_close") is
overloaded with both of these functions.
</p>

<p>
The programs for the processes P and Q can be implemented as follows:
</p>

<pre
class="patsyntax">
#pats2xhtml_dats('\
(* ****** ****** *)

fun
P (
  i1: int, i2: int
, chn: channeg(Q_ssn)
) : bool = lt where
{
  val () = channel_send(chn, i1)
  val () = channel_send(chn, i2)
  val lt = channel_recv(chn)
  val () = channel_close(chn)
}

(* ****** ****** *)

fun
Q (
  chp: chanpos(Q_ssn)
) : void =
{
  val i1 = channel_recv(chp)
  val i2 = channel_recv(chp)
  val () = channel_send(chp, i1 < i2)
  val () = channel_close(chp)
}

(* ****** ****** *)
')</pre>

<p>
But how a channel can be created in the first place? The answer
to this question depends on the underlying support for distributed
programming. For instance, we may be able to introduce the following
function #dyncode("channel_create") for creating a channel:

<pre
class="patsyntax">
#pats2xhtml_sats('\
fun
channeg_create{ss:type}
  (fserv: chanpos(ss) -<lincloptr1> void): channeg(ss)
')</pre>

The basic idea here is to spawn a thread (by executing the linear
closure-function #dyncode("fserv")) that works on the postive end of
the newly created channel and then returns the negative end of the
channel to the caller.
</p>

<h2>
Session-typed channels based on web-workers
</h2>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
