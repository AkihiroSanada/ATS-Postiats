<!DOCTYPE html>
<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-GraphSearch</title>
##patsyntax()
##thePage_style()
</head>

<body>

<h1>
Effective ATS:<br>
A Template-Based Implementation of Graph Search
</h1>

##para('\

ATS is a feature-rich language, and dependent types, linear types
and embeddable templates can be seen as three of its most prominent
features. In this article, I present a concrete example to illustrate
that embeddable templates can play a pivotal role in support of a
style of refinement-based programming.

')##comment("para")

<h2>Generic Graph Search</h2>

##para('\

Abstractly speaking, a graph is a (possibly infinite) collection of
nodes and each node is associated with a set of nodes that are
referred to as its neighbors. Let us introduce an abstract type
##stacode("node") for the nodes in a given graph (on which some kind
search is to be performed):

<pre
class="patsyntax">
##dats2xhtml('\
//
abstype node = ptr
typedef nodelst = list0(node)
//
extern
fun
node_get_neighbors(nx: node): nodelst
//
')</pre>

Clearly, the interface assigned to ##dyncode("node_get_neighbors")
imposes the assumption that the set of neighbors of each node is finite.

')##comment("para")

##para('\

A common approach to searching a graph employs a store for nodes
that are to be processed. The search is over if the store becomes
empty. Otherwise, a node is chosen from the store to be processed
and all of its neighbors are put into the store. Let us introduce
a function ##dyncode("process_node") as follows for processing each
chosen node:

<pre
class="patsyntax">
##dats2xhtml('\
//
extern
fun{}
process_node(nx: node): bool
//
')</pre>

Note that a call to ##dyncode("process_node") returns a boolean value
to indicate whether the search should continue or stop immediate.

')##comment("para")

<hr size="2">
<p>
This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</p>
##thePage_script()
</body>
</html>
