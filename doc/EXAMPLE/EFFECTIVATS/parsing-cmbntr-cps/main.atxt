%{
#include "./../ATEXT/atextfun.hats"
%}

<!DOCTYPE html>
<html>

<head>
<meta
 http-equiv="content-type"
 content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-parsing-cmbntr-cps</title>
#patscode_style()
</head>

<body>

<h1>
Effective ATS:<br>
Combinators for Parsing in CPS-style
</h1>

<p>
In this article, I present a brief introduction to parsing combinators
that are designed to facilitate parser implementation in CPS-style. This
is also an occassion for me to advocate the use of abstract types in
programming via a concrete case.
</p>

<h2>
Parsers of CPS-style
</h2>

<p>
Let us first take a look at the following two type definitions:

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
typedef
parcont
  (a:t@ype) = (a, parinp) -<cloref1> parout
//
typedef
parinp_nullify
  (a:t@ype) = (parinp, parcont(a)) -<cloref1> parout
//
')</pre>

The types #stacode("parinp") and #stacode("parout") are abstract at
this stage. Intuitively, #stacode("parinp") is meant to be the type for
the parsing input and #stacode("parout") the type for the parsing output.
Given a type T, the type #stacode("parcont(T)") is for a continuation of a
parser that is supposed to return a value of the type T; the type
#stacode("parinp_nullify(T)") is for a parser of CPS-style that parses
some input into a value of the type T and then passes the value and
the remaining input to a continuation of the type #stacode("parcont(T)").

</p>

<p>

<pre
class="patsyntax">
#pats2xhtml_dats('\
//
extern
castfn
kparser_encode
  {a:t@ype}(parinp_nullify(a)): kparser(a)
//
extern
castfn
kparser_decode{a:t@ype}(kparser(a)): parinp_nullify(a)
//
')</pre>

</p>


<h2>
Parsing Combinators
</h2>

<p>
Generally speaking, parsing combinators are functions designed
for constructing parsers. While a parsing combinator is often called
on some existing parsers to construct a new parser, it is not uncommon
to see one that takes as its arguments values that are not parsers.
I present as follows some common parsing combinators.
</p>

<p>
Two combinators
#dyncode("kparser_fail") and #dyncode("kparser_just")
are given the following types:

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
{a:t@ype}
kparser_fail(): kparser(a)
//
fun
{a:t@ype}
kparser_just(x: a): kparser(a)
//
')</pre>

Calling #dyncode("kparser_fail") simply raises an exception.
Given a value, #dyncode("kparser_just") simply returns the value
without consuming any input.

</p>

<p>
Given a parser and a predicate,
the combinator #dyncode("kparser_satisfy") constructs
another parser that only returns if the value returned
by the given parser satisfies the predicate:

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
{a:t@ype}
kparser_satisfy
(
  kparser(a), test: cfun1(a, bool)
) : kparser(a) // end-of-fun
//
')</pre>
</p>

<p>
Given a parser and a function, the combinator #dyncode("kparser_fmap")
constructs another parser that returns a value obtained from applying
the given function to the value returned by the given parser:

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
{a:t@ype}
{b:t@ype}
kparser_fmap
(
  kp: kparser(a), fmap: cfun1(a, b)
) : kparser(b) // end-of-fun
//
')</pre>
</p>

<p>
Given two parsers, the combinator #dyncode("kparser_join")
constructs a new parser that essentially calls the two parsers
consecutively and then combines the values returned by them to form
a tuple:

<pre
class="patsyntax">
#pats2xhtml_sats('\
//
fun
{a1
,a2:t@ype}
kparser_join
(
  kp1: kparser(a1), kp2: kparser(a2)
) : kparser(@(a1, a2)) // end-of-fun
//
')</pre>
</p>

<hr size="2">

This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.

</body>
</html>

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

