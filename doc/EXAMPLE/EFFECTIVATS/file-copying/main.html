<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
   "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>Effectivats-file-copying-1</title>
</head>

<body>

<h1>
Effective ATS: Copying Files (1)
</h1>

While the task of copying files is conceptually simple, it can still be
quite interesting to implement in ATS.

<p>

In order to copy the content of one file into anther, we need a means to
refer to the involved files. In Linux, the notion of file descriptor serves
precisely this purpose. Although we know that a file descriptor is
represented as an integer, it seems appropriate to make it abstract as is
done in the following declaration:

<pre>
abst@ype filedes = int
</pre>

Often it is a good practice to give an abstract type a name that is less
likely to cause collision and then introduce a short alias for the name.
For instance, the following declarations demonstrate such a practice:

<pre>
abst@ype filedes_t0ype = int
stadef filedes: t@ype = filedes_t0ype
</pre>

My naming convention uses the special identifier [t0ype] to indicate
a type of the sort t@ype, that is, a type of unknown size. Note that
the stadef-declaration can also be replaced with the following one:

<pre>
typedef filedes = filedes_t0ype
</pre>

Now let us name the file-copying function [fcopy] and give it
the following interface:

<pre>
fun fcopy (src: fildes, dst: fildes): void
</pre>

How should we implement [fcopy]? For the moment, let us try to answer this
question in a somewhat abstract manner.

<p>

Clearly, we should be able to read chars from [src] and also write chars
into [dst]. So let us assume that the following two functions are available
for use:

<pre>
fun readch (src: fildes): char
fun writech (src: fildes, c: char): void
</pre>

There is yet one more thing: We should be able to tell whether we have
finished reading all the chars from a given file. One simple way to do
this is to require that [readch] return a special value to indicate the
end of a file being reached. For this purpose, we modify the interface
of [readch] as follows:

<pre>
fun readch (src: fildes): int
</pre>

We use natural numbers, that is, non-negative integers for valid chars and
a negative integer (e.g., -1) for the special value (indicating that the
end of [src] is reached). Now we can readily implement [fcopy] as follows:

<pre>
implement
fcopy (src, dst) = let
  val c = readch (src)
in
//
if c >= 0 then
  (writech (dst, c); fcopy (src, dst))
// end of [if]
//
end (* end of [fcopy] *)
</pre>

Now it is time to raise the obvious question: How can functions [readch]
and [writech] be implemented? They can be implemented based on the system
calls [read] and [write]. Please find the code of a running implementation
of [fcopy] in fcopy-1.dats, where [readch] and [writech] are implement in C
directly.

<p>

Of course, there is a lot of criticism that can be said about the above
implementation of [fcopy]. For instance, it is terribly inefficient; it
does not support any error-handling at all; etc. I will attempt to address
these issues elsewhere. However, one thing that is extremely positive in
this implementation is the introduction of functions [readch] and
[writech], which adds a layer to shield system calls [read] and [write]
from being used directly. This is a programming style I would recommend
highly and repeatedly.

</body>
</html>
