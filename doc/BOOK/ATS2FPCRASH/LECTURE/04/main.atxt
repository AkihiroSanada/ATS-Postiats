%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture04">
#title("Higher-Order Functions")

#para("\

In ATS, an anonymous function can be defined as a
lambda-abstraction. For instance, the square function on integers can
be defined as follows:

#dats2xhtml('\
//
val
square = lam(x: int): int => x * x
//
')

where the keyword #keycode("lam") is for constructing a
lambda-abstraction.  For defining a recursive anonymous function, the
keyword #keycode("fix") needed. For instance, the factorial function
can also be implemented as follows:

#dats2xhtml('\
//
val fact =
fix f(x: int): int => if x > 0 then x * f(x) else 1
//
')

A function value can be passed as a function argument just like any
other values, and a higher-order function refers to one that takes a
function value as its argument. As far as terminology is concerned, a
first-order function takes no function arguments; a second-order
function takes a first-order function as its argument; a third-order
function takes a second-order function as its argument; etc. In
practice, higher-order functions are overwhelmingly second-order ones.

")

#para("\

At this point, I want to digress a bit by advocating a so-called
#emphasis("build-your-own-library") approach to learning
programming. Often a limitation faced by someone learning programming
is that one does not have many opportunities to actually use the code
written by oneself. For instance, we rarely see a case where someone
makes extensive use of a data structure (such as hash table and
associative map) implemented by his or her own. Most likely, one
implements some data structure for the purpose of learning about it
and then throws the code away afterwards. My own experience strongly
indicates that one can learn a great deal more about programming if
one insists on calling library functions implemented by oneself. From
this point on, I will gradually build a library for this book and I
encourage everyone reading the book to study the source code for the library
<ulink url=\"https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FPCRASH/LECTURE/MYLIB\">on-line</ulink>.

")

#para("\

As an example of higher-order function, let us implement a commonly
used library function of the name #dyncode("int_foreach"):

#dats2xhtml('\
//
extern
fun
int_foreach
(n0: int, fwork: cfun(int, void)): void
//
')

Note that the type #stacode("cfun(int, void)") is just a shorthand for
#stacode("(int) -&lt;cloref1&gt; void"), which is assigned to a
closure-function that takes an integer argument and returns void.
There are two kinds of functions in ATS: envless function and
closure-function; the former is just a function in the sense of C: a
function pointer to some memory location where a sequence of
instructions is stored; the latter is essentially a function pointer
paired with an environment (represented as a tuple of values) for
certain paramemters. For an envless function from #stacode("int") to
#stacode("void"), its type is written as #stacode("(int) -&gt; void")
or #stacode("(int) -&lt;fun1&gt; void").  While turning an envless
function into a closure-function is straightforward, there is no
generic method for turning a closure-function into an envless
function. Note that each function argument of a higher-order function
is usually chosen to be a closure-function so as to make the
higher-order function more applicable.

")

#para("\

A standard implementation of #dyncode("int_foreach") is given as
follows:

#dats2xhtml('\
//
implement
int_foreach
(n0, fwork) =
loop(0) where {
  fun
  loop(i: int): void =
    if i < n0 then (fwork(i); loop(i+1)) else ()
  // end of [fun loop]
} (* end of [int_foreach] *)
//
')

")

#para("\

For testing #dyncode("fact") (that implements the factorial
function), we can simply make a call to #dyncode("int_foreach")
as follows:

#dats2xhtml('\
//
fun
testfact(n: int): void =
int_foreach(n, lam(i) => println!("fact(", i, ") = ", fact(i)))
//
')

")

#para("\

As another example, let us implement a higher-order function of the
name #dyncode("int_foldleft") as follows:

#dats2xhtml('\
//
extern
fun
{res:t@ype}
int_foldleft
( n0: int
, res: res, fopr: cfun(res, int, res)): res
//
implement
{res}(*tmp*)
int_foldleft
  (n0, res, fopr) =
  loop(res, 0) where
{
//
fun loop(res: res, i: int): res =
  if i < n0 then loop(fopr(res, i), i+1) else res
//
} (* end of [int_foldleft] *)
//
')

Note that #dyncode("int_foldleft") is declared as a function template.
For someone who knows the standard left-folding function on a list
(for folding the list from left to right), #dyncode("int_foldleft")
does essentially the same as left-folding a list consisting of
integers from #dyncode("0") to #dyncode("n-1"), where #dyncode("n") is
the first argument passed to #dyncode("int_foldleft"). For instance,
we can implement the factorial function as follows:

#dats2xhtml('\
//
fun
fact(n: int): int =
int_foldleft<int>(n, 1, lam(res, i) => res * (i+1))
//
')

If we want a function #dyncode("sqsum") to sum up the squares of the
first #dyncode("n") positive integers for any given natural number
#dyncode("n"), we can implement it with a call to #dyncode("int_foldleft") as well:

#dats2xhtml('\
//
fun
sq(i: int): int = i*i
fun
sqsum(n: int): int =
int_foldleft<int>(n, 0, lam(res, i) => res * sq(i+1))
//
')

")

#para("\

Please find #mycodelink("LECTURE/04/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture04"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

