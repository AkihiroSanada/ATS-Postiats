%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture07-10">
#title("Example: Game of Twenty-four")

#para("\

Given four integers n1, n2, n3 and n4, one chooses two and uses them
to produce a rational number r1 by applying either addition,
subtraction, multiplication or division; one mixes r1 with the
remaining two numbers and chooses two of them to produce a rational
number r2 by applying either addition, subtraction, multiplication or
division; one then takes r2 and the last remaining number to produce a
rational number r3 by applying addition, subtraction, multiplication,
or division; if there exists a way to make r3 equal 24, then (n1, n2,
n3, n4) is said to be a good quad. For instance, (10,10,4,4) is a good
quad since we have: (10*10-4)/4 = 24; (5,7,7,11) is a good quad since
we have: (5-11/7)*7 = 24. Game-of-24 is a game that determines whether
four given integers form a good quad or not.

")

#para("\

In the following presentation of this chapter, I intend to present an
implementation of Game-of-24 in pure functional style, solidifying
various functional programming concepts covered so far. Please pay
attention to the support for overloading in ATS, which helps make
the presented code significantly easier to access.\

")

#para("\

Instead of making direct use of rational numbers in the
implementation, I choose doubles (that is, floating point numbers of
double precision) to approaximate them.  The following declarations
introduce #dyncode("int2dbl") and #dyncode("dbl2int") for casting
integers to doubles and vice versa, respectively:

#dats2xhtml('\
//
\#define
int2dbl g0int2float_int_double
\#define
dbl2int g0float2int_double_int
//
')

")

#para("\

In the case where four given integers are claimed to form a good quad,
we may want to see a proof to justify the claim. The following
datatype #stacode("expr") is meant for providing such a proof:

#dats2xhtml('\
//
datatype expr =
  | EXPRnum of double
  | EXPRbop of (string(*opr*), expr, expr)
//
typedef exprlst = list0(expr)
//
')

For instance, the expression #dyncode("(10*10-4)/4") can be represented
as a value of the type #stacode("expr"):

#dats2xhtml('\
//
val myproof =
EXPRbop("/", EXPRbop("-", EXPRbop("*", EXPRnum(10), EXPRnum(10)), EXPRnum(4)), EXPRnum(4))
//
')

Note that values of the type #stacode("expr") is often referred as
abstract syntax trees.

")

#para("\

Given an expression (that is, an expr-value), the following function
#dyncode("eval_expr") returns the value of the expression:

#dats2xhtml('\
//
extern
fun
eval_expr(x0: expr): double
//
overload eval with eval_expr
//
implement
eval_expr(x0) =
(
case+ x0 of
| EXPRnum(v0) => v0
| EXPRbop(opr, x1, x2) => let
    val v1 = eval_expr(x1)
    val v2 = eval_expr(x2)
  in
    case+ opr of
    | "+" => v1 + v2
    | "-" => v1 - v2
    | "*" => v1 * v2
    | "/" => v1 / v2
    | _(*unrecognized*) =>
      let val () = assertloc(false) in 0.0 end
  end
) (* end of [eval_expr] *)
//
')

")

#para("\

The following functions #dyncode("print_expr") and
#dyncode("fprint_expr") are needed for displaying an expression (that
is, an expr-value):

#dats2xhtml('\
//
extern
fun
print_expr : (expr) -> void
extern
fun
fprint_expr : (FILEref, expr) -> void
//
overload print with print_expr
overload fprint with fprint_expr
//
(* ****** ****** *)
//
implement
print_expr(x0) =
fprint_expr(stdout_ref, x0)
//
implement
fprint_expr(out, x0) =
(
case x0 of
| EXPRnum(v0) =>
  fprint(out, dbl2int(v0))
| EXPRbop(opr, x1, x2) =>
  fprint!(out, "(", x1, opr, x2, ")")
)
//
')

")

#para("\

The following functions are introduced for constructing abstract
syntax trees to represent the 4 arithmetic operations: addition,
subtraction, multiplication, and division:

#dats2xhtml('\
//
extern
fun
add_expr_expr
  : (expr, expr) -> expr
and
sub_expr_expr
  : (expr, expr) -> expr
and
mul_expr_expr
  : (expr, expr) -> expr
and
div_expr_expr
  : (expr, expr) -> expr
//
overload + with add_expr_expr
overload - with sub_expr_expr
overload * with mul_expr_expr
overload / with div_expr_expr
//
(* ****** ****** *)
//
implement
add_expr_expr(x1, x2) = EXPRbop("+", x1, x2)
implement
sub_expr_expr(x1, x2) = EXPRbop("-", x1, x2)
implement
mul_expr_expr(x1, x2) = EXPRbop("*", x1, x2)
implement
div_expr_expr(x1, x2) = EXPRbop("/", x1, x2)
//
')

By overloading familiar symbols like #dyncode("+"), #dyncode("-"),
#dyncode("*"), and #dyncode("/"), I expect that the presented code
should be easier to access (even for someone who knows very little
about the programming language in which the code is written).

")

#para("\

When using floating point numbers, one often needs to
pay special attention equality test. For testing whether
the value of an expression equals a given integer, the following
function #dyncode("eq_expr_int") checks whether the absolute
difference between the value and the integer is less than
a tiny fraction #dyncode("EPSILON"):

#dats2xhtml('\
//
\#define EPSILON 1E-8
//
extern
fun
eq_expr_int(expr, int): bool
//
overload = with eq_expr_int
//
implement
eq_expr_int(x0, i0) = abs(eval_expr(x0) - i0) < EPSILON
//
')

I must say that choosing #dyncode("EPSILON") to be 10#sup("-8")
is an empirical decision (aimed at handling inputs that are small
integers (e.g., between 0 and 100)).

")

#para("\

What is done so far can be thought of as providing basic setup
for the task of implementing Game-of-24. It is time for us to switch
to the algorithmic part of the task next.

")

#para("\

Given two expressions, the function #dyncode("combine_expr_expr")
returns a list consisting of every expression that can be constructed
by applying addition, subtraction, multiplication, or division to the
two given ones:

#dats2xhtml('\
//
extern
fun
combine_expr_expr(expr, expr): exprlst
//
overload combine with combine_expr_expr
//
(* ****** ****** *)
//
implement
combine_expr_expr
  (x1, x2) = res where
{
//
val res = list0_nil()
val res = list0_cons(x1+x2, res)
val res = list0_cons(x1-x2, res)
val res = list0_cons(x2-x1, res)
val res = list0_cons(x1*x2, res)
val res = if x2 = 0 then res else list0_cons(x1/x2, res)
val res = if x1 = 0 then res else list0_cons(x2/x1, res)
//
val res = list0_reverse(res)
//
} (* end of [combine_expr_expr] *)
//
')

Please note that the divisor must be non-zero if the division
operation is applied.

")

#para("\

#dats2xhtml('\
//
extern
fun
do_one
(xs: task): list0(task)
//
extern
fun
do_ones
(n: int, xss: list0(task)): list0(task)
//
(* ****** ****** *)
//
implement
do_one(xs) = let
//
val x1x2xss =
list0_nchoose_rest<expr>(xs, 2)
//
in
//
list0_mapjoin<$tup(exprlst, exprlst)><task>
(
x1x2xss
,
lam
($tup(x1x2, xs)) =>
list0_map<expr><task>
 (combine(x1x2[0], x1x2[1]), lam(x) => list0_cons(x, xs))
)
//
end // end of [do_one]
//
(* ****** ****** *)
//
implement
do_ones(n, xss) =
if n >= 2
  then
  do_ones
  ( n-1
  , list0_mapjoin<task><task>(xss, lam(xs) => do_one(xs))
  ) (* do_ones *)
  else xss
//
')

")

#para("\

Please find #mycodelink("LECTURE/07-10/CODE", "on-line") the entirety of
the code used in this chapter. The mentioned URL link(s) can be found as follows:

")#comment("para")

</chapter><!--id="lecture07-10"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

