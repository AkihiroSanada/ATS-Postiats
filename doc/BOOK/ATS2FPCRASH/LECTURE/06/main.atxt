%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture06">
#title("Functional List-Processing (2)")

#para("\

I would like to first point out in this chapter a very common mistake
in (functional) list-processing. First and foremost, a list is not
meant to be used like an array. The following function #dyncode("list0_get_at")
does the so-called list-subscripting:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_get_at
(xs: list0(a), n: int): a
//
implement
{a}(*tmp*)
list0_get_at
  (xs, n) =
(
case+ xs of
| list0_nil() =>
  $raise ListSubscriptExn()
| list0_cons(x, xs) =>
  if n <= 0 then x else list0_get_at<a>(xs, n-1)
)
//
')

For instance, given the list #dyncode("(1,10,100)") and
the index #dyncode("1"), #dyncode("list0_get_at") return the element
#dyncode("10").  Another common name for #dyncode("list0_get_at") is
#dyncode("list0_nth").  Note that the code #dyncode("$raise
ListSubscriptExn()") is for raising an exception (in the case where
the given #dyncode("n") is greater than or equal to the length of the
given #dyncode("xs")), which is to be explained in details later.
Clearly, the time-complexity of #dyncode("list0_get_at") is O(n)
(while array-subscripting is O(1)-time). It is almost always a poor
programming style to process the elements in a list by calling
#dyncode("list0_get_at") (as the resulting code is likely to be
prohibitively inefficient time-wise). For the purpose of illustration,
let us take a look at the following two functions for tallying the
integers contained in a given list:

#dats2xhtml('\
//
fun
list0_tally1
  (xs: list0(int)): int =
  list0_foldleft<int><int>(xs, 0, lam(res, x) => res + x)
//
fun
list0_tally2
  (xs: list0(int)): int =
  int_foldleft<int>
  (list0_length(xs), 0, lam(res, i) => res + list0_get_at<int>(xs, i))
//
')

Given a list #dyncode("xs") of length n, the function
#dyncode("list0_tally1") is O(n)-time while the function
#dyncode("list0_tally2") is O(n#sup("2"))-time. List-processing should
be done in the efficient style of #dyncode("list0_tally1") rather than
in the terribly inefficient style of #dyncode("list0_tally2"). In
general, please try to avoid doing list-subscripting repeatedly if the
involved index cannot be bounded by a small constant!

")

#para("\

Let us see more functions for performing functional
list-processing in the following presentation and an
example of functional programming at the end that illustrates some
typical use of list-processing functions.

")

#para("\

A commonly used (higher-order) function is often referred to as
list-map, which takes a list and a function and returns a newly
constructed list consisting of all of the elements obtained from
applying the function to each element in the given list:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list0_map
(xs: list0(a), fopr: cfun(a, b)): list0(b)
//
implement
{a}{b}
list0_map
(
  xs, fopr
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(x), auxlst(xs))
)
//
} (* end of [list0_map] *)
//
')

For instance, given the list #dyncode("(1, 2, 3, 4, 5)") and the
integer square function, #dyncode("list0_map") returns the list
consisting of #dyncode("1"), #dyncode("4"), #dyncode("9"),
#dyncode("16"), and #dyncode("25").\

")

#para("\

With #dyncode("list0_map"), we can readily build #dyncode("list0_cross")
as follows for computing the cross product of two given lists:

#dats2xhtml('\
//
extern
fun
{a,b:t@ype}
list0_cross
(xs: list0(a), ys: list0(b)): list0($tup(a, b))
//
implement
{a,b}(*tmp*)
list0_cross
  (xs, ys) = let
//
typedef ab = $tup(a, b)
//
in
//
list0_concat // for concatenating a list of lists
(
list0_map<a><list0(ab)>
  (xs, lam(x) => list0_map<b><ab>(ys, lam(y) => $tup(x, y)))
) (* end of [list0_concat] *)
//
end // end of [list0_cross]
//
')

For instance, given two lists #dyncode("(0, 1)")
and #dyncode("(2, 3, 4)"), #dyncode("list0_cross") returns a newly
constructed list consisting of the following six pairs: #dyncode("(0,
2)"), #dyncode("(0, 3)"), #dyncode("(0, 4)"), #dyncode("(1, 2)"),
#dyncode("(2, 3)"), and #dyncode("(3, 4)").

")

#para("\

A function rather similar to #dyncode("list0_map") is
#dyncode("list0_foreach"), which takes a list and a procedure (i.e., a
function returning void) and applies the procedure to each element in
the list:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_foreach
(xs: list0(a), fwork: cfun(a, void)): void
//
implement
{a}(*tmp*)
list0_foreach
(
  xs, fwork
) = loop(xs) where
{
//
fun
loop
(xs: list0(a)): void =
(
case+ xs of
| list0_nil() => ()
| list0_cons(x, xs) => (fwork(x); loop(xs))
)
//
} (* end of [list0_foreach] *)
//
')

")

#para("\

Another commonly used (higher-order) function is often referred to as
list-filter, which takes a list and a predicate (i.e., a function
returning a boolean value) and returns a newly constructed list
consisting of all of the elements in the given list that satisfy the
given predicate:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_filter
(xs: list0(a), test: cfun(a, bool)): list0(a)
//
implement
{a}(*tmp*)
list0_filter
(
  xs, test
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(a) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x, xs) =>
  if test(x)
    then list0_cons(x, auxlst(xs)) else auxlst(xs)
  // end of [if]
)
//
} (* end of [list0_filter] *)
//
')

For instance, given the list #dyncode("(1, 2, 3, 4, 5)")
and the predicate for testing whether an integer is even,
#dyncode("list0_filter") returns the list consisting of #dyncode("2")
and #dyncode("4").

")

#para("\

Given a list #dyncode("xs"), the following function
#dyncode("list0_remdup") removes all of the elements in #dyncode("xs")
that have already appeared previously:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_remdup
(xs: list0(a), eqfn: cfun(a, a, bool)): list0(a)
//
implement
{a}(*tmp*)
list0_remdup(xs, eqfn) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x0, xs) =>
  list0_cons(x0, list0_remdup<a>(list0_filter<a>(xs, lam(x) => eqfn(x0, x)), eqfn))
)
//
')

The implementation of #dyncode("list0_remdup") should clearly remind
one of the sieve of Eratosthenes, which is to be given a stream-based
implementation later.

")

#para("\

The list-processing function #dyncode("list0_map") processes every
element in its list argument and so does #dyncode("list0_filter").
Sometimes, we need a list-processing function that stops immediately
after certain condition is met. For instance, we may want to locate
the index of the first element in a given list that satisfies some test,
which can done by calling the following function #dyncode("list0_find_index"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_find_index
(xs: list0(a), test: cfun(a, bool)): int
//
implement
{a}(*tmp*)
list0_find_index
  (xs, test) = let
//
fun
loop
(xs: list0(a), i: int): int =
(
case+ xs of
| list0_nil() => ~1
| list0_cons(x, xs) =>
  if test(x) then i else loop(xs, i+1)
)
//
in
  loop(xs, 0)
end // end of [list0_find_index]
//
')

For instance, given the list #dyncode("(1, 2, 3)") and the predicate
for testing whether an integer is even, #dyncode("list0_find_index")
returns #dyncode("1") (which is the index for the element #dyncode("2")
in the given list). Note that #dyncode("~1") (negative 1) is returned
if no element satisfying the given predicate is found.

")

#para("\

Given a list0-value #dyncode("xs") and a predicate #dyncode("test"),
#dyncode("list0_exist") returns true if and only if there exists one
element in #dyncode("xs") satisfing #dyncode("test"), and
#dyncode("list0_forall") returns true if and only if every element in
#dyncode("xs") satisfies #dyncode("test"). Both of these two functions
can be readily implemented based on a direct call to
#dyncode("list0_find_index"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
list0_exists
(xs: list0(a), test: cfun(a, bool)): bool
extern
fun
{a:t@ype}
list0_forall
(xs: list0(a), test: cfun(a, bool)): bool
//
implement
{a}(*tmp*)
list0_exists(xs, test) =
list0_find_index<a>(xs, test) >= 0
implement
{a}(*tmp*)
list0_forall(xs, test) =
list0_find_index<a>(xs, lam(x) => not(test(x))) < 0
//
')

")

#para("\

Given a list (x#sub("0"), ..., x#sub("n-1")) of length n, its indexed
version refers to the list of pairs in which the elements are of the form
(i, x#sub("i")) for i ranging from 0 to n-1.  For a function that
processes a given list, there is often a meaningful variant of the
function that processes the indexed version of the list. For instance,
the following function #dyncode("list0_imap") is such a variant of
#dyncode("list0_map"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list0_imap
(xs: list0(a), fopr: cfun(int, a, b)): list0(b)
//
implement
{a}{b}
list0_imap
(
  xs, fopr
) = auxlst(0, xs) where
{
//
fun
auxlst
(i: int, xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(i, x), auxlst(i+1, xs))
)
//
} (* end of [list0_imap] *)
//
')

Let us use #dyncode("list0_iexists") and #dyncode("list0_iforall") to
refer to the variants of #dyncode("list0_exists") and
#dyncode("list0_forall"), respectively, for processing indexed lists.
The code implementing #dyncode("list0_iexists") and #dyncode("list0_iforall")
is omitted for brevity.

")

#para("\

I have so far presented a variety of functions for processing lists in a
functional style. I would like to conclude the chapter with an example
of functional programming that can concretely demonstrate some typical use of
list-processing functions in practice.

")

#para("\

The famous 8-queen puzzle asks the player to find ways to put eight
queen pieces on a chess board such that no queen piece can attack any
other ones. In other words, no two queen pieces can be put on the same
row, the same column, or the same diagnal. This puzzle can be readily
solved with a tree-based search.

")

#para("\

Please find #mycodelink("LECTURE/06/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture06"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

