%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture09">
#title("Raising and Catching Exceptions")

#para("\

Exceptions provide a mechanism for altering the (normal) control-flow
during program execution. Raising an exception is somewhat like
executing a goto-statement.  A handler for handling a raised exception
is essentially a pattern matching clause guarded by a pattern (for
matching exceptions).  Intuitively speaking, a raised exception passes
through a stack of handlers; the raised exception is handled by a
handler if the exception matches the guard of the handler, or it
simply tries the next handler to see if it can be handled; the raised
exception terminates program execution abnormally if it is not handled
by any of the handlers.

")

#para("\

In ATS, a try-expression (or try-with-expression) is of the form
(#keycode("try") exp #keycode("with") clseq), where #keycode("try") is
a keyword, exp is an expression, #keycode("with") is also a keyword,
and clseq is a sequence of pattern matching clauses (used as
exception-handlers). When evaluating such a try-expression, we first
evaluate exp. If the evaluation of exp leads to a value, then the
value is also the value of the try-expression. If the evaluation of
exp leads to a raised exception, then we match the exception against
the guards of the matching clauses in clseq. If there is a match, the
raised exception is caught and we continue to evaluate the body of the
first clause whose guard is matched. If there is no match, the raised
exception is uncaught. In the following example,
#dyncode("list0_exists") is implemented based on
#dyncode("list0_foreach"):

#dats2xhtml('\
//
implement
{a}(*tmp*)
list0_exists
  (xs, test) = let
//
exception True of ()
//
in
//
try let
//
val () =
list0_foreach<a>
( xs
, lam(x) => if test(x) then $raise True()
)
//
in
  false
end with ~True() => true
//
end // end of [list0_exists]
//
')

There is a built-in type #stacode("exn") in ATS, which is somewhat
like an extensible datatype in the sense that a new constructor
associated with #stacode("exn") can be introduced through an
exception-declaration. For instance, #dyncode("True") is introduced as
a nullary exception-constructor in the body of
#dyncode("list0_exists"). Given a list and a function,
#dyncode("list0_foreach") normally traverses until the end of the list
while appying the function to each encountered element.  When the call
to #dyncode("list0_foreach") in the body of #dyncode("list0_exists")
is evaluated, an exception (#dyncode("True()")) is raised to stop
further traversing if an element satisfying the predicate
#dyncode("test") is encountered.  If the call to to
#dyncode("list0_foreach") returns, then the value #dyncode("false") is
the return value of #dyncode("list0_exists").  If #dyncode("True()")
is raised during the evaluation of the call, then this raised
exception is to be caught by the handler following the
#keycode("with"), resulting in the value #dyncode("true") becoming the
return value of #dyncode("list0_exists").

")

#para("\

Please find #mycodelink("LECTURE/09/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture09"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

