%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture11">
#title("Linear Lazy Stream-Processing")

#para("\

As the name suggests, linear lazy streams are the linear version of
lazy streams. In ATS, a linear value is one that cannot be shared; it
must be consumed properly for otherwise a type error is reported
during typechecking. Before moving on with programming linear lazy
streams, I would like to give a strong motivation for doing it.  Let
me first present as follows a simple but telling example that
demonstrates a stream-based approach to addressing the potential risk
of stack overflow due to deeply nested non-tail-recursive calls. The
following implementation of #dyncode("list0_map") is standard:

#dats2xhtml('\
//
implement
{a}{b}
list0_map
(xs, fopr) =
auxmain(xs) where
{
//
fun
auxmain
(
xs: list0(a)
) : list0(b) =
(
case+ xs of
| list0_nil() => list0_nil()
| list0_cons(x, xs) => list0_cons(fopr(x), auxmain(xs))
)
//
} (* end of [list0_map] *)
//
')

Clearly, this implementation is not tail-recursive. When applied to a
long list (e.g., one consisting of 1000000 elements),
#dyncode("list0_map") runs a high risk of causing stack overflow. This
can become a very serious issue in practice if we ever want to
applying functional programming to a domain like machine learning
where processing large data becomes a norm rather than an
exception. One possibility is to insist on using only tail-recursion
in the implementation of a function like #dyncode("list0_map") that
may need to be applied to large data, but such a requirement or
restriction clearly exerts negative impact on the use of recursion in
problem-solving. After all, there are numerous algorithms that are
natrually expressed in terms of (general) recursion. And non-trivial
effort is often needed in order to implement such an algorithm based on
tail-recursion only, diminishing programming productivity.

#dats2xhtml('\
//
implement
{a}{b}
list0_map(xs, fopr) = let
//
fun
auxmain
(
xs: list0(a)
) : stream(b) = $delay
(
case+ xs of
| list0_nil() => stream_nil()
| list0_cons(x, xs) => stream_cons(fopr(x), auxmain(xs))
)
//
in
  g0ofg1(stream2list(auxmain(xs)))
end // end of [list0_map]
//
')

")

#para("\

Please find #mycodelink("LECTURE/11/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture11"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

