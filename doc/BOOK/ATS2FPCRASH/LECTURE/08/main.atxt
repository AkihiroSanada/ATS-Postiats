%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture08">
#title("Persistent Arrays and References")

#para("\

Let us start with references. A reference is precisely an
(initialized) singleton array, that is, an array of size 1, and its
typical use is for implementing a global variable that can be updated.

")

#para("\

The following function is for creating a reference:

#sats2xhtml('\
//
fun
{a:t@ype}
ref_make_elt(x0: a): ref(a)
//
')

where #stacode("ref") is a type constructor in ATS that takes a type T
to form a reference type #stacode("ref(T)") for any reference holding
a value of the type T.  The functions #dyncode("ref_get_elt") and
#dyncode("ref_set_elt") are for fetching and updating the value stored
in a reference, respectively:

#sats2xhtml('\
//
fun
{a:t@ype}
ref_get_elt(r: ref(a)): a
fun
{a:t@ype}
ref_set_elt(r: ref(a), x: a): void
//
')

A shorthand for #dyncode("ref_make_elt") is #dyncode("ref").  Also,
both #dyncode("!") and #dyncode("[]") are overloaded with
#dyncode("ref_get_elt") and #dyncode("ref_set_elt"). For instance, the
following code prints out 0, 1, and 3 twice:

#dats2xhtml('\
//
val r0 = ref<int>(0)
val () = println! (!r0)
val () = (!r0 := !r0 + 1)
val () = println! (!r0)
val () = (!r0 := !r0 + 2)
val () = println! (!r0)
//
val r1 = ref<int>(0)
val () = println! (r1[])
val () = (r1[] := r1[] + 1)
val () = println! (r1[])
val () = (r1[] := r1[] + 2)
val () = println! (r1[])
//
')

")

#para("\

Programmers often misuse references. This is especially true for those
with a background in imperative programming. For instance, the
following example shows a typical poor use of references that is often
resulted from someone learning functional programming by \"translating\"
code written in imperative style:

#dats2xhtml('\
//
fun
fact_ref
(n: int): int = let
//
val i = ref<int>(0)
val r = ref<int>(1)
//
fun loop(): void =
  if !i < n then (!i := !i+1; !r := !r * !i; loop())
//
in
  let val () = loop() in !r end
end (* end of [fact_ref] *)
//
')

There are some obvious drawbacks in this implementation of
#dyncode("fact_ref"). For evaluating each call to
#dyncode("fact_ref"), two references are created, which become garbage
after the call returns. As a reference is allocated on heap, it is not
mapped to a register when compiled. Accessing a reference involves
memory traffic, which is much more expensive than accessing a
register. Compared to a tail-recursive implementation of the factorial
function in functional style, #dyncode("fact_ref") is of great
inefficiency both time-wise and memory-wise.

")

#para("\

There is a type constructor #stacode("array0") in ATS that takes a
type T to form the array type #stacode("array0(T)") for an array
storing elements of the type T. We refer to such an array as an
array0-value, which is essentially a pair containing a pointer (to the
memory where elements are stored) and an integer (indicating the
capacity of the array that cannot be changed). For instance, the
following function can be called to create an array0-value:

#sats2xhtml('\

fun
{a:t@ype}
array0_make_elt(n: 

')

")

#para("\

Please find #mycodelink("LECTURE/08/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture08"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

