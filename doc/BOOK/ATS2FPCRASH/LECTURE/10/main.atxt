%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include
"./../../MYTEXT/ats2fpcrash.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="lecture10">
#title("Lazy Stream-Processing")

#para("\

A stream is like a list but it is lazy in the sense that the elements
in a stream are not required to be made available at the moment when
the stream is formed. Instead, each element only needs to be produced
at the point where the element is actually needed for evaluation.
Given a type T, the type #stacode("stream(T)") is for a value
representing a stream of elements of the type T. Let us use the name
stream-value to refer to such a value, which is completely opaque for
it does not even reveal whether the stream it represents is empty or
not. Internally, a stream-value is represented as a thunk, that is, a
nullary closure-function. Evaluating a stream-value (that is, calling
the thunk representing it) yields a stream-con value of type
#dyncode("stream_con(T)") for some T, where #dyncode("stream_con")
is the following declared datatype:

#sats2xhtml('\
datatype
stream_con(a:t@ype) =
  | steam_nil of ()
  | stream_cons of (a, stream(a))
')

With pattern matching, we can inspect whether a stream-con value
represents an empty stream or not. If the stream is non-empty, then
its first element can be extracted.

")

#para("\

Formally speaking, we have the following type definition in ATS:

#sats2xhtml('\
typedef stream(a:t@ype) = lazy(stream_con(a))
')

where #stacode("lazy") is a special type constructor. Given a type
T, the type #stacode("lazy(T)") is essentially for a thunk that returns
a value of type T. Often such a thunk is referred to as a suspended
computation of type T, which can be resumed by simply calling the thunk.

")

#para("\

As an example, the following function #dyncode("int_stream_from")
takes an integer #dyncode("n") and returns a stream that enumerates
ascendingly all of the integers greater than or equal to
#dyncode("n"):

#dats2xhtml('\
//
fun
int_stream_from
  (n: int): stream(int) =
  $delay(stream_cons(n, int_stream_from(n+1)))
//
')

The keyword #keycode("$delay") indicates the construction
of a thunk based on the expression appearing as its argument.

")

#para("\

Accessing elements in a given stream is shown in the following
example:

#dats2xhtml('\
//
fun
{a:t@ype}
stream_get_at
  (xs: stream(a), n: int): a =
(
case+ !xs of
| stream_nil() =>
  (
    $raise StreamSubscriptExn()
  )
| stream_cons(x, xs) =>
  (
    if n <= 0 then x else stream_get_at<a>(xs, n-1)
  )
)
//
')

The function #dyncode("stream_get_at") is the stream-version of
#dyncode("list_get_at"): Given a stream and a position (denoted by an
integer), #dyncode("stream_get_at") returns the element in the stream
at the given position. Note that the symbol #dyncode("!") refers to
the function #dyncode("lazy_force"), which evaluates a given stream
value into a stream-con value in this case.

")

#para("\

Please find #mycodelink("LECTURE/10/CODE", "on-line") the entirety of
the code used in this chapter. \

")#comment("para")

</chapter><!--id="lecture10"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}

