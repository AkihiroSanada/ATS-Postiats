%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dot-overload">
#title("Overloaded Dot-Symbols")

#para('\

In many programming languages, the so-called dot-notation is commonly
associated with selecting a field from a given tuple-value or record-value.
In ATS, field selection can be done through either pattern matching or the
use of dot-notation. For example, the following code constructs a flat
tuple and also a boxed one, and then uses dot-notation to select their
components:

#atscode('\
//
val tup_flat = @("a", "b")
val tup_boxed = $tup("a", "b")
//
val-"a" = tup_flat.0 and "b" = tup_flat.1
val-"a" = tup_boxed.0 and "b" = tup_boxed.1
//
')

There is support in ATS for overloading a specified dot-symbol with
(mutiple) function names so that dot-notation can be employed to call these
functions, resulting in code that reads like field selection from tuples or
records. This style of calling functions can, sometimes, make the code
written in ATS to be more easily accessible, and it is especially so when
ATS interacts with other languages.\

')

#para('\

As an example, let us introduce an abstract type #stacode("point") for
points in a 2-dimensional space and also declare some associated functions:

#atscode('\
//
abstype point = ptr // boxed
//
extern
fun
point_make
  (x: double, y: double): point
//
extern
fun point_get_x (p: point): double
and point_get_y (p: point): double
//
extern
fun point_set_x (p: point, x: double): void
and point_set_y (p: point, x: double): void
//
')

For getting the x-coordinate and y-coordinate of a given point, the
functions #dyncode("point_get_x") and #dyncode("point_get_y") can be
called, respectively.  For setting the x-coordinate and y-coordinate of a
given point, the functions #dyncode("point_set_x") and
#dyncode("point_set_y") can be called, respectively. By introducing two
dot-symbols #dyncode(".x") and #dyncode(".y") and then overloading them
with certain function names as follows:

#atscode('\
symintr .x .y
overload .x with point_get_x
overload .x with point_set_x
overload .y with point_get_y
overload .y with point_set_y
')

we can use dot-notation to call the corresponding get-functions and
set-functions as is shown in the following code:

#atscode('\
val p0 = point_make (1.0, ~1.0)
val x0 = p0.x // point_get_x (p0)
and y0 = p0.y // point_get_y (p0)
val () = p0.x := y0 // point_set_x (p0, y0)
and () = p0.y := x0 // point_set_y (p0, x0)
')

Note that the dot-notation in any assigement is only allowed to refer to a
function that returns the void-value. In the above example, both
#dyncode("point_set_x") and #dyncode("point_set_y") return the void-value.
Also, it should be emphasized that overloaded dot-notation can only be
applied to a non-linear value. As for linear values, a slightly different
mechanism is available, which I intend to write about in this tutorial as
well.\

')

#para("\


Please find #mycodelink("chap_dotoverld.dats", "on-line") the entirety of the
code presented in this chapter.\

")#comment("para")

</chapter><!--"dot-overload"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
