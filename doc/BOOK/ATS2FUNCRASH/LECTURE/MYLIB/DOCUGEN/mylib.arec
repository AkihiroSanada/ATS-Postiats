####################################
#
# This is the library
# used for ATS2FUNCRASH
#
####################################
[name]: \
[interface]: \
[implement]: \
[description]: \
####################################
#
# For integers
#
####################################
[name]: \
int_foreach
[interface]: \
fun{}
int_foreach
( n0: int
, fwork: cfun(int, void)): void
[implement]: \
implement
{}(*tmp*)
int_foreach
  (n0, fwork) =
  loop(0) where
{
//
fun
loop(i: int): void =
if i < n0 then (fwork(i); loop(i+1))
//
} (* end of [int_foreach] *)
####################################
[name]: \
int_foreach_method
[interface]: \
fun{}
int_foreach_method
(n0: int)(fwork: cfun(int, void)): void
//
overload
.foreach with int_foreach_method of 100
//
[implement]: \
implement
{}(*tmp*)
int_foreach_method(n0) =
lam(fwork) => int_foreach<>(n0, fwork)
####################################
[name]: \
int_foldleft
[interface]: \
fun
{res:t@ype}
int_foldleft
( n0: int
, res: res
, fopr: cfun(res, int, res)): res
[implement]: \
implement
{res}(*tmp*)
int_foldleft
  (n0, res, fopr) =
  loop(res, 0) where
{
//
fun loop(res: res, i: int): res =
  if i < n0
    then loop(fopr(res, i), i+1) else res
  // end of [if]
//
} (* end of [int_foldleft] *)
####################################
[name]: \
int_foldleft_method
[interface]: \
fun
{res:t@ype}
int_foldleft_method
(n0: int, ty: TYPE(res))
(res: res, fopr: cfun(res, int, res)): res
//
overload
.foldleft with int_foldleft_method of 100
//
[implement]: \
implement
{res}(*tmp*)
int_foldleft_method(n0, ty) =
lam(res, fopr) => int_foldleft<res>(n0, res, fopr)
####################################
[name]: \
int_cross_foreach
[interface]: \
fun{}
int_cross_foreach
( m: int
, n: int
, fwork: cfun(int, int, void)): void
[implement]: \
implement
{}(*tmp*)
int_cross_foreach
( m, n
, fwork) =
(
int_foreach
( m
, lam(i) =>
  int_foreach(n, lam(j) => fwork(i, j)))
)
####################################
[name]: \
int_cross_foreach_method
[interface]: \
fun{}
int_cross_foreach_method
(m: int, n: int)(fwork: cfun(int, int, void)): void
//
overload
.cross_foreach with int_cross_foreach_method of 100
//
[implement]: \
implement
{}(*tmp*)
int_cross_foreach_method
(m, n) =
lam(fwork) => int_cross_foreach(m, n, fwork)
####################################
#
# For list0-values
#
####################################
[name]: \
list0_is_nil
[interface]: \
fun{}
list0_is_nil{a:t@ype}(list0(a)): bool
//
overload iseqz with list0_is_nil of 100
//
[implement]: \
implement
{}(*tmp*)
list0_is_nil(xs) =
(case+ xs of list0_nil() => true | _ => false)
[description]: \
This function tests whether a given list0-value
is empty.
####################################
[name]: \
list0_is_cons
[interface]: \
fun{}
list0_is_cons{a:t@ype}(list0(a)): bool
//
overload isneqz with list0_is_cons of 100
//
[implement]: \
implement
{}(*tmp*)
list0_is_cons(xs) =
(case+ xs of list0_cons _ => true | _ => false)
[description]: \
This function tests whether a given list0-value
is non-empty.
####################################
[name]: \
list0_length
[interface]: \
fun
{a:t@ype}
list0_length(xs0: list0(INV(a))): int
//
overload length with list0_length of 100
//
[implement]: \
implement
{a}(*tmp*)
list0_length(xs) =
list0_foldleft<int><a>(xs, 0, lam(r, _) => r + 1)
####################################
[name]: \
list0_head_exn
[interface]: \
fun
{a:t@ype}
list0_head_exn(xs: list0(INV(a))): (a)
//
overload .head with list0_head_exn of 100
//
####################################
[name]: \
list0_tail_exn
[interface]: \
fun
{a:t@ype}
list0_tail_exn(xs: list0(INV(a))): list0(a)
//
overload .tail with list0_tail_exn of 100
//
####################################
[name]: \
list0_append
[interface]: \
fun
{a:t@ype}
list0_append
(xs: list0(INV(a)), ys: list0(a)): list0(a)
####################################
[name]: \
list0_concat
[interface]: \
fun
{a:t@ype}
list0_concat(xs: list0(list0(INV(a)))): list0(a)
####################################
[name]: \
list0_reverse
[interface]: \
fun
{a:t@ype}
list0_reverse(xs: list0(INV(a))): list0(a)
####################################
[name]: \
list0_revappend
[interface]: \
fun
{a:t@ype}
list0_revappend
(xs: list0(INV(a)), ys: list0(a)): list0(a)
####################################
[name]: \
list0_map
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_map
( xs: list0(INV(a))
, fopr: cfun(a, b)): list0(b)
[implement]: \
implement
{a}{b}
list0_map
(
  xs, fopr
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x, xs) =>
  list0_cons(fopr(x), auxlst(xs))
)
//
} (* end of [list0_map] *)
[description]: \
Given a list0-value xs and a closure-function f, this function
returns another list0-value consisting of f(xs[0]), ..., f(xs[n-1]),
where n is the length of xs. The implementation of this function in
ATSLIB is tail-recursive.
[code-sample]: \
####################################
[name]: \
list0_map_method
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_map_method
( xs: list0(INV(a)))
( fopr: cfun1(a, b)) : list0(b)
//
overload
.map with list0_map_method of 100
//
[implement]: \
implement
{a}{b}
list0_map_method
  (xs) =
(
  lam(fopr) => list0_map<a><b>(xs, fopr)
)
####################################
[name]: \
list0_mapopt
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_mapopt
( xs: list0(INV(a))
, fopr: cfun(a, option0(b))): list0(b)
[implement]: \
implement
{a}{b}
list0_mapopt
(
  xs, fopr
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(b) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x, xs) =>
  (
  case+ fopr(x) of
  | None0() => auxlst(xs)
  | Some0(y) => list0_cons(y, auxlst(xs))
  )
)
//
} (* end of [list0_mapopt] *)
[description]: \
Given a list0-value xs and a closure-function f, this function
returns another list0-value consisting of the join of the option
values f(xs[0]), ..., f(xs[n-1]), where n is the length of xs. The
implementation of this function in ATSLIB is tail-recursive.
####################################
[name]: \
list0_mapopt_method
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_mapopt_method
( xs: list0(INV(a)) )
( fopr: cfun(a, option0(b)) ): list0(b)
//
overload
.mapopt with list0_mapopt_method of 100
//
[implement]: \
implement
{a}{b}
list0_mapopt_method
  (xs) =
(
  lam(fopr) => list0_mapopt<a><b>(xs, fopr)
)
####################################
[name]: \
list0_mapcons
[interface]: \
fun
{a:t@ype}
list0_mapcons
( x0: a
, xss: list0(list0(a))): list0(list0(a))
[implement]: \
implement
{a}(*tmp*)
list0_mapcons
  (x0, xss) =
(
list0_map<list0(a)><list0(a)>(xss, lam(xs) => list0_cons(x0, xs))
) (* list0_mapcons *)
####################################
[name]: \
list0_mapjoin
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_mapjoin
( xs: list0(INV(a))
, fopr: cfun(a, list0(b))): list0(b)
[implement]: \
implement
{a}{b}
list0_mapjoin
  (xs, fopr) =
(
  list0_concat<b>(list0_map<a><list0(b)>(xs, fopr))
)
####################################
[name]: \
list0_foreach
[interface]: \
fun
{a:t@ype}
list0_foreach
( xs: list0(INV(a))
, fwork: cfun(a, void)): void
[implement]: \
implement
{a}(*tmp*)
list0_foreach
(
  xs, fwork
) = loop(xs) where
{
//
fun
loop
(xs: list0(a)): void =
(
case+ xs of
| list0_nil() => ()
| list0_cons(x, xs) => (fwork(x); loop(xs))
)
//
} (* end of [list0_foreach] *)
####################################
[name]: \
list0_foreach_method
[interface]: \
fun
{a:t@ype}
list0_foreach_method
( xs: list0(INV(a)))
( fwork: cfun(a, void)): void
//
overload
.foreach with list0_foreach_method of 100
//
[implement]: \
implement
{a}(*tmp*)
list0_foreach_method
  (xs) =
(
lam(fwork) => list0_foreach<a>(xs, fwork)
)
####################################
[name]: \
list0_filter
[interface]: \
fun
{a:t@ype}
list0_filter
( xs: list0(INV(a))
, pred: cfun(a, bool)): list0(a)
[implement]: \
implement
{a}(*tmp*)
list0_filter
(
  xs, test
) = auxlst(xs) where
{
//
fun
auxlst
(xs: list0(a)): list0(a) =
(
case+ xs of
| list0_nil() =>
  list0_nil()
| list0_cons(x, xs) =>
  if test(x)
    then list0_cons(x, auxlst(xs)) else auxlst(xs)
  // end of [if]
)
//
} (* end of [list0_filter] *)
####################################
[name]: \
list0_filter_method
[interface]: \
fun
{a:t@ype}
list0_filter_method
( xs: list0(INV(a)))
( pred: cfun(a, bool)): list0(a)
//
overload
.filter with list0_filter_method of 100
//
[implement]: \
implement
{a}(*tmp*)
list0_filter_method
  (xs) =
(
  lam(pred) => list0_filter<a>(xs, pred)
)
####################################
#
# For stream-values
#
####################################
[name]: \
int_stream_from
[interface]: \
fun
int_stream_from(n: int): stream(int)
[implement]: \
implement
int_stream_from(n) =
$delay(stream_cons(n, int_stream_from(n+1)))
####################################
[name]: \
stream_make_list0
[interface]: \
fun
{a:t@ype}
stream_make_list0(list0(INV(a))): stream(a)
[implement]: \
implement
{a}(*tmp*)
stream_make_list0
  (xs) = $delay
(
case+ xs of
| list0_nil() =>
  stream_nil()
| list0_cons(x, xs) =>
  stream_cons(x, stream_make_list0<a>(xs))
)
####################################
[name]: \
stream_get_at_exn
[interface]: \
fun
{a:t@ype}
stream_get_at_exn(stream(a), n: int): a
//
overload [] with stream_get_at_exn of 100
//
[implement]: \
implement
{a}(*tmp*)
stream_get_at_exn
  (xs, n) =
(
case- !xs of
(*
| stream_nil() =>
  (
    $raise StreamSubscriptExn()
  )
*)
| stream_cons(x, xs) =>
  (
    if n <= 0
      then x else stream_get_at_exn<a>(xs, n-1)
    // end of [if]
  )
)
####################################
[name]: \
stream_takeLte
[interface]: \
fun
{a:t@ype}
stream_takeLte
  (xs: stream(a), n: int): stream(a)
[implement]: \
implement
{a}(*tmp*)
stream_takeLte
  (xs, n) = $delay
(
if
n > 0
then
(
case+ !xs of
| stream_nil() =>
  stream_nil()
| stream_cons(x, xs) =>
  stream_cons(x, stream_takeLte(xs, n-1))
)
else stream_nil((*void*))
) (* end of [stream_takeLte] *)
####################################
[name]: \
stream_append
[interface]: \
fun
{a:t@ype}
stream_append
(xs: stream(a), ys: stream(a)): stream(a)
[implement]: \
implement
{a}(*tmp*)
stream_append
(xs, ys) = $delay
(
case+ !xs of
| stream_nil() => !ys
| stream_cons(x, xs) =>
  stream_cons(x, stream_append<a>(xs, ys))
)
####################################
[name]: \
stream_concat
[interface]: \
fun
{a:t@ype}
stream_concat
  (xss: stream(stream(a))): stream(a)
[implement]: \
implement
{a}(*tmp*)
stream_concat(xss) = $delay
(
case+ !xss of
| stream_nil() =>
  stream_nil()
| stream_cons(xs, xss) => !
  (
   stream_append<a>(xs, stream_concat<a>(xss))
  ) (* end of [stream_cons] *)
)
####################################
[name]: \
stream_map
[interface]: \
fun
{a:t@ype}
{b:t@ype}
stream_map
(xs: stream(a)
, fopr: cfun(a, b)): stream(b)
[implement]: \
implement
{a}{b}
stream_map
  (xs, fopr) = $delay
(
case+ !xs of
| stream_nil() =>
  stream_nil()
| stream_cons(x, xs) =>
  stream_cons
    (fopr(x), stream_map<a><b>(xs, fopr))
  // end of [stream_cons]
)
####################################
[name]: \
stream_filter
[interface]: \
fun
{a:t@ype}
stream_filter
( xs: stream(a)
, test: cfun(a, bool)): stream(a)
[implement]: \
implement
{a}(*tmp*)
stream_filter
  (xs, test) = $delay
(
case+ !xs of
| stream_nil() =>
  stream_nil()
| stream_cons(x, xs) =>
  if test(x)
    then
    stream_cons
      (x, stream_filter<a>(xs, test))
    // end of [then]
    else !(stream_filter<a>(xs, test))
  // end of [if]
)
####################################
[name]: \
stream_foreach
[interface]: \
fun
{a:t@ype}
stream_foreach
(
xs: stream(a),
fwork: cfun(a, void)
) : void // end-of-function
[implement]: \
implement
{a}(*tmp*)
stream_foreach(xs, fwork) =
(
//
case+ !xs of
| stream_nil() => ()
| stream_cons(x, xs) =>
  (fwork(x); stream_foreach<a>(xs, fwork))
//
) (* end of [stream_foreach] *)
####################################
[name]: \
stream_foldleft
[interface]: \
fun{
res:t@ype
}{a:t@ype}
stream_foldleft
(
xs: stream(a),
r0: res, fopr: cfun(res, a, res)
) : res // end-of-function
[implement]: \
implement
{res}{a}
stream_foldleft(xs, r0, fopr) =
(
//
case+ !xs of
| stream_nil() => r0
| stream_cons(x, xs) =>
  stream_foldleft<res><a>(xs, fopr(r0, x), fopr)
//
) (* end of [stream_foldleft] *)
####################################
#
# For linear stream-values
#
####################################
[name]: \
int_stream_vt_from
[interface]: \
fun
int_stream_vt_from(n: int): stream_vt(int)
[implement]: \
implement
int_stream_vt_from(n) =
$ldelay(stream_vt_cons(n, int_stream_vt_from(n+1)))
####################################
[name]: \
stream_vt_takeLte
[interface]: \
fun
{a:t@ype}
stream_vt_takeLte
  (xs: stream_vt(a), n: int): stream_vt(a)
[implement]: \
implement
{a}(*tmp*)
stream_vt_takeLte
  (xs, n) = $ldelay
(
if
n > 0
then
(
case+ !xs of
| ~stream_vt_nil() =>
   stream_vt_nil()
| ~stream_vt_cons(x, xs) =>
   stream_vt_cons(x, stream_vt_takeLte(xs, n-1))
)
else (~xs; stream_vt_nil((*void*)))
,
lazy_vt_free(xs) // called when the stream is freed
) (* end of [stream_vt_takeLte] *)
####################################
[name]: \
stream_vt_map
[interface]: \
fun
{a:t@ype}
{b:t@ype}
stream_vt_map
(xs: stream_vt(a), fopr: cfun(a, b)): stream_vt(b)
[implement]: \
implement
{a}{b}
stream_vt_map
  (xs, fopr) = $ldelay
(
case+ !xs of
| ~stream_vt_nil() =>
   stream_vt_nil()
| ~stream_vt_cons(x, xs) =>
   stream_vt_cons(fopr(x), stream_vt_map<a><b>(xs, fopr))
, lazy_vt_free(xs)
)
####################################
[name]: \
stream_vt_foldleft
[interface]: \
fun{
res:t@ype
}{a:t@ype}
stream_vt_foldleft
(
xs: stream_vt(a),
r0: res, fopr: cfun(res, a, res)
) : res // end-of-function
[implement]: \
implement
{res}{a}
stream_vt_foldleft(xs, r0, fopr) =
(
//
case+ !xs of
| ~stream_vt_nil() => r0
| ~stream_vt_cons(x, xs) =>
   stream_vt_foldleft<res><a>(xs, fopr(r0, x), fopr)
//
) (* end of [stream_vt_foldleft] *)
[description]: \
####################################
#
# For continuation-passing
#
####################################
[name]: \
list0_kmap
[interface]: \
fun
{a:t@ype}
{b:t@ype}
list0_kmap
( xs: list0(INV(a))
, f0: cfun(a, cont1(b), void)
, k0: cont1(list0(b))) : void
[implement]: \
implement
{a}{b}
list0_kmap(xs, f0, k0) =
(
case+ xs of
| list0_nil() =>
  k0(list0_nil())
| list0_cons(x, xs) =>
  f0
  ( x
  , lam(y) =>
    list0_kmap<a><b>
      (xs, f0, lam(ys) => k0(list0_cons(y, ys)))
    // end of [list0_kmap]
  )
)
[description]: \
####################################
[name]: \
stream_kforeach
[interface]: \
fun
{a:t@ype}
stream_kforeach
( xs: stream(INV(a))
, f0: cfun(a, cont1(bool), void), k0: cont0()): void
[implement]: \
implement
{a}(*tmp*)
stream_kforeach(xs, f0, k0) =
(
case+ !xs of
| stream_nil() => k0()
| stream_cons(x, xs) =>
  f0
  ( x
  , lam(y) =>
    if y then stream_kforeach<a>(xs, f0, k0) else k0()
  )
)
[description]: \
######### end of [mylib.arec] #########
