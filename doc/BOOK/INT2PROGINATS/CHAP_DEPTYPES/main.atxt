%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="introduction-to-dependent-types">
#title("Introduction to Dependent Types")

#para("\

The types we have encountered so far in this book are often not adequately
precise in capturing programming invariants. For instance, if we assign the
type #stacode("int") to both of integers 0 and 1, then we simply cannot
distinguish 0 from 1 at the level of types. This means that 0 and 1 are
interchangeable as far as typechecking is concerned. In other words, we
cannot expect a program error to be caught during typechecking if the error
is caused by 0 being mistyped as 1. This form of imprecision in types is a
crippling limitation if we ever want to build a type-based specification
language that is reasonably expressive for practical use.

")#comment("para")

#para("\

Please find #mycodelink("CHAP_DEPTYPES/", "on-line")
the code employed for illustration in this chapter plus some additional
code for testing.\

")

</chapter>
<!--id="introduction_to_dependent_types"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
