%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="Cinteraction">
#title("Interaction with C")

#para('\

ATS and C share precisely the same native/flat/unboxed data representation.
As a consequence, there is no need for wrapping/unwrapping or
boxing/unboxing when calling from C a function implemented in ATS or vice
versa, and there is also no run-time overhead for doing so. To a large
extent, ATS can be considered a front-end to C that is equipped with a
highly expressive type system and a localizable template system.

')

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_CINTERACT/", "on-line").\

")

<!-- ****** ****** -->

<sect1
id="external_name">
<title>
External Global Names
</title>

#para("\

A function declared in ATS can be given a global name of C-style so as to
allow the function to appear in both ATS code and C code.  In particular,
the function can be implemented in ATS and called in C or vice versa.\

")

#para("\

In the following code, we see that two functions are declared:

#atscode('\
extern
fun fact (n: int): int
extern
fun fact2 (n: int, res: int): int = "ext\#fact2_in_c"
')

The first function #dyncode("fact") does not have a global name while the
second function #dyncode("fact2") is assigned a global name
#dyncode("fact2_in_c").  The symbol #keycode("ext\#") indicates that
#dyncode("fact2_in_c") is treated as a global function in C and its
prototype needs to be declared (via the #dyncode("extern") keyword) before
it can be called.

")

#para("\

Let us assume that #dyncode("fact") can be implemented as follows:

#atscode('\
implement fact (n) = fact2 (n, 1)
')

When compiling this implementation, the ATS compiler needs to form function
names in the generated C code to refer to #dyncode("fact") and
#dyncode("fact2").  For the former, the function name in the C code is
determined by a set of rules (which take into account the issue of
namespace).  For the latter, the function name is simply chosen to be the
assigned global name #dyncode("fact2_in_c"). As is suggested by the name of
#dyncode("fact2_in_c"), this function can be directly implemented in C as
follows:

<informalexample><programlisting>
<![CDATA[int
fact2_in_c (int n, int res)
{
  while (n > 0) { res *= n ; n -= 1 ; } ; return res ;
}
]]></programlisting></informalexample>

It is also allowed to implement #dyncode("fact2") in ATS
directly as is shown below:

#atscode('\
implement
fact2 (n, res) = if n > 0 then fact2 (n-1, n*res) else res
')

This implementation of #dyncode("fact2") can be called in C
through the name #dyncode("fact2_in_c").\

")

#para('\

If both #dyncode("fact2") and #dyncode("fact2_in_c") are implemented (the
former in ATS and the latter in C), then a linking-time error is to be
issued to indicate that #dyncode("fact2_in_c") is implemented repeatedly.\

')

#para('\

One can also declare #dyncode("fact2") as follows:

#atscode('\
extern
fun fact2 (n: int, res: int): int = "mac\#fact2_in_c"
')

The symbol #keycode("mac\#") indicates that #dyncode("fact2_in_c") is
treated like a macro in C. In particular, #dyncode("fact2_in_c") can be
called without its prototype being declared first. As a matter of fact, it
may not even have a prototype. This style of declaration naturally expects
#dyncode("fact2_in_c") to be implemented in C directly.\

')

#para('\

It is also allowed to use #keycode("sta\#") in place of #keycode("mac\#"):

#atscode('\
extern
fun fact2 (n: int, res: int): int = "sta\#fact2_in_c"
')

If declared in this style, which only occurs rarely in practice,
then #dyncode("fact2_in_c") is treated like a static function in C.\

')

</sect1><!--id="external_global_names"-->

<!-- ****** ****** -->

<sect1
id="external_types_and_values">
<title>
External Types and Values in ATS
</title>

#para("\

External types and values can be readily formed in ATS to refer to types
and values declared in C.

")

#para("\

Suppose that there is a type in C of the name #stacode("some_type_in_c"),
then this type can be referred to in ATS as $extype\"some_type_in_c\". For
instance, type definitions are introduced in the following code for
some external types in C:

#atscode('\
typedef Cint = $extype"int"
typedef Clint = $extype"long int"
typedef Cllint = $extype"long long int"
typedef Cint2 = $extype"struct{ int x; int y; }"
')

Suppose that there is a value in C of the name #dyncode("some_value_in_c"),
then this value can be referred to in ATS as $extval(T, \"some_value_in_c\"),
where T is a type in ATS assigned to this value.
For instance, macro definitions are introduced in the following code for
some external values in C:

#atscode('\
macdef NULL = $extype(ptr, "0")
macdef stdin_ref = $extype(FILEref, "stdin")
macdef stdout_ref = $extype(FILEref, "stdout")
')

External value can also be formed to refer to functions in C as done
in the following code:

#atscode('\
macdef atoi = $extype(string -> int, "atoi")
macdef atol = $extype(string -> lint, "atol")
macdef atof = $extype(string -> double, "atof")
')

Note that there are other ways in ATS that are often more approriate for
directly referring to functions in C.  Typically, the primary purpose of
forming an external value in ATS is to allow a constant declared in C to be
directly referred to in ATS code.

")

</sect1><!--id="external_types_and_values"-->

<!-- ****** ****** -->

<sect1
id="inclusion_of_external_code">
<title>
Inclusion of External Code in ATS
</title>

#para("\

Just like including assembly inside C code, it is straightforward to
include C code inside ATS code.

")

</sect1><!--id="inclusion_of_external_code"-->

</chapter>

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
