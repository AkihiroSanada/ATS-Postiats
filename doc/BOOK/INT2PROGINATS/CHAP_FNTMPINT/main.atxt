%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="from-genericity-to-late-binding">
#title("From Genericity to Late-Binding")

<!-- ****** ****** -->

#para('\

The support for function templates in ATS is deeply ingrained in the design
and implementation of ATS. Primarily, function templates are meant to
provide a general approach to code reuse in ATS that is highly flexible (in
terms of applicability) while incurring minimal run-time overhead if
any. Both ATSPRE (that is, ATSLIB/prelude) and ATSLIB/libats are nearly
entirely template-based, and the templates in these libraries are for use
by #command("patsopt") to generate C code that implements template
instances in the ATS source being compiled. The library files of ATS for
linking (#filename("libatslib.a") and #filename("libatslib.so")) are minimal, and
they are not even necessary for compiling ATS source into executable binaries.

')#comment("para")

<!-- ****** ****** -->

<sect1
 id="genericity-of-template-implementations">
#title("Genericity of Template Implementations")

#para('\

As is briefly explained in Part I of the book, function templates can be
seen as a natural solution to the problem of supporting parametric
polymorphism in the presence of native unboxed data. However, function
templates can do much more than just supporting parametric polymorphism.
Let #dyncode("myprint") be a function template of the following interface:

#atscode('\
fun{a:t@ype} myprint (x: a): void
')

Given a value, #dyncode("myprint") is supposed to print out some kind of
representation for this value. For instance, we can implement
#dyncode("myprint") as follows:

#atscode('\
implement{a} myprint (x) = print_string "?"
')

This implementation of #dyncode("myprint") is often referred to as a
(fully) generic template implementation due to no restriction being imposed
on the template parameter. Following is another way to code the same
implementation:

#atscode('\
implement(a) myprint<a> (x) = print_string "?"
')

Clearly, the above generic implementation of #dyncode("myprint") is
unsatisfactory as it outputs no specific information on a given value.  We
may want to implement #dyncode("myprint") as follows for only values of the
type #stacode("int"):

#atscode('\
implement myprint<int> (x) = print_int (x)
')

where #dyncode("print_int") is called to print out a given integer. This
implementation of #dyncode("myprint") is often referred to as a specific
template implementation due to the template parameter being bound to a
specific type (that is, #stacode("int") in this case). The following code
implements #dyncode("myprint") for list-values (that is, values of type
#stacode("List(T)") for some type T):

#atscode('\
implement(a)
myprint<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (myprint<a> (x); myprint<List(a)> (xs))
')

This implementation of #dyncode("myprint") is often referred to as a
partially generic template implementation. In order for an instance of
#dyncode("myprint") to use this implementation, the template parameter for
the instance must be of the form #stacode("List(T)") for some type T.

')#comment("para")

#para('\

Implementations of a function template can be ordered according to an
obvious partial ordering referred to as genericity ordering: The genericity
of one implementation is less than or equal to that of another one if the
former implementation is an instance of the latter one. Please note that
the first-fit (instead of best-fit) strategy is employed to locate the
template implementation needed for compiling a given template
instance. More specifically, locating the template implementation for a
particular template instance follows the standard principle of lexical
scoping to search for the first one that is available for use.

')#comment("para")

</sect1><!--id="genericity-of-template-implementations"-->

<!-- ****** ****** -->

<sect1
 id="generic-operations-on-numbers">
#title("Example: Generic Operations on Numbers")

#para("\

There are many types of numbers in ATS. With function templates, we can
greatly enhance code sharing in numerical computation. For instance, we can
give a generic implementation of matrix multiplication of the following
interface:

#atscode("\
fun
{a:t@ype}
matrix_mul
  {p,q,r:int}
(
  p: int(p)
, q: int(q)
, r: int(r)
, A: &matrix(a, p, q)
, B: &matrix(a, q, r)
, C: &matrix(a?, p, r) >> matrix(a, p, r)
) : void // end of [matrix_mul]
")

and then use it to immediately obtain implementations of matrix
multiplication for matrices of integers, matrices of floating point
numbers, matrices of floating point complex numbers, etc. This approach is
clearly far superior to relying on error-prone macros in C.

")#comment("para")

#para("\

Let us take a look at a concrete example involving generic operations on
numbers. The following code gives a standard implementation of the
factorial function:

#atscode('\
//
extern
fun fact(n: int): int
//
implement
fact(n) =
  if n > 0 then n * fact(n-1) else 1
// end of [fact]
//
')

When applied to 100, #dyncode("fact") is likely to return 0. This can be
easily understood as the true value of the factorial of 100 is a multiple
of 2#sup("32") and the multiplication operation on integers of the type
#stacode("int") is probably modulo 2#sup("32"). Suppose that we want to
replace this multiplication operation with the one on floating point
numbers of double precision. This can be done by implementing a slight variant
of #dyncode("fact") as follows

#atscode('\
//
extern
fun factd(n: int): double

implement
factd(n) =
  if n > 0 then n * factd(n-1) else 1.0
// end of [factd]
//
')

When applied to 100, #dyncode("factd") should return a large floating point
number. Obviously, there is a great deal of code duplication between the
implementations of #dyncode("fact") and #dyncode("factd"). We can readily
eliminate this duplication by introducing a generic implementation of the
factorial function as follows:

#atscode('\
//
extern
fun{a:t@ype} gfact(n: int): a
//
implement
{a}(*tmp*)
gfact(n) = (
//
if n > 0
then gmul_int_val<a>(n, gfact<a>(n-1))
else gnumber_int<a>(1)
//
) (* end of [gfact] *)
//
')

With a bit of support for overloading in ATS, we can rewrite
#dyncode("gfact") as follows:

#atscode('\
implement
{a}(*tmp*)
gfact(n) = let
//
overload * with gmul_int_val
//
in
//
if n > 0
then n * gfact<a>(n-1) else gnumber_int<a>(1)
//
end (* end of [gfact] *)
')

We can now implement #dyncode("fact") and #dyncode("factd")
as follows:

#atscode('\
//
implement fact = gfact<int>
implement factd = gfact<double>
//
')

There is support in ATS based on the GNU multiple precision arithmetic
library (GMPLIB) for integers of unlimited precision. The following code
presents a way to compute the true value of the factorial of 100:

#atscode('\
//
staload _(*T*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_t.dats"
staload _(*VT*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_vt.dats"
//
staload GINTINF =
"{$LIBATSHWXI}/intinf/DATS/gintinf_t.dats"
//
typedef intinf = $GINTINF.intinf
overload print with $GINTINF.print_intinf
//
val () =
println! ("gfact<intinf>(100) = ", gfact<intinf>(100))
//
')

I only list some leading digits of the result:

#atscode('\
gfact<intinf>(100) = 933262154439441526816992388562667[...omitted...]
')
")

#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/gnumber.dats", "gnumber.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="generic-operations-on-numbers"-->

<!-- ****** ****** -->

<sect1
 id="templates-as-a-special-form-of-functors">
#title("Templates as a Special Form of Functors")

#para("\

Many uses of higher-order functions can be readily replaced with function
templates in ATS.  In particular, higher-order functions are often
implemented in ATS based on the corresponding function templates.
Let us start with a concrete example. Following is a standard
implementation of list mapping as a higher-order function (template):

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_fun{n:nat}
  (xs: list(a, n), f: a -> b): list_vt(b, n)
//
implement
{a}{b}
list_map_fun (xs, f) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (f(x), aux(xs))
)
//
in
  aux(xs)
end // end of [list_map_fun]
//
')

Given a list of cerntain length and a function (which is envless),
#dyncode("list_map_fun") returns a linear list of the same
length. Unfortunately, #dyncode("list_map_fun") cannot be called on a list and
a closure-function. We certainly can implement a variant of
#dyncode("list_map_fun") of the following interface by essentially duplicating
the implementation of #dyncode("list_map_fun"):

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_cloref{n:nat}
  (xs: list(a, n), f: a -<cloref1> b): list_vt(b, n)
//
')

While #dyncode("list_map_cloref") can be called on a list and a
closure-function, the closure-function that is formed at run-time to be
passed to a call to #dyncode("list_map_cloref") most likely becomes garbage
immediately after the call returns. Without garbage collection (GC), the
memory for storing the closure is leaked. We surely have many good reasons
for avoiding using a higher-order function like #dyncode("list_map_cloref")
when doing embedded programming in ATS.

")

#para('\

A proper way to implement list mapping (as I see it) is given as follows:

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map{n:nat}
  (xs: list(a, n)): list_vt(b, n)
//
extern
fun
{a:t@ype}{b:t@ype} list_map$fopr(x: a): b
//
implement
{a}{b}
list_map (xs) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (list_map$fopr<a><b>(x), aux(xs))
) (* end of [aux] *)
//
in
  aux(xs)
end // end of [list_map]
//
')

The function template #dyncode("list_map") is given in a style that is
often referred to as being functorial: #dyncode("list_map") can be thought
of as a functor in Standard ML that applies to a module consisting of a
single function #dyncode("list_map$fopr"). In SML, each argument of a
functor, which itself is a module, needs to be constructed and then passed
to the functor explcitly. In ATS, the template implementation needed for
compiling a particular template instance is located through a search
procedure (that follows the standard principle of lexical scoping).

')#comment("para")

#para('\

With #dyncode("list_map"), we can implement both #dyncode("list_map_fun")
and #dyncode("list_map_cloref") as follows in a straightforward manner:

#atscode('\
implement
{a}{b}
list_map_fun(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_fun]

(* ****** ****** *)

implement
{a}{b}
list_map_cloref(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_cloref]
')

For those who are familiar with functors in SML, the implementation of
#dyncode("list_map_fun") and #dyncode("list_map_cloref") should clearly
remind them of functor application.

')#comment("para")

#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/list_map.dats", "list_map.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="templates-as-a-special-form-of-functors"-->

<!-- ****** ****** -->

<sect1
 id="template-for-loop-construction">
#title("Example: Templates for Loop Construction")

#para('\

Beginners in functional programming (FP) who have already acquired some
knowledge of imperative programming often ask about ways to construct
for-loops and while-loops in FP. A commonly given answer is that loop
constructs are unnecessary in FP as they can be readily replaced with
higher-order functions. Let us first see some thorny issues with this
answer.\

')#comment("para")

#para('\

The following code in C implements a function that returns the sum
of the first n natural numbers when applied to a natural number n:

#atscode('\
int
tally (int n) {
  int i, res;
  for (i = 0, res = 0; i < n; i += 1) res += i;
  return res;
}
')

This function #dyncode("tally") can be given the following
equivalent implementation in ATS:

#atscode('\
fun
tally
(
  n: int
) : int = loop (0, 0) where
{
  fun loop (i: int, res: int): int =
    if i < n then loop (i + 1, res + i) else res
}
')

where the tail-recursive function #dyncode("loop") is just a translation
of the for-loop in C.

')#comment("para")

#para('\

When someone claims that loop constructs can be replaced with higher-order
functions, he or she probably means to construct loops with a function like
the following one:

#atscode('\
fun
for_loop
(
  count: int, limit: int, fwork: (int) -<cloref1> void
) : void = (
if count < limit
  then (fwork(count); for_loop(count+1, limit, fwork)) else ()
// end of [if]
) (* end of [for_loop] *)
')

For instance, the following function #dyncode("tally2") is directly based
on #dyncode("for_loop"):

#atscode('\
fun
tally2
(
  n: int
) : int = let
  val res = ref<int> (0)
in
  for_loop (0, n, lam (i) => !res := !res + i); !res
end // end of [tally2]
')

While both #dyncode("tally") and #dyncode("tally2") return the same result
when applied to a given natural number, they behave very differently at
run-time. In particular, each call to #dyncode("tally2") creates a
(persistent) reference on heap for temporary use; the reference becomes
garbage immediately after the call returns. Compared to #dyncode("tally"),
#dyncode("tally2") is inefficient both time-wise and memory-wise.\

')#comment("para")

#para('\

To eliminate the need for reference creation in #dyncode("tally2"), we
turn #dyncode("for_loop") into the following function template
#dyncode("for_loop2"):

#atscode('\
fun{
env:t@ype
} for_loop2
(
  count: int, limit: int
, env: &env >> _, fwork: (int, &env >> _) -<cloref1> void
) : void = (
if
count < limit
then (
  fwork(count, env); for_loop2<env> (count+1, limit, env, fwork)
) else ()
// end of [if]
) (* end of [for_loop2] *)
')

We can further turn #dyncode("tally2") into the following #dyncode("tally3")
based on #dyncode("for_loop2"):

#atscode('\
fun
tally3
(
  n: int
) : int = let
  var res: int = 0
in
  for_loop2<int> (0, n, res, lam (i, res) => res := res + i); res
end // end of [tally3]
')

While #dyncode("tally3") improves upon #dyncode("tally2"), it is still a
bit unsatisfactory. Clearly, the closure function formed before
#dyncode("tally3") calls #dyncode("for_loop2") becomes garbage immediately
after the call returns. It is plausible to expect an optimizing C compiler
(e.g., gcc and clang) can eliminate the need for actual closure formation
when it is called on the C code generated from ATS source, but there is
no guarantee. In order to have such a guarantee, we can evolve
#dyncode("for_loop2") into the following function template
#dyncode("for_loop3:") 

#atscode('\
fun{
env:t@ype
} for_loop3
(
  count: int, limit: int, env: &env >> _
) : void = (
if
count < limit
then (
  for_loop3$fwork<env>(count, env); for_loop3<env>(count+1, limit, env)
) else ()
// end of [if]
) (* end of [for_loop3] *)
')

where #dyncode("for_loop3$fwork") is given the interface below:

#atscode('\
fun{
env:t@ype
} for_loop3$fwork(count: int, env: &env >> _): void
')

Finally, we can turn #dyncode("tally3") into #dyncode("tally4")
as follows:

#atscode('\
fun
tally4
(
  n: int
) : int = let
//
var res: int = 0
//
implement
for_loop3$fwork<int> (i, res) = res := res + i
//
in
  for_loop3<int> (0, n, res); res
end // end of [tally4]
')

By inspecting the C code generated by #command("patsopt") from compiling
#dyncode("tally4"), we can see that the C code is essentially equivalent to
the implementation of #dyncode("tally") in C (given at the beginning of
this section).

')#comment("para")

#para('\

By now, the reader probably agrees with me if I say the statement should at
least be considered grossly inaccurate that claims loop constructs in FP
can be readily replaced with higher-order functions.  Please find on-line
the file #mycodelink("CHAP_FNTMPINT/loopcons.dats", "loopcons.dats")
containing the entirety of the code presented in this section plus some
testing code.\

')#comment("para")

</sect1><!--id="template-for-loop-construction"-->

<!-- ****** ****** -->

<sect1
 id="template-based-support-for-late-binding">
#title("Template-Based Support for Late-Binding")

#para('\

When asked about the meaning of object-oriented programming (OOP),
Alan Kay once said that OOP to him meant only messaging, local retention
and protection and hiding of state-process, and extreme late-binding of all
things.

')#comment("para")

</sect1><!--id="template-based-support-for-late-binding"-->

<!-- ****** ****** -->

</chapter>
<!--id="from-genericity-to-late-binding"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
