%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"dlist_vt.dats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/dlist_vt.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

#atscode_separator()

staload "prelude/SATS/dlist_vt.sats"

#atscode_separator()

dataviewtype
DLIST (
  a:viewt@ype+, int
) = // DLIST
  | {r:nat}
    DLISTcons (a, r+1) of (a, ptr(*prev*), DLIST (a, r))
  | DLISTnil (a, 0) of ()
// end of [DLIST]

#atscode_separator()

extern
castfn
DLIST2ptr {a:vt0p}{r:int} (xs: !DLIST(INV(a), r)):<> ptr

#atscode_separator()

assume
dlist_viewtype (a: vt0p, f:int, r:int) = DLIST (a, r)

#atscode_separator()

\#define nullp the_null_ptr

#atscode_separator()

implement{} dlist_vt_nil {a} () = DLISTnil ()

#atscode_separator()

implement{a}
dlist_vt_cons
  (x, xs) = let
in
//
case+ xs of
| @DLISTcons
    (_, prev, _) => let
    val p_prev = addr@ (prev)
    prval () = fold@ (xs) // HX: no-op
    val res = DLISTcons {a} (x, nullp, xs)
    val () =
      $effmask_wrt ($UN.ptr_set<ptr> (p_prev, DLIST2ptr(res)))
    // end of [val]
  in
    res
  end // end of [DLISTcons]
| ~DLISTnil () => DLISTcons {a} (x, nullp, DLISTnil ())
//
end // end of [dlist_vt_cons]

#atscode_separator()

implement{a}
dlist_vt_snoc
  (xs, x) = let
//
val node =
  DLISTcons {a} (x, DLIST2ptr(xs), DLISTnil ())
val node1 =
  __ref (node) where {
  extern castfn __ref (xs: !DLIST(a, 1)):<> DLIST(a, 1)
} // end of [where] // end of [val]
val+ @DLISTcons
  (_, _, xs1) = xs
val+ ~DLISTnil () = xs1; val () = $effmask_wrt (xs1 := node1)
prval () = fold@ {a} (xs)
prval () =
  __unref (xs) where { extern praxi __unref (xs: DLIST(a, 2)): void }
// end of [prval]
//
in
  node
end // end of [dlist_vt_snoc]

#atscode_separator()

implement{}
dlist_vt_is_nil (xs) =
  case+ xs of DLISTnil () => true | DLISTcons _ => false
// end of [dlist_vt_is_nil]

implement{}
dlist_vt_is_cons (xs) =
  case+ xs of DLISTnil () => false | DLISTcons _ => true
// end of [dlist_vt_is_cons]

#atscode_separator()

implement{a}
dlist_vt_getref_elt (xs) = let
  val+ @DLISTcons (x, _, _) = xs; val p_x = addr@ (x) in fold@(xs); p_x
end // end of [dlist_vt_get_elt]

implement{a}
dlist_vt_getref_next (xs) = let
  val+ @DLISTcons (_, _, xs1) = xs; val p_xs1 = addr@ (xs1) in fold@(xs); p_xs1
end // end of [dlist_vt_get_next]

#atscode_separator()

implement{a}
dlist_vt_get
  (xs) = let
  val+ DLISTcons (x, _, _) = xs in x
end // end of [dlist_vt_get]

implement{a}
dlist_vt_set
  (xs, x0) = let
  val+ @DLISTcons (x, _, _) = xs in x := x0; fold@ (xs)
end // end of [dlist_vt_set]

#atscode_separator()

implement{a}
dlist_vt_is_atbeg
  {f,r} (xs) = let
  prval () = lemma1_dlist_vt_param {a}{f,r} (xs)
in
//
if dlist_vt_is_cons (xs) then let
  val+ DLISTcons (_, prev, _) = xs
  val [b:bool] ans = (
    if prev > nullp then false else true
  ) : Bool // end of [val]
  prval () = __assert () where {
    extern praxi __assert (): [b==(f==0)] void
  } // end of [where] // end of [prval]
in
  ans
end else let
  prval () = lemma3_dlist_vt_param {a}{f} (xs)
in
  true
end // end of [if]
//
end // end of [dlist_vt_is_atbeg]

implement{a}
dlist_vt_is_atend
  {f,r} (xs) = let
  val+ @DLISTcons
    (_, _, xs1) = xs
  val next = DLIST2ptr (xs1)
  prval () = fold@ (xs)
  val [b:bool] ans = (
    if next > nullp then false else true
  ) : Bool // end of [val]
  prval () = __assert () where {
    extern praxi __assert (): [b==(r==1)] void
  } // end of [prval]
in
  ans
end // end of [dlist_vt_is_atend]

#atscode_separator()

implement{a}
rdlist_vt_is_atbeg
  {f,r} (xs) = dlist_vt_is_atend {f,r} (xs)
// end of [rdlist_vt_is_atbeg]

implement{a}
rdlist_vt_is_atend
  {f,r} (xs) = dlist_vt_is_atbeg {f,r} (xs)
// end of [rdlist_vt_is_atend]

#atscode_separator()

implement{a}
dlist_vt_length
  {f,r} (xs) = let
//
fun loop {r:nat}{r0:int} .<r>.
  (xs: !DLIST (a, r), res: int (r0)):<> int (r0+r) =
  case+ xs of
  | DLISTcons
      (_, _, xs1) => loop (xs1, res + 1)
  | DLISTnil () => res
// end of [loop]
prval () = lemma1_dlist_vt_param {a}{f,r} (xs)
//
in
  loop (xs, 0)
end // end of [dlist_vt_length]

implement{a}
rdlist_vt_length
  {f,r} (xs) = let
//
fun loop {f:nat} .<f>.
  (prev: ptr, res: int):<> int = let
  val [r:int] xs = __cast (prev) where {
    extern castfn __cast : ptr -<> [r:nat] DLIST (a, r)
  } // end of [where] // end of [val]
in
//
case+ xs of
| DLISTcons
    (_, prev, _) => let
    prval () = __assert () where {
      extern praxi __assert (): [f > 0] void
    } // end of [where] // end of [prval]
    prval () = __free (xs) where {
      extern praxi __free : DLIST (a, r) -<prf> void
    } // end of [where] // end of [prval]
  in
    loop {f-1} (prev, res + 1)
  end // end of [DLISTcons]
| ~DLISTnil () => res
//
end // end of [loop]
//
prval () =
  lemma1_dlist_vt_param {a}{f,r} (xs)
//
val res = (
  case+ xs of
  | DLISTcons
      (_, prev, _) => loop {f} (prev, 0)
  | DLISTnil () => 0
) : int // end of [val]
//
in
  $UN.cast {int(f)} (res)
end // end of [rdlist_vt_length]

#atscode_separator()

implement{a}
dlist_vt_move
  {f,r} (xs) = let
//
val+ DLISTcons (_, _, xs1) = xs
//
val xs1 =
  __ref (xs1) where {
  extern castfn __ref (xs: !DLIST(a, r-1)):<> DLIST(a, r-1)
} // end of [where] // end of [val]
prval () =
  __unref (xs) where { extern praxi __unref (xs: DLIST (a, r)): void}
// end of [prval]
//
in
  xs1 (* : dlist_vt (a, f+1, r-1) *)
end // end of [dlist_vt_move]

implement{a}
dlist_vt_move_all
  {f,r} (xs) = let
  val isend = dlist_vt_is_atend {f,r} (xs)
  prval () = lemma1_dlist_vt_param {a}{f,r} (xs)
in
  if isend then
    xs else dlist_vt_move_all {f+1,r-1} (dlist_vt_move {f,r} (xs))
  // end of [if]
end // end of [dlist_vt_move_all]

#atscode_separator()

implement{a}
rdlist_vt_move
  {f,r} (xs) = let
//
prval () =
  lemma1_dlist_vt_param {a}{f,r} (xs)
prval () = (
  sif r == 0 then lemma3_dlist_vt_param {a}{f} (xs) else () 
) : [r > 0] void // end of [prval]
//
val+ DLISTcons (_, prev, _) = xs
//
prval () =
  __free (xs) where {
  extern praxi __free (xs: DLIST (a, r)): void
} // end of [where] // end of [prval]
//
in
//
  $UN.castvwtp0 {DLIST(a, r+1)} (prev)
//
end // end of [rdlist_vt_move]

implement{a}
rdlist_vt_move_all
  {f,r} (xs) = let
//
val () =
  lemma1_dlist_vt_param {a}{f,r} (xs)
//
fun loop 
  {f,r:int | f >= 0; r > 0} .<f>. (
  xs: dlist_vt (INV(a), f, r)
) :<> dlist_vt (a, 0, f+r) = let
  val isend = rdlist_vt_is_atend {f,r} (xs)
  prval () = lemma1_dlist_vt_param {a}{f,r} (xs)
in
  if isend then
    xs else loop {f-1,r+1} (rdlist_vt_move {f,r} (xs))
  // end of [if]
end // end of [loop]
//
in
//
if dlist_vt_is_cons (xs) then let
in
 loop {f,r} (xs)
end else let
  prval () = lemma3_dlist_vt_param {a}{f} (xs)
in
  xs
end // end of [if]
//
end // end of [rdlist_vt_move_all]

#atscode_separator()

implement{a}
dlist_vt_insert
  (xs, x0) = let
//
val+ @DLISTcons (_, prev, _) = xs
val p_prev = addr@ (prev); val prev = prev
prval () = fold@ (xs)
val xs2 = DLISTcons {a} (x0, prev, xs)
val () = $UN.ptr_set (p_prev, DLIST2ptr (xs2))
//
val () =
  if prev > nullp then {
  val xs_prev =
    $UN.castvwtp0 {DLIST (a, 1)} (prev)
  val p_prev_next = dlist_vt_getref_next (xs_prev)
  prval () =
    __free (xs_prev) where { extern praxi __free : DLIST (a, 1) -<prf> void }
  // end of [prval]
  val () = $UN.ptr_set (p_prev_next, DLIST2ptr (xs2))
} // end of [if] // end of [val]
//
in
  xs2
end // end of [dlist_vt_insert]

#atscode_separator()

implement{a}
dlist_vt_remove
  (xs, x0) = let
//
val+ ~DLISTcons (x, prev, xs1) = xs
val () = x0 := x
val+ @DLISTcons (_, prev1, xs2) = xs1
val () = prev1 := prev
prval () = fold@ (xs1)
//
val () =
  if prev > nullp then {
  val xs_prev =
    $UN.castvwtp0 {DLIST (a, 1)} (prev)
  val p_prev_next = dlist_vt_getref_next (xs_prev)
  prval () =
    __free (xs_prev) where { extern praxi __free : DLIST (a, 1) -<prf> void }
  // end of [prval]
  val () = $UN.ptr_set (p_prev_next, DLIST2ptr (xs1))
} // end of [if] // end of [val]
//
in
  xs1
end // end of [dlist_vt_remove]

#atscode_separator()

implement{a}
rdlist_vt_insert
  (xs, x0) =
  dlist_vt_move (dlist_vt_insert (xs, x0))
// end of [rdlist_vt_insert]

implement{a}
rdlist_vt_remove
  {f,r} (xs, x0) = let
//
  prval () = lemma1_dlist_vt_param {a}{f,r} (xs)
  prval () = lemma2_dlist_vt_param {a}{f,r} (xs)
//
in
  dlist_vt_remove (rdlist_vt_move {f,r} (xs), x0)
end // end of [rdlist_vt_remove]

#atscode_separator()

implement{a}
dlist_vt_append
  {f1,r1}{f2,r2} (xs1, xs2) = let
  prval () = lemma1_dlist_vt_param {a}{f1,r1} (xs1)
  prval () = lemma1_dlist_vt_param {a}{f2,r2} (xs2)
in
//
if dlist_vt_is_cons (xs2) then let
  val xs2 = rdlist_vt_move_all {f2,r2} (xs2)
in
  if dlist_vt_is_cons (xs1) then let
//
    val p1 = DLIST2ptr (xs1)
    val xs1_last = dlist_vt_move_all {f1,r1} (xs1)
//
    val () = {
      val+ @DLISTcons (_, prev, _) = xs2
      val () = prev := DLIST2ptr (xs1_last)
      prval () = fold@ (xs2)
    } // end of [val]
//
    val () = {
      val+ @DLISTcons
        (_, _, next) = xs1_last
      val+ ~DLISTnil () = next // HX: no-op
      val () = next := xs2
      prval () = fold@ (xs1_last)
    } // end of [val]
//
    prval () =
      __free (xs1_last) where {
      extern praxi __free : DLIST (a, 1+f2+r2) -<prf> void
    } // end of [prval]
//
  in
    $UN.castvwtp0 {dlist_vt (a, f1, r1+f2+r2)} (p1)
  end else let
    prval () = lemma3_dlist_vt_param {a}{f1} (xs1)
    val+ ~DLISTnil () = xs1
  in
    xs2
  end // end of [if]
end else let
  prval () = lemma3_dlist_vt_param {a}{f2} (xs2)
  val+ ~DLISTnil () = xs2
in
  xs1
end // end of [if]
//
end // end of [dlist_vt_append]

#atscode_separator()

implement{a}
rdlist_vt_append
  {f1,r1}{f2,r2} (xs1, xs2) = let
//
  viewtypedef res = dlist_vt (a, f1+r1+f2, r2)
//
  prval () = lemma1_dlist_vt_param {a}{f1,r1} (xs1)
  prval () = lemma1_dlist_vt_param {a}{f2,r2} (xs2)
//
in
//
if dlist_vt_is_cons (xs1) then let
//
  val xs1 = dlist_vt_move_all {f1,r1} (xs1)
//
  val p2 = DLIST2ptr (xs2)
  val xs2_first = rdlist_vt_move_all {f2,r2} (xs2)
//
  val () = {
    val+ @DLISTcons
      (_, prev, _) = xs2_first
    val () = prev := DLIST2ptr (xs1)
    val () = fold@ (xs2_first)
  } // end of [val]
//
  val () = {
    val+ @DLISTcons (_, _, next) = xs1
    val+ ~DLISTnil () = next // HX: no-op
    val () = next := xs2_first
    prval () = fold@ (xs1)
  } // end of [val]
//
  prval () =
    __free (xs1) where {
    extern praxi __free : DLIST (a, 1+f2+r2) -<prf> void
  } // end of [prval]
//
in
  $UN.castvwtp0 {res} (p2)
end else let
  prval () = lemma3_dlist_vt_param {a}{f1} (xs1)
  val+ ~DLISTnil () = xs1
in
  xs2
end // end of [if]
//
end // end of [rdlist_vt_append]

#atscode_separator()

implement{a}
dlist_vt_free {r} (xs) = let
//
fun loop
  {r:nat} .<r>.
  (xs: DLIST (a, r)):<> void =
  case+ xs of
  | ~DLISTcons (_, _, xs) => loop (xs) | ~DLISTnil () => ()
// end of [loop]
prval () = lemma1_dlist_vt_param {a}{0,r} (xs)
//
in
  loop (xs)
end // end of [dlist_vt_free]

#atscode_separator()

implement
{a}{env}
dlist_vt_foreach_env
  (xs, env) = let
//
prval () =
  lemma1_dlist_vt_param (xs)
// end of [prval]
//
fun loop
  {r:nat} .<r>. (
  xs: !DLIST (a, r), env: &env
) : void = let
in
//
case+ xs of
| @DLISTcons
    (x, _(*prev*), xs1) => let
    val () =
      dlist_vt_foreach$fwork<a><env> (x, env)
    // end of [val]
    val () = loop (xs1, env)
    prval () = fold@ (xs) // HX: no-op
  in
    // nothing
  end // end of [DLISTcons]
| DLISTnil () => ()
//
end // end of [loop]
//
in
  loop (xs, env)
end // end of [dlist_vt_foreach_env]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "dlist_vt_atxt.txt")
%}\
