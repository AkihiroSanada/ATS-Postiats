%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"string.dats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/string.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("April, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"

#atscode_separator()

\#define CNUL '\000'

#atscode_separator()

overload + with add_ptr_bsz

#atscode_separator()

macdef castvwtp_trans = $UN.castvwtp0 // former name

#atscode_separator()

extern
fun memcpy
  (d:ptr, s:ptr, n:size_t):<!wrt> ptr = "mac\#atspre_string_memcpy"
// end of [memcpy]

#atscode_separator()

implement{}
string_is_empty (str) = let
  val p = string2ptr(str) in $UN.ptr1_get<char>(p) = CNUL
end // end of [string_is_empty]
implement{}
string_isnot_empty (str) = let
  val p = string2ptr(str) in $UN.ptr1_get<char>(p) != CNUL
end // end of [string_isnot_empty]

#atscode_separator()

implement{}
string_is_atend_size{n}{i}
  (str, i) = let
  val p_i = add_ptr_bsz (string2ptr(str), i)
in
  $UN.cast{bool(n==i)}($UN.ptr1_get<char>(p_i) = CNUL)
end // end of [string_is_atend_size]

implement{tk}
string_is_atend_gint (str, i) =
  string_is_atend_size (str, g1int2uint(i))
// end of [string_is_atend_gint]
implement{tk}
string_is_atend_guint (str, i) =
  string_is_atend_size (str, g1uint2uint(i))
// end of [string_is_atend_guint]

#atscode_separator()

implement{}
string_get_at_size (str, i) =
  $UN.ptr1_get<charNZ>(string2ptr(str) + i)
// end of [string_get_at_size]

implement{tk}
string_get_at_gint (str, i) =
  string_get_at_size (str, g1int2uint (i))
// end of [string_get_at_gint]
implement{tk}
string_get_at_guint (str, i) =
  string_get_at_size (str, g1uint2uint (i))
// end of [string_get_at_guint]

#atscode_separator()

implement{}
string_test_at_size
  {n}{i} (str, i) = let
//
extern
castfn
__cast (c: char):<>
  [c:int] (string_index_p (n, i, c) | char (c))
//
in
  __cast ($UN.ptr1_get<char>(string2ptr(str) + i))
end // end of [string_test_at_size]

implement{tk}
string_test_at_gint (str, i) =
  string_test_at_size (str, g1int2uint (i))
// end of [string_test_at_gint]
implement{tk}
string_test_at_guint (str, i) =
  string_test_at_size (str, g1uint2uint (i))
// end of [string_test_at_guint]

#atscode_separator()

%{
fun
fun_string_cmp_decl
  (opr: string): atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
implement
%s_string_string (x1, x2) = (compare_string_string (x1, x2) %s 0)\
", @(
 opr, fopr_d
)
) // end of [sprintf] // end of [val]
in
  atext_strptr (ent)
end // end of [fun_char_cmp0_decl]
%}\
\
#fun_string_cmp_decl("lt")
#fun_string_cmp_decl("lte")
#fun_string_cmp_decl("gt")
#fun_string_cmp_decl("gte")
#fun_string_cmp_decl("eq")
#fun_string_cmp_decl("neq")

#atscode_separator()

implement
strintcmp
  {n1,n2} (x1, n2) = let
//
prval () = lemma_string_param (x1)
//
fun loop
  {n2:nat} .<n2>.
  (p1: ptr, n2: int n2):<> int = let
  val c = $UN.ptr0_get<char>(p1)
in
  if c != CNUL then (
    if n2 > 0 then loop (ptr_succ<char>(p1), n2-1) else 1(*gt*)
  ) else (
    if n2 > 0 then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop (string2ptr(x1), n2))
end // end of [strintcmp]

implement
strlencmp
  {n1,n2} (x1, x2) = let
//
prval () = lemma_string_param (x1)
prval () = lemma_string_param (x2)
//
//
fun loop
  {n1:nat} .<n1>. (
  p1: ptr, p2: ptr
) :<> int = let
  val c1 = $UN.ptr0_get<char>(p1)
  val c2 = $UN.ptr0_get<char>(p2)
in
  if c1 != CNUL then let
    prval () =
      __assert () where {
      extern praxi __assert (): [n1 > 0] void
    } // end of [prval]
  in
    if c2 != CNUL then
      loop {n1-1} (ptr_succ<char>(p1), ptr_succ<char>(p2))
    else 1(*gt*) // end of [if]
  end else (
    if c2 != CNUL then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop{n1}(string2ptr(x1), string2ptr(x2)))
end // end of [strlencmp]

#atscode_separator()

implement
fprint_string (out, x) = fileref_puts (out, x)

#atscode_separator()

implement
string_make_list (cs) =
  string_make_listlen (cs, list_length (cs))
// end of [string_make_list]

implement
string_make_listlen
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p, c)
  in
    loop (cs, n-1, ptr_succ<char>(p))
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc ((i2sz)n1))
val p1 = $effmask_wrt (loop (cs, n, p0))
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_listlen]

#atscode_separator()

implement
string_make_list_rev (cs) =
  string_make_listlen_rev (cs, list_length (cs))
// end of [string_make_list_rev]

implement
string_make_listlen_rev
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val p1 = ptr_pred<char>(p)
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p1, c)
  in
    loop (cs, n-1, p1)
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc ((i2sz)n1))
val p1 = ptr_add<char>(p0, n)
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
val p0 = $effmask_wrt (loop (cs, n, p1))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_listlen_rev]

#atscode_separator()

implement{
} string_make_substring
  {n}{st,ln}
  (str, st, ln) = $effmask_wrt let
//
val ln1 = succ(ln)
val (pf, pfgc | p_dst) = malloc_gc (ln1)
val p_src = string2ptr(str)
val p_dst = memcpy (p_dst, p_src + st, ln)
//
val () = $UN.ptr0_set<char>(p_dst + ln, CNUL)
//
in
  castvwtp_trans{strnptr(ln)}((pf, pfgc | p_dst))
end // end of [string_make_substring]

#atscode_separator()

implement{}
string0_length
  (str) = string1_length ($UN.cast{String}(str))
// end of [string0_length]

implement{}
string1_length
  {n} (str) =
  __strlen (str) where {
  extern fun __strlen (str: string n):<> size_t (n) = "mac\#atspre_strlen"
} // end of [where] // end of [string1_length]

#atscode_separator()

implement{}
string0_copy
  (str) = let
  val str = string2str (str)
  val str2 = string1_copy (str)
  prval () = lemma_strnptr_param (str2)
in
  strnptr2strptr (str2)
end // end of [string0_copy]

implement{}
string1_copy
  {n} (str) = let
  val n = string1_length (str)
  val n1 = succ(n)
  val (pf, pfgc | p) = malloc_gc (n1)
  val _(*p*) = $effmask_wrt (memcpy (p, string2ptr(str), n1))
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p))
end // end of [string1_copy]

#atscode_separator()

implement{
} strchr {n} (str, c0) = let
  prval () = lemma_string_param (str)
  extern fun __strchr (string, int):<> ptr = "mac\#atspre_strchr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr(str)
  val p1 = __strchr (str, (char2int0)c0)
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strchr]

implement{
} strrchr {n} (str, c0) = let
  prval () = lemma_string_param (str)
  extern fun __strrchr (string, int):<> ptr = "mac\#atspre_strrchr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr(str)
  val p1 = __strrchr (str, (char2int0)c0)
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strrchr]

#atscode_separator()

implement{
} strstr {n} (haystack, needle) = let
  prval () = lemma_string_param (haystack)
  extern fun __strstr (string, string):<> ptr = "mac\#atspre_strstr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr(haystack)
  val p1 = __strstr (haystack, needle)
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strstr]

#atscode_separator()

implement{
} strspn {n}
  (str, accept) = let
  prval () = lemma_string_param (str)
  extern fun __strspn (string, string):<> sizeLte (n) = "mac\#atspre_strspn"
in
  __strspn (str, accept)
end // end of [strspn]

implement{
} strcspn {n}
  (str, reject) = let
  prval () = lemma_string_param (str)
  extern fun __strcspn (string, string):<> sizeLte (n) = "mac\#atspre_strcspn"
in
  __strcspn (str, reject)
end // end of [strcspn]

#atscode_separator()

implement{}
string_index {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strchr (str, c))
// end of [string_index]

implement{}
string_rindex {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strrchr (str, c))
// end of [string_rindex]

#atscode_separator()

implement{}
string0_append
  (x1, x2) = let
//
val x1 = string1_of_string0 (x1)
val x2 = string1_of_string0 (x2)
val x12 = string1_append (x1, x2)
prval () = lemma_strnptr_param (x12)
//
in
  strnptr2strptr (x12)
end // end of [string0_append]

implement{}
string1_append
  {n1,n2} (x1, x2) = let
//
val n1 = strlen (x1) and n2 = strlen (x2)
//
val n12 = n1 + n2
val (pf, fpf | p) = malloc_gc (succ(n12))
//
val p1 = memcpy (p, string2ptr(x1), n1)
val p2 = memcpy (p + n1, string2ptr(x2), succ(n2))
//
in
  castvwtp_trans{strnptr(n1+n2)}((pf, fpf | p))
end // end of [string1_append]

#atscode_separator()

implement
stringlst_concat
  (xs) = $effmask_all let
//
prval () = lemma_list_param (xs)
//
val ns = let
//
implement
list_map$fwork<string><size_t> (x) = string0_length (x)
//
in
  list_map<string><size_t> (xs)
end // end of [ns]
//
val ntot = let
//
implement
list_foldleft$fwork<size_t><size_t> (acc, n) = acc + n
//
in
  list_foldleft ($UN.list_vt2t (ns), (i2sz)0)
end // end of [ntot]
//
fun loop {n:nat} .<n>. (
  p: ptr, xs: list (string, n), ns: list_vt (size_t, n)
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val+~list_vt_cons (n, ns) = ns
    val _(*p*) = memcpy (p, string2ptr(x), n)
  in
    loop (ptr_add<char> (p, n), xs, ns)
  end // end of [list_cons]
| list_nil () => let
    val+~list_vt_nil () = ns in $UN.ptr0_set<char> (p, CNUL)
  end // end of [list_nil]
//
end // end of [loop]
//
val ntot = g1ofg0_uint (ntot)
val (pf, pfgc | p) = malloc_gc (succ(ntot))
val () = loop (p, xs, ns)
//
in
  castvwtp_trans{Strptr1}((pf, pfgc | p))
end // end of [stringlst_concat]

#atscode_separator()

implement
string_explode
  {n} (x) = let
//
prval () = lemma_string_param (x)
//
viewtypedef res(n) = list_vt (charNZ, n)
//
fun loop {n:nat} .<n>. (
  x: string n, res: &ptr? >> res(n)
) :<!wrt> void = let
  val p = string2ptr (x)
  val c = $UN.ptr1_get<Char> (p)
in
  if c != CNUL then let
    prval () = __assert () where {
      extern praxi __assert (): [n > 0] void
    }
    val () = res :=
      list_vt_cons {charNZ}{0} (c, _)
    val+list_vt_cons (_, res1) = res
    val x = $UN.cast{string(n-1)} (ptr1_succ(p))
    val () = loop (x, res1)
  in
    fold@ (res)
  end else let
    prval () = __assert () where {
      extern praxi __assert (): [n == 0] void
    }
  in
    res := list_vt_nil ()
  end // end of [if]
end // end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (x, res))
//
in
  res
end // end of [string_explode]

#atscode_separator()

implement{}
string_tabulate {n} (n) = let
//
prval () = lemma_g1uint_param (n)
//
fun loop (
  p: ptr, n: size_t, i: size_t
) : void = let
in
//
if i < n then let
  val c = string_tabulate$fwork (i)
  val () = $UN.ptr0_set<char> (p, c)
in
  loop (ptr_succ<char> (p), n, succ (i))
end else
  $UN.ptr0_set<char> (p, CNUL)
// end of [if]
//
end // end of [loop]
//
val n1 = succ(n)
val (pf, fpf | p0) = malloc_gc (n1)
val () = loop (p0, n, g1int2uint (0))
//
in
  castvwtp_trans{strnptr(n)}((pf, fpf | p0))
end // end of [string_tabulate]

#atscode_separator()

implement{env}
string_foreach$cont (c, env) = true
implement{env}
string_foreach$fwork (c, env) = ((*void*))

implement{}
string_foreach (str) = let
  var env: void = () in string_foreach_env (str, env)
end // end of [string_foreach]

implement{env}
string_foreach_env
  {n} (str, env) = let
//
fun loop (
  p: ptr, env: &env
) : ptr = let
  val c = $UN.ptr0_get<char> (p)
  val cont = (
    if c != CNUL then string_foreach$cont<env> (c, env) else false
  ) : bool // end of [val]
in
  if cont then let
    val () =
      string_foreach$fwork<env> (c, env) in loop (ptr_succ<char> (p), env)
    // end of [val]
  end else (p) // end of [if]
end // end of [fun]
//
val p0 =
  string2ptr (str)
val p1 = loop (p0, env)
//
in
  $UN.cast{sizeLte(n)}(p1 - p0)
end // end of [string_foreach_env]

#atscode_separator()

implement{env}
string_rforeach$cont (c, env) = true
implement{env}
string_rforeach$fwork (c, env) = ((*void*))

implement{}
string_rforeach (str) = let
  var env: void = () in string_rforeach_env (str, env)
end // end of [string_rforeach]

implement{env}
string_rforeach_env
  {n} (str, env) = let
//
val n = string1_length (str)
typedef chararr = array (char, n)
val p = string2ptr (str)
prval (pf, fpf) = $UN.ptr_vtake {chararr} (p)
//
implement
array_rforeach$cont<char><env>
  (c, env) = string_rforeach$cont<env> (c, env)
implement
array_rforeach$fwork<char><env>
  (c, env) = string_rforeach$fwork<env> (c, env)
val res = array_rforeach_env<char><env> (!p, n, env)
//
prval () = fpf (pf)
//
in
  res
end // end of [string_rforeach_env]

#atscode_separator()

(*
//
// HX-2013-03: it is now defined as a macro
//
implement
stropt_none () = $UN.cast{stropt(~1)} (the_null_ptr)
*)

#atscode_separator()

implement{
} stropt_is_none {n} (x) = (
  $UN.cast{bool(n < 0)} (ptr0_is_null ($UN.cast2ptr (x)))
) // end of [stropt_is_none]

implement{
} stropt_is_some {n} (x) = (
  $UN.cast{bool(n>=0)} (ptr0_isnot_null ($UN.cast2ptr (x)))
) // end of [stropt_is_some]

#atscode_separator()

implement{
} stropt_length (x) = let
  prval () = lemma_stropt_param (x)
in
  if stropt_is_some (x) then
    g1uint2int (string1_length (stropt_unsome(x)))
  else i2ssz(~1) // end of [if]
end // end of [stropt_length]

#atscode_separator()

implement
fprint_stropt
  (out, x) = (
  if stropt_is_some (x) then
    fprint_string (out, stropt_unsome(x))
  else fprint_ptr (out, the_null_ptr)
) // end of [fprint_stropt]

#atscode_separator()

implement fprint_val<string> = fprint_string

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "string_atxt.txt")
%}\
