%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"string.dats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/string.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("April, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"

#atscode_separator()

\#define CNUL '\000'

#atscode_separator()

extern
fun memcpy
  (d:ptr, s:ptr, n:size_t):<!wrt> ptr = "mac\#atslib_memcpy"
// end of [memcpy]

#atscode_separator()

implement{}
string_is_empty (str) = let
  val p = string2ptr (str) in $UN.ptr_get<char> (p) = CNUL
end // end of [string_is_empty]

implement{}
string_isnot_empty (str) = ~string_is_empty (str)

#atscode_separator()

%{
fun
fun_string_cmp_decl
  (opr: string): atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
implement
%s_string_string (x1, x2) = (compare_string_string (x1, x2) %s 0)\
", @(
 opr, fopr_d
)
) // end of [sprintf] // end of [val]
in
  atext_strptr (ent)
end // end of [fun_char_cmp0_decl]
%}\
\
#fun_string_cmp_decl("lt")
#fun_string_cmp_decl("lte")
#fun_string_cmp_decl("gt")
#fun_string_cmp_decl("gte")
#fun_string_cmp_decl("eq")
#fun_string_cmp_decl("neq")

#atscode_separator()

implement
strintcmp
  {n1,n2} (x1, n2) = let
//
prval () = lemma_string_param (x1)
//
fun loop
  {n2:nat} .<n2>.
  (p1: ptr, n2: int n2):<> int = let
  val c = $UN.ptr0_get<char> (p1)
in
  if c != CNUL then (
    if n2 > 0 then loop (ptr0_succ(p1), n2-1) else 1(*gt*)
  ) else (
    if n2 > 0 then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop (string2ptr(x1), n2))
end // end of [strintcmp]

implement
strlencmp
  {n1,n2} (x1, x2) = let
//
prval () = lemma_string_param (x1)
prval () = lemma_string_param (x2)
//
//
fun loop
  {n1:nat} .<n1>. (
  p1: ptr, p2: ptr
) :<> int = let
  val c1 = $UN.ptr0_get<char> (p1)
  val c2 = $UN.ptr0_get<char> (p2)
in
  if c1 != CNUL then let
    prval () =
      __assert () where {
      extern praxi __assert (): [n1 > 0] void
    } // end of [prval]
  in
    if c2 != CNUL then
      loop {n1-1} (ptr0_succ(p1), ptr0_succ(p2))
    else 1(*gt*) // end of [if]
  end else (
    if c2 != CNUL then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop{n1}(string2ptr(x1), string2ptr(x2)))
end // end of [strlencmp]

#atscode_separator()

implement
fprint_string (out, x) = fileref_puts (out, x)

#atscode_separator()

implement
string_make_list (cs) =
  string_make_listlen (cs, list_length (cs))
// end of [string_make_list]

implement
string_make_listlen
  {n} (cs, n) = $effmask_wrt let
//
prval () = lemma_list_param (cs)
//
fun loop {n:nat} .<n>. (
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val+ list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char> (p, c)
  in
    loop (cs, n-1, ptr0_succ<char>(p))
  end else p // end of [val]
end // end of [loop]
//
val n1 = n + 1
val (
  pf, pfgc | p0
) = malloc_gc (g1int2uint(n1))
val p1 = loop (cs, n, p0)
val () = $UN.ptr0_set<char> (p1, CNUL)
//
in
  $UN.castvwtp_trans {strnptr(n)} @(pf, pfgc | p0)
end // end of [string_make_listlen]

#atscode_separator()

implement
string_make_list_rev (cs) =
  string_make_listlen_rev (cs, list_length (cs))
// end of [string_make_list_rev]

implement
string_make_listlen_rev
  {n} (cs, n) = $effmask_wrt let
//
prval () = lemma_list_param (cs)
//
fun loop {n:nat} .<n>. (
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val p = ptr0_pred<char> (p)
    val+ list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char> (p, c)
  in
    loop (cs, n-1, p)
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (
  pf, pfgc | p0
) = malloc_gc (g1int2uint(n1))
val p1 = ptr0_add_int<char> (p0, n)
val () = $UN.ptr0_set<char> (p1, CNUL)
val p0 = loop (cs, n, p1)
//
in
  $UN.castvwtp_trans {strnptr(n)} @(pf, pfgc | p0)
end // end of [string_make_listlen_rev]

#atscode_separator()

implement
string_make_substring
  {n}{st,ln}
  (str, st, ln) = $effmask_wrt let
//
val ln1 = succ(ln)
val (pf, pfgc | p_dst) = malloc_gc (ln1)
val p_src = ptr1_add_uint<char> (string2ptr(str), st)
val _(*p_dst*) = memcpy (p_dst, p_src, ln)
//
val p_dst_ln =
  ptr1_add_uint<char> (p_dst, ln)
val () =
  $UN.ptr0_set<char> (p_dst_ln, CNUL)
//
in
  $UN.castvwtp_trans {strnptr(ln)} @(pf, pfgc | p_dst)
end // end of [string_make_substring]

#atscode_separator()

implement
string0_length
  (str) = string1_length ($UN.cast{String}(str))
// end of [string0_length]

implement
string1_length
  {n} (str) =
  __strlen (str) where {
  extern fun __strlen (str: string n):<> size_t (n) = "mac\#atspre_strlen"
} // end of [where] // end of [string1_length]

#atscode_separator()

implement
string0_copy (str) = let
  val str = string1_of_string0 (str)
  val str1 = string1_copy (str)
  prval () = lemma_string_param (str)
  prval () = lemma_strnptr_param (str1)
in
  strptr_of_strnptr (str1)
end // end of [string0_copy]

implement
string1_copy
  {n} (str) = let
  val n = string1_length (str)
  val n1 = succ(n)
  val (pf, pfgc | p) = malloc_gc (n1)
  val _(*p*) = $effmask_wrt (memcpy (p, string2ptr(str), n1))
in
  $UN.castvwtp_trans {strnptr(n)} @(pf, pfgc | p)
end // end of [string1_copy]

#atscode_separator()

implement
strchr {n} (str, c0) = let
  prval () = lemma_string_param (str)
  extern fun __strchr (string, int):<> ptr = "mac\#atspre_strchr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr (str)
  val p1 = __strchr (str, (int_of_char)c0)
in
  if p1 > the_null_ptr then __sub (p1, p0) else g1int2int (~1)
end // end of [strchr]

implement
strrchr {n} (str, c0) = let
  prval () = lemma_string_param (str)
  extern fun __strrchr (string, int):<> ptr = "mac\#atspre_strrchr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr (str)
  val p1 = __strrchr (str, (int_of_char)c0)
in
  if p1 > the_null_ptr then __sub (p1, p0) else g1int2int (~1)
end // end of [strrchr]

#atscode_separator()

implement
strstr {n} (haystack, needle) = let
  prval () = lemma_string_param (haystack)
  extern fun __strstr (string, string):<> ptr = "mac\#atspre_strstr"
  extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac\#atspre_sub_ptr_ptr"
  val p0 = string2ptr (haystack)
  val p1 = __strstr (haystack, needle)
in
  if p1 > the_null_ptr then __sub (p1, p0) else g1int2int (~1)
end // end of [strstr]

#atscode_separator()

implement
strspn {n} (str, accept) = let
  prval () = lemma_string_param (str)
  extern fun __strspn (string, string):<> sizeLte (n) = "mac\#atspre_strspn"
in
  __strspn (str, accept)
end // end of [strspn]

implement
strcspn {n} (str, reject) = let
  prval () = lemma_string_param (str)
  extern fun __strcspn (string, string):<> sizeLte (n) = "mac\#atspre_strcspn"
in
  __strcspn (str, reject)
end // end of [strcspn]

#atscode_separator()

implement
stringlst_concat
  (xs) = $effmask_all let
//
implement
list_map__fwork<string><size_t> (x) = string0_length x
val ns = list_map<string><size_t> (xs)
//
implement
list_foldleft__fwork<size_t><size_t> (acc, n) = acc + n
val ntot = list_foldleft ($UN.listcast (ns), g1int2uint(0))
//
fun loop {n:nat} .<n>. (
  p: ptr, xs: list (string, n), ns: list_vt (size_t, n)
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val+ ~list_vt_cons (n, ns) = ns
    val _(*p*) = memcpy (p, string2ptr(x), n)
  in
    loop (ptr0_add_uint<char> (p, n), xs, ns)
  end
| list_nil () => let
    val+ ~list_vt_nil () = ns in $UN.ptr0_set<char> (p, CNUL)
  end // end of [list_nil]
//
end // end of [loop]
//
val ntot = g1ofg0_uint (ntot)
val (pf, pfgc | p) = malloc_gc (succ(ntot))
val () = loop (p, xs, ns)
//
in
  $UN.castvwtp_trans {Strptr1} @(pf, pfgc | p)
end // end of [stringlst_concat]

#atscode_separator()

implement
string_explode
  {n} (x) = let
//
prval () = lemma_string_param (x)
//
viewtypedef res(n) = list_vt (charNZ, n)
//
fun loop {n:nat} .<n>. (
  x: string n, res: &ptr? >> res(n)
) :<!wrt> void = let
  val p = string2ptr (x)
  val c = $UN.ptr_get<Char> (p)
in
  if c != CNUL then let
    prval () = __assert () where {
      extern praxi __assert (): [n > 0] void
    }
    val () = res :=
      list_vt_cons {charNZ}{0} (c, _)
    val+ list_vt_cons (_, res1) = res
    val x = $UN.cast{string(n-1)} (ptr1_succ(p))
    val () = loop (x, res1)
  in
    fold@ (res)
  end else let
    prval () = __assert () where {
      extern praxi __assert (): [n == 0] void
    }
  in
    res := list_vt_nil ()
  end // end of [if]
end // end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (x, res))
//
in
  res
end // end of [string_explode]

#atscode_separator()

implement{env}
string_foreach__cont (c, env) = true
implement{env}
string_foreach__fwork (c, env) = ((*void*))

implement{}
string_foreach (str) = let
  var env: void = () in string_foreach_env (str, env)
end // end of [string_foreach]

implement{env}
string_foreach_env
  {n} (str, env) = let
//
fun loop (
  p: ptr, env: &env
) : ptr = let
  val c = $UN.ptr0_get<char> (p)
  val cont = (
    if c != CNUL then string_foreach__cont (c, env) else false
  ) : bool // end of [val]
in
  if cont then let
    val () =
      string_foreach__fwork<env> (c, env)
    val p = ptr0_succ<char> (p)
  in
    loop (p, env)
  end else p // end of [if]
end // end of [fun]
//
val p0 =
  string2ptr (str)
val p1 = loop (p0, env)
//
in
  $UN.cast{sizeLte(n)}(p1 - p0)
end // end of [string_foreach_env]

#atscode_separator()

implement{env}
string_rforeach__cont (c, env) = true
implement{env}
string_rforeach__fwork (c, env) = ((*void*))

implement{}
string_rforeach (str) = let
  var env: void = () in string_rforeach_env (str, env)
end // end of [string_rforeach]

implement{env}
string_rforeach_env
  {n} (str, env) = let
//
val n = string1_length (str)
typedef chararr = array (char, n)
val p = string2ptr (str)
prval (pf, fpf) = $UN.ptr_vget {chararr} (p)
//
implement
array_rforeach__cont<char><env>
  (c, env) = string_rforeach__cont<env> (c, env)
implement
array_rforeach__fwork<char><env>
  (c, env) = string_rforeach__fwork<env> (c, env)
val res = array_rforeach_env<char><env> (!p, n, env)
//
prval () = fpf (pf)
//
in
  res
end // end of [string_rforeach_env]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "string_atxt.txt")
%}\
