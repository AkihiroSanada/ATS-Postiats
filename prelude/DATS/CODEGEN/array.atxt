%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"array.dats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"
staload IT = "prelude/SATS/iterator.sats"

#atscode_separator()

implement{a}
array_getref_at
  (A, i) = let
  val p = ptr0_add_uint (addr@(A), i) in $UN.cast2Ptr1 (p)
end // end of [array_getref_at]

implement{a}
array_get_at (A, i) = let
  val p = ptr0_add_uint (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at]

implement{a}
array_set_at (A, i, x) = let
  val p = ptr0_add_uint (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at]

implement{a}
array_exch_at (A, i, x) = let
  val p = ptr0_add_uint (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at]

#atscode_separator()

implement{a}
array_ptr_takeout
  {l}{n}{i}(pf | p, i) = let
  prval pfout = array_v_takeout {a}{l}{n}{i} (pf)
in
  (pfout | ptr1_add_uint<a> (p, i))
end // end of [array_ptr_takeout]

#atscode_separator()

implement{a}
array_ptr_alloc
  {n} (asz) = let
  val [l:addr] (
    pf, pfgc | p
  ) = malloc_gc (asz * sizeof<a>)
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: b0ytes (n*sizeof(a)) @ l): array_v (a?, l, n)
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  (pf, pfgc | p)
end // end of [array_ptr_alloc]

#atscode_separator()

implement
array_ptr_free
  {a}{l}{n} (pf, pfgc | p) = let
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: array_v (a?, l, n)): b0ytes (n*sizeof(a)) @ l
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  free_gc (pf, pfgc | p)
end // end of [array_ptr_free]

#atscode_separator()

implement{a}
array_copy
  {n} (to, from, n) = let
  val p_to = addr@(to) and p_from = addr@(to)
  extern fun memcpy (
    p1: ptr, p2: ptr, n: size_t
  ) :<!wrt> void = "mac\#atslib_memcpy"
  val () = memcpy (p_to, p_from, n*sizeof<a>)
  extern praxi __assert {l1,l2:addr} (
    pf1: !array_v (a?, l1, n) >> array_v (a  , l1, n)
  , pf2: !array_v (a , l2, n) >> array_v (a?!, l2, n)
  ) : void // end of [__assert]
  prval () = __assert (view@ (to), view@ (from))
in
  // nothing
end // end of [array_copy]

#atscode_separator()

implement{a}
array_copy_from_list
  (A, xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list (a, n)
) :<!wrt> void = (
  case+ xs of
  | list_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list]

#atscode_separator()

implement{a}
array_copy_from_list_vt
  (A, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list_vt (a, n)
) :<!wrt> void = (
  case+ xs of
  | ~list_vt_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list_vt]

#atscode_separator()

implement{a}
array_copy_to_list_vt
  (A, n) = res where {
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l, n: size_t n, res: &ptr? >> list_vt (a, n)
) :<!wrt> void = (
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = res := list_vt_cons {a}{0} (!p, _)
    val+ list_vt_cons (_, res1) = res
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    res := list_vt_nil ()
  end // end of [if]
) (* end of [loop] *)
//
var res: ptr
val () = loop (view@(A) | addr@(A), n, res)
//
} // end of [array_copy_to_list_vt]

#atscode_separator()

implement{a}{env}
array_foreach__cont (x, env) = true
implement{a}{env}
array_foreach__fwork (x, env) = ((*void*))

implement{a}
array_foreach (A, asz) = let
  var env: void = () in array_foreach_env<a><void> (A, asz, env)
end // end of [array_foreach]

implement
{a}{env}
array_foreach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val cont = array_foreach__cont (!p, env)
  in
    if cont then let
      val () = array_foreach__fwork (!p, env)
      val res = loop (pf2 | ptr1_succ<a> (p), pred(n), env)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      res
    end else let
      prval () = pf := array_v_cons (pf1, pf2) in n
    end (* end of [if] *)
  end else n(*0*)
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | p_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach_env]

#atscode_separator()

implement{a}{env}
array_rforeach__cont (x, env) = true
implement{a}{env}
array_rforeach__fwork (x, env) = ((*void*))

implement{a}
array_rforeach (A, asz) = let
  var env: void = () in array_rforeach_env<a><void> (A, asz, env)
end // end of [array_rforeach]

implement
{a}{env}
array_rforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| p: ptr (l+n*sizeof(a)), n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_unextend (pf)
    val p = ptr1_pred<a> (p)
    val n = pred (n) // HX: current index
    val (pf2 | p) = viewptr_match (pf2 | p)
    val cont = array_rforeach__cont (!p, env)
  in
    if cont then let
      val () = array_rforeach__fwork (!p, env)
      val res = loop (pf1 | p, n, env)
      prval () = pf := array_v_extend (pf1, pf2)
    in
      res
    end else let
      prval () = pf := array_v_extend (pf1, pf2) in n
    end (* end of [if] *)
  end else n (*0*)
end // end of [loop]
//
val p_end =
  ptr1_add_uint<a> (addr@(A), asz)
val n = loop (view@(A) | p_end, asz, env)
in
  asz - n
end // end of [array_rforeach_env]

#atscode_separator()

implement{a}
array_initize
  (A, asz) = let
//
prval () = lemma_g1uint_param (asz)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n) | p: ptr l, n: size_t n, i: size_t
) : void =
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = array_initize__fwork (i, !p)
    val () = loop (pf2 | ptr1_add_int<a> (p, 1), pred(n), succ(i))
    prval () = pf := array_v_cons {a} (pf1, pf2)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    // nothing
  end // end of [if]
//
in
  loop (view@ (A) | addr@ (A), asz, g0int2uint(0))
end // end of [array_initize]

#atscode_separator()

implement{a}
array_initize_elt
  (A, asz, elt) = let
//
implement
array_initize__fwork<a> (i, xi) = xi := elt
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_elt]

#atscode_separator()

implement{a}
array_initize_list
  (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
var xs = $UN.cast2ptr (xs)
val p_xs = $UN.cast{Ptr1} (addr@ (xs))
//
implement
array_initize__fwork<a>
  (i, xi) = let
  val+ list_cons
    (x, xs) = $UN.ptr_get<list1> (p_xs)
  val () = $UN.ptr_set<list0> (p_xs, xs)
in
  xi := x
end // end of [array_initize__fwork]
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_list]

#atscode_separator()

implement{a}
array_initize_list_vt
  (A, asz, xs) = let
//
viewtypedef list0 = listGte_vt (a, 0)
viewtypedef list1 = listGte_vt (a, 1)
//
var xs =
  $UN.castvwtp_trans{ptr} (xs)
val p_xs = $UN.cast{Ptr1} (addr@ (xs))
//
implement
array_initize__fwork<a>
  (i, xi) = let
  val+ ~list_vt_cons
    (x, xs) = $UN.ptr_get<list1> (p_xs)
  val () = $UN.ptr_set<list0> (p_xs, xs)
in
  xi := x
end // end of [array_initize__fwork]
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_list_vt]

#atscode_separator()

implement{a}
array_bsearch
  (A, n) = $effmask_all let
//
val itr = $IT.iter_make_array (view@(A) | addr@(A), n)
//
implement
$IT.iter_bsearch__ford<a> (x) = array_bsearch__ford<a> (x)
val () = $IT.iter_bsearch (itr, n)
//
val ofs = $IT.iter_get_offset (itr)
//
val (pf | ()) = $IT.iter_free_array (itr)
prval () = view@ (A) := pf
//
in
  ofs
end // end of [array_bsearch_funenv]

#atscode_separator()

implement{a}
array_quicksort_fun
  (A, asz, cmp) = let
  val tsz = sizeof<a>
  extern fun qsort (
    base: ptr, asz: size_t, tsz: size_t, cmp: cmpref (a)
  ) :<> void = "mac\#atslib_qsort"
in
  qsort (addr@(A), asz, tsz, cmp)
end // end of [array_quicksort_fun]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "array_atxt.txt")
%}\
