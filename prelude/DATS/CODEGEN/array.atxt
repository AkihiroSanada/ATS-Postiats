%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"array.dats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"
staload IT = "prelude/SATS/iterator.sats"

#atscode_separator()

implement{a}
array_getref_at
  (A, i) = let
  val p = ptr0_add_guint (addr@(A), i) in $UN.cast{cPtr1(a)}(p)
end // end of [array_getref_at]

implement{a}
array_get_at_size (A, i) = let
  val p = ptr0_add_guint (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at_size]

implement{a}
array_set_at_size (A, i, x) = let
  val p = ptr0_add_guint (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at_size]

implement{a}
array_exch_at_size (A, i, x) = let
  val p = ptr0_add_guint (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at_size]

#atscode_separator()

implement{a}
array_interchange
  (A, i, j) = let
in
//
if i != j then let
  val p = addr@(A)
  val pi = ptr0_add_guint<a> (p, i)
  val pj = ptr1_of_ptr0 (ptr0_add_guint<a> (p, j))
  prval (pf, fpf) = $UN.ptr_vtake {a} (pj)
  val () = $UN.ptr0_exch<a> (pi, !pj)
  prval () = fpf (pf)
in
  // nothing
end else () // end of [if]
//
end // end of [array_interchange]

#atscode_separator()

implement{a}
array_ptr_takeout
  {l}{n}{i}(pf | p, i) = let
  prval pfout =
    array_v_takeout {a}{l}{n}{i} (pf)
  // end of [prval]
in
  (pfout | ptr1_add_guint<a> (p, i))
end // end of [array_ptr_takeout]

#atscode_separator()

implement{a}
array_ptr_alloc
  {n} (asz) = let
  val [l:addr] (
    pf, pfgc | p
  ) = malloc_gc (asz * sizeof<a>)
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: b0ytes (n*sizeof(a)) @ l): array_v (a?, l, n)
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  (pf, pfgc | p)
end // end of [array_ptr_alloc]

#atscode_separator()

implement
array_ptr_free
  {a}{l}{n} (pf, pfgc | p) = let
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: array_v (a?, l, n)): b0ytes (n*sizeof(a)) @ l
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  free_gc (pf, pfgc | p)
end // end of [array_ptr_free]

#atscode_separator()

implement{}
fprint_array__sep
  (out) = fprint_string (out, "; ")
// end of [fprint_array__sep]

implement{a}
fprint_array
  (out, A, asz) = let
//
typedef tenv = int
implement
array_foreach__fwork<a><tenv>
  (x, env) = let
  val n = env
  val () = if n > 0 then fprint_array__sep<> (out)
  val () = env := n + 1
in
  fprint_ref<a> (out, x)
end // end of [array_foreach__fwork]
//
var env: tenv = 0
val _(*n*) = array_foreach_env<a><tenv> (A, asz, env)
//
in
  // nothing
end // end of [fprint_array]

implement{a}
fprint_array_sep
  (out, A, asz, sep) = let
//
implement
fprint_array__sep<> (out) = fprint_string (out, sep)
//
in
  fprint_array<a> (out, A, asz)
end // end of [fprint_array_sep]

#atscode_separator()

implement{a}
array_copy
  {n} (to, from, n) = let
  val p_to = addr@(to) and p_from = addr@(to)
  extern fun memcpy (
    p1: ptr, p2: ptr, n: size_t
  ) :<!wrt> void = "mac\#atslib_memcpy"
  val () = memcpy (p_to, p_from, n*sizeof<a>)
  extern praxi __assert {l1,l2:addr} (
    pf1: !array_v (a?, l1, n) >> array_v (a  , l1, n)
  , pf2: !array_v (a , l2, n) >> array_v (a?!, l2, n)
  ) : void // end of [__assert]
  prval () = __assert (view@ (to), view@ (from))
in
  // nothing
end // end of [array_copy]

#atscode_separator()

implement{a}
array_copy_from_list
  (A, xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list (a, n)
) :<!wrt> void = (
  case+ xs of
  | list_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list]

#atscode_separator()

implement{a}
array_copy_from_list_vt
  (A, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list_vt (a, n)
) :<!wrt> void = (
  case+ xs of
  | ~list_vt_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list_vt]

#atscode_separator()

implement{a}
array_copy_to_list_vt
  (A, n) = res where {
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l, n: size_t n, res: &ptr? >> list_vt (a, n)
) :<!wrt> void = (
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = res := list_vt_cons {a}{0} (!p, _)
    val+ list_vt_cons (_, res1) = res
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    res := list_vt_nil ()
  end // end of [if]
) (* end of [loop] *)
//
var res: ptr
val () = loop (view@(A) | addr@(A), n, res)
//
} // end of [array_copy_to_list_vt]

#atscode_separator()

implement{a}{env}
array_foreach__cont (x, env) = true
implement{a}{env}
array_foreach__fwork (x, env) = ((*void*))

implement{a}
array_foreach (A, asz) = let
  var env: void = () in array_foreach_env<a><void> (A, asz, env)
end // end of [array_foreach]

implement
{a}{env}
array_foreach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val cont = array_foreach__cont (!p, env)
  in
    if cont then let
      val () = array_foreach__fwork (!p, env)
      val res = loop (pf2 | ptr1_succ<a> (p), pred(n), env)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      res
    end else let
      prval () = pf := array_v_cons (pf1, pf2) in n
    end (* end of [if] *)
  end else n(*0*)
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | p_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach_env]

#atscode_separator()

implement{a}
array_foreach_funenv
  {v}{vt} (pf | A, asz, f, env) =
  array_foreach_funenv_tsz {a}{v}{vt} (pf | A, asz, sizeof<a>, f, env)
// end of [array_foreach_funenv]

implement{a}
array_foreach_fun
  {n}{fe} (A, asz, f) = let
  typedef tfun = (!unit_v | &a, !ptr) -<fun,fe> void
  val f = $UN.cast{tfun} (f)
  prval pfu = unit_v ()
  var env: ptr = the_null_ptr
  val () = array_foreach_funenv<a> (pfu | A, asz, f, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_fun]

implement{a}
array_foreach_cloref
  {n}{fe} (A, asz, f) = let
//
  viewdef v = unit_v
  typedef vt = (&a) -<cloref,fe> void
//
  fun app .<>. (pf: !v | x: &a, env: !vt):<fe> void = env (x)
  prval pfu = unit_v ()
  var env = f
  val () = array_foreach_funenv<a> {v}{vt} (pfu | A, asz, app, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_cloref]

#atscode_separator()

implement
{a1,a2}{env}
array_foreach2__cont (x1, x2, env) = true
implement
{a1,a2}{env}
array_foreach2__fwork (x1, x2, env) = ((*void*))

implement
{a1,a2}
array_foreach2 (A1, A2, asz) = let
  var env: void = () in array_foreach2_env<a1,a2><void> (A1, A2, asz, env)
end // end of [array_foreach2]

implement
{a1,a2}{env}
array_foreach2_env
  {n0} (A1, A2, asz, env) = let
//
prval () = lemma_array_param (A1)
//
fun loop
  {l1,l2:addr}
  {n:nat | n <= n0} .<n>. (
  pf1: !array_v (a1, l1, n)
, pf2: !array_v (a2, l2, n)
| p1: ptr l1, p2: ptr l2, n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (pf11, pf12) = array_v_uncons (pf1)
    prval (pf21, pf22) = array_v_uncons (pf2)
    val cont = array_foreach2__cont (!p1, !p2, env)
  in
    if cont then let
      val () = array_foreach2__fwork (!p1, !p2, env)
      val res = loop (
        pf12, pf22 | ptr1_succ<a1> (p1), ptr1_succ<a2> (p2), pred(n), env
      ) // end of [val]
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22)
    in
      res
    end else let
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22) in n
    end (* end of [if] *)
  end else n(*0*)
end // end of [loop]
//
val p1_beg = addr@(A1)
val p2_beg = addr@(A2)
val n = loop (view@(A1), view@(A2) | p1_beg, p2_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach2_env]

#atscode_separator()

implement{a}{env}
array_rforeach__cont (x, env) = true
implement{a}{env}
array_rforeach__fwork (x, env) = ((*void*))

implement{a}
array_rforeach (A, asz) = let
  var env: void = () in array_rforeach_env<a><void> (A, asz, env)
end // end of [array_rforeach]

implement
{a}{env}
array_rforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| p: ptr (l+n*sizeof(a)), n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_unextend (pf)
    val p = ptr1_pred<a> (p)
    val n = pred (n) // HX: current index
    val (pf2 | p) = viewptr_match (pf2 | p)
    val cont = array_rforeach__cont (!p, env)
  in
    if cont then let
      val () = array_rforeach__fwork (!p, env)
      val res = loop (pf1 | p, n, env)
      prval () = pf := array_v_extend (pf1, pf2)
    in
      res
    end else let
      prval () = pf := array_v_extend (pf1, pf2) in n
    end (* end of [if] *)
  end else n (*0*)
end // end of [loop]
//
val p_end =
  ptr1_add_guint<a> (addr@(A), asz)
val n = loop (view@(A) | p_end, asz, env)
in
  asz - n
end // end of [array_rforeach_env]

#atscode_separator()

implement{a}
array_initize
  (A, asz) = let
//
prval () = lemma_g1uint_param (asz)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n) | p: ptr l, n: size_t n, i: size_t
) : void =
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = array_initize__init (i, !p)
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), succ(i))
    prval () = pf := array_v_cons {a} (pf1, pf2)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    // nothing
  end // end of [if]
//
in
  loop (view@ (A) | addr@ (A), asz, g0int2uint(0))
end // end of [array_initize]

#atscode_separator()

implement{a}
array_initize_elt
  (A, asz, elt) = let
//
implement
array_initize__init<a> (i, xi) = xi := elt
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_elt]

#atscode_separator()

implement{a}
array_initize_list
  (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
var xs = $UN.cast2ptr (xs)
val p_xs = $UN.cast{Ptr1} (addr@ (xs))
//
implement
array_initize__init<a>
  (i, xi) = let
  val+ list_cons
    (x, xs) = $UN.ptr_get<list1> (p_xs)
  val () = $UN.ptr_set<list0> (p_xs, xs)
in
  xi := x
end // end of [array_initize__init]
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_list]

#atscode_separator()

implement{a}
array_initize_list_vt
  (A, asz, xs) = let
//
viewtypedef list0 = listGte_vt (a, 0)
viewtypedef list1 = listGte_vt (a, 1)
//
var xs =
  $UN.castvwtp_trans{ptr} (xs)
val p_xs = $UN.cast{Ptr1} (addr@ (xs))
//
implement
array_initize__init<a>
  (i, xi) = let
  val+ ~list_vt_cons
    (x, xs) = $UN.ptr_get<list1> (p_xs)
  val () = $UN.ptr_set<list0> (p_xs, xs)
in
  xi := x
end // end of [array_initize__init]
//
in
  $effmask_all (array_initize (A, asz))
end // end of [array_initize_list_vt]

#atscode_separator()

implement{a}
array_bsearch
  (A, n) = $effmask_all let
//
val itr =
  $IT.iter_make_array (view@(A) | addr@(A), n)
// end of [val]
implement
$IT.iter_bsearch__ford<a> (x) = array_bsearch__ford<a> (x)
val () = $IT.iter_bsearch (itr, n)
//
val ofs = $IT.iter_get_fofs (itr)
//
val (pf | ()) = $IT.iter_free_array (itr)
prval () = view@ (A) := pf
//
in
  ofs
end // end of [array_bsearch_funenv]

#atscode_separator()

implement{a}
array_quicksort_fun
  (A, asz, cmp) = let
  val tsz = sizeof<a>
  extern fun qsort (
    base: ptr, asz: size_t, tsz: size_t, cmp: cmpref (a)
  ) :<> void = "mac\#atslib_qsort"
in
  qsort (addr@(A), asz, tsz, cmp)
end // end of [array_quicksort_fun]

#atscode_separator()

implement{a}
array_permute (A, asz) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) | p: ptr l, n: size_t n
) : void = let
in
//
if n >= 2 then let
  val i = array_permute__randint<> (n)
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = if i > 0 then $UN.ptr0_exch<a> (ptr0_add_guint<a> (p, i), !p)
  val () = loop (pf2 | ptr1_succ<a> (p), pred (n))
  prval () = pf := array_v_cons (pf1, pf2)
in
  // nothing
end else () // end of [if]
//
end // end of [loop]
//
in
  loop (view@ (A) | addr@ (A), asz)
end // end of [array_permute]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "array_atxt.txt")
%}\
