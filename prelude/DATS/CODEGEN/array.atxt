%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"array.dats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"

#atscode_separator()

implement{a}
array_getref_at
  (A, i) = let
  val p = ptr_add_uint (addr@(A), i) in $UN.cast2Ptr1 (p)
end // end of [array_getref_at]

implement{a}
array_get_at (A, i) = let
  val p = ptr_add_uint (addr@(A), i) in $UN.ptr_get<a> ($UN.cast2Ptr1(p))
end // end of [array_get_at]

implement{a}
array_set_at (A, i, x) = let
  val p = ptr_add_uint (addr@(A), i) in $UN.ptr_set<a> ($UN.cast2Ptr1(p), x)
end // end of [array_set_at]

implement{a}
array_exch_at (A, i, x) = let
  val p = ptr_add_uint (addr@(A), i) in $UN.ptr_exch<a> ($UN.cast2Ptr1(p), x)
end // end of [array_exch_at]

#atscode_separator()

implement{a}
array_ptr_takeout
  {l}{n}{i}(pf | p, i) = let
  prval pfout = array_v_takeout {a}{l}{n}{i} (pf)
in
  (pfout | ptr1_add_uint<a> (p, i))
end // end of [array_ptr_takeout]

#atscode_separator()

implement{a}
array_ptr_alloc
  {n} (asz) = let
  val [l:addr] (
    pf, pfgc | p
  ) = malloc_gc (asz * sizeof<a>)
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: b0ytes (n*sizeof(a)) @ l): array_v (a?, l, n)
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  (pf, pfgc | p)
end // end of [array_ptr_alloc]

#atscode_separator()

implement
array_ptr_free
  {a}{l}{n} (pf, pfgc | p) = let
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: array_v (a?, l, n)): b0ytes (n*sizeof(a)) @ l
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  free_gc (pf, pfgc | p)
end // end of [array_ptr_free]

#atscode_separator()

implement{a}
array_copy
  {n} (to, from, n) = let
  val p_to = addr@(to) and p_from = addr@(to)
  extern fun memcpy (
    p1: ptr, p2: ptr, n: size_t
  ) :<!wrt> void = "mac\#atslib_memcpy"
  val () = memcpy (p_to, p_from, n*sizeof<a>)
  extern praxi __assert {l1,l2:addr} (
    pf1: !array_v (a?, l1, n) >> array_v (a  , l1, n)
  , pf2: !array_v (a , l2, n) >> array_v (a?!, l2, n)
  ) : void // end of [__assert]
  prval () = __assert (view@ (to), view@ (from))
in
  // nothing
end // end of [array_copy]

#atscode_separator()

implement{a}
array_copy_from_list
  (A, xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list (a, n)
) :<!wrt> void = (
  case+ xs of
  | list_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_add_int<a> (p, 1), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list]

#atscode_separator()

implement{a}
array_copy_from_list_vt
  (A, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list_vt (a, n)
) :<!wrt> void = (
  case+ xs of
  | ~list_vt_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_add_int<a> (p, 1), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list_vt]

#atscode_separator()

implement{a}
array_copy_to_list_vt
  (A, n) = res where {
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l, n: size_t n, res: &ptr? >> list_vt (a, n)
) :<!wrt> void = (
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = res := list_vt_cons {a}{0} (!p, _)
    val+ list_vt_cons (_, res1) = res
    val () = loop (pf2 | ptr1_add_int<a> (p, 1), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    res := list_vt_nil ()
  end // end of [if]
) (* end of [loop] *)
//
var res: ptr
val () = loop (view@(A) | addr@(A), n, res)
//
} // end of [array_copy_to_list_vt]

#atscode_separator()

implement{a}
array_foreach
  (A, asz) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) | p: ptr l, n: size_t n
) : void =
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val () = array_foreach__fwork (!p)
    val () = loop (pf2 | ptr1_add_int (p, 1), pred(n))
    prval () = pf := array_v_cons (pf1, pf2)
  in
    // nothing
  end else ()
// end of [loop]
in
  loop (view@(A) | addr@(A), asz)
end // end of [array_foreach]

implement{a}
array_iforeach
  (A, asz) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) | p: ptr l, n: size_t n, i: size_t
) : void =
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val () = array_iforeach__fwork (i, !p)
    val () = loop (pf2 | ptr1_add_int (p, 1), pred(n), succ(i))
    prval () = pf := array_v_cons (pf1, pf2)
  in
    // nothing
  end else ()
// end of [loop]
in
  loop (view@(A) | addr@(A), asz, g1int2uint(0))
end // end of [array_iforeach]

#atscode_separator()

implement{a}
array_foreach_funenv
  (pfv | A, asz, f, env) =
  array_foreach_funenv_tsz (pfv | A, asz, sizeof<a>, f, env)
// end of [array_foreach_funenv]

#atscode_separator()

implement{a}
array_iforeach_funenv
  (pfv | A, asz, f, env) =
  array_iforeach_funenv_tsz (pfv | A, asz, sizeof<a>, f, env)
// end of [array_iforeach_funenv]

#atscode_separator()

implement{a}
array_quicksort
  (A, asz, cmp) = let
  val tsz = sizeof<a>
  extern fun qsort (
    base: ptr, asz: size_t, tsz: size_t, cmp: cmpref (a)
  ) :<> void = "mac\#atslib_qsort"
in
  qsort (addr@(A), asz, tsz, cmp)
end // end of [array_quicksort]

#atscode_separator()

implement{a}
array_bsearch_funenv
  (A, n, pord, env) =
  $effmask_all let
  val itr =
    iter_make_array (view@(A) | addr@(A), n)
  val () = iter_bsearch_funenv (itr, pord, env, n)
  val ofs = iter_get_offset (itr)
  val (pf | ()) = iter_free_array (itr)
  prval () = view@ (A) := pf
in
  ofs
end // end of [array_bsearch_funenv]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "array_atxt.txt")
%}\
