%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"list_vt.dats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

staload UN = "prelude/SATS/unsafe.sats"

#atscode_separator()

implement{}
list_vt_is_nil (xs) =
  case+ xs of list_vt_nil () => true | _ =>> false
implement{}
list_vt_is_cons (xs) =
  case+ xs of list_vt_cons _ => true | _ =>> false

#atscode_separator()

implement{a}
list_vt_sing (x) = list_vt_cons (x, list_vt_nil ())

#atscode_separator()

implement{a}
list_vt_length (xs) = let
  prval () = lemma_list_vt_param (xs)
  fun loop
    {i,j:nat} .<i>. (
    xs: !list_vt (a, i), j: int j
  ) :<> int (i+j) =
    case+ xs of
    | list_vt_cons (_, xs) => loop (xs, j + 1)
    | list_vt_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [list_vt_length]

#atscode_separator()

implement{a}
list_vt_free (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>.
  (xs: list_vt (a, n)):<!wrt> void =
  case+ xs of
  | ~list_vt_cons (_, xs) => loop (xs) | ~list_vt_nil () => ()
// end of [loop]
//
in
  loop (xs)
end // end of [list_vt_free]

implement{a}
list_vt_free_fun
  {fe} (xs, f) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n), f: (&a>>a?) -<fe> void
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (x)
      val xs1_ = xs1
      val () = free@ {a?}{0} (xs)
    in
      loop (xs1_, f)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => ()
// end of [loop]
//
in
  loop (xs, f)
end // end of [list_vt_free_fun]

#atscode_separator()

implement{a}
list_vt_clear_fun
  {n}{fe} (xs, f) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n) >> list_vt (a?, n)
, f: (&a>>a?) -<fe> void
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (x)
      val () = loop (xs1, f)
      prval () = fold@ {a?} (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | @list_vt_nil () => fold@ {a?} (xs)
// end of [loop]
//
in
  loop (xs, f)
end // end of [list_vt_clear_fun]

#atscode_separator()

implement{a}
list_vt_append
  {m,n} (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop {m:nat} .<m>. (
  xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
) :<!wrt> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = loop (xs1, ys); prval () = fold@ (xs) in (*none*)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => (xs := ys)
// end of [loop]
var res = xs
val () = loop (res, ys)
//
in
  res
end // end of [list_vt_append]

implement{a}
list_vt_extend
  (xs, y) = list_vt_append<a> (xs, list_vt_sing<a> (y))
// end of [list_vt_extend]

#atscode_separator()

implement{a}
list_vt_reverse (xs) =
  list_vt_reverse_append<a> (xs, list_vt_nil)
// end of [list_vt_reverse]

#atscode_separator()

implement{a}
list_vt_reverse_append
  (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m,n:nat} .<m>. (
  xs: list_vt (a, m), ys: list_vt (a, n)
) :<!wrt> list_vt (a, m+n) =
  case xs of
  | @list_vt_cons
      (_, xs1) => let
      val xs1_ = xs1
      val () = xs1 := ys; prval () = fold@ (xs)
    in
      loop (xs1_, xs)
    end
  | ~list_vt_nil () => ys
(* end of [loop] *)
//
in
  loop (xs, ys)
end // end of [list_vt_reverse_append]

#atscode_separator()

implement{a}
list_vt_concat
  (xss) = let
  viewtypedef VT = List_vt (a)
  fun loop {n:nat} .<n>. (
    res: VT, xss: list_vt (VT, n)
  ) :<!wrt> VT =
    case+ xss of
    | ~list_vt_cons (xs, xss) => let
        val res = list_vt_append<a> (xs, res) in loop (res, xss)
      end // end of [list_vt_cons]
    | ~list_vt_nil () => res
  // end of [loop]
  val xss = list_vt_reverse (xss)
in
//
case+ xss of
| ~list_vt_cons
    (xs, xss) => loop (xs, xss)
| ~list_vt_nil () => list_vt_nil ()
//
end // end of [list_concat]

#atscode_separator()

implement{a}
list_vt_foreach_funenv
  {v}{vt}{n}{fe}
  (pf | xs, f, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  pf: !v
| xs: !list_vt (a, n)
, f: (!v | &a, !vt) -<fe> void
, env: !vt
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (pf | x, env)
      val () = loop (pf | xs1, f, env)
    in
      fold@ (xs)
    end // end of [list_vt_cons]
  | list_vt_nil () => ()
// end of [loop]
//
in
  loop (pf | xs, f, env)
end // end of [list_vt_foreach_funenv]

#atscode_separator()

implement{a}
list_vt_make_array
  {n} (A, n) = let
//
prval () = lemma_array_param (A)
viewtypedef res(n:int) = list_vt (a, n)
fun loop
  {l:addr}
  {n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l
, n: size_t n
, res: &ptr? >> res(n)
) :<!wrt> void =
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val () = res :=
      list_vt_cons {a}{0} (_, _)
    val+ list_vt_cons (x, res1) = res
    val () = x := !p
    val () = loop (pf2 | ptr1_add_int<a> (p, 1), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = array_v_unnil (pf)
    prval () = pf := array_v_nil ()
  in
    res := list_vt_nil ()
  end // end of [if]
// end of [loop]
var res: ptr // uninitialized
val () = $effmask_wrt (loop (view@(A) | addr@(A), n, res))
//
in
  res
end // end of [list_vt_make_array]

#atscode_separator()

implement{a}
list_vt_mergesort
  {n} (xs, cmp) = let
  var env: ptr = null
  val cmp = __cast (cmp) where {
    extern castfn __cast (cmp: cmpref (a)):<> cmpref (a, ptr)
  } // end of [val]
in
  list_vt_mergesort_env (xs, cmp, env)
end // end of [list_vt_mergesort]

implement{a}
list_vt_mergesort_env
  {vt}{n} (xs, cmp, env) = let
//
fun split {n,n1:nat | n >= n1} .<n1>. (
    xs: &list_vt (a, n) >> list_vt (a, n1)
  , n1: int n1, res: &List_vt a? >> list_vt (a, n-n1)
  ) :<!wrt> void =
  if n1 > 0 then let
    val+ @list_vt_cons (_, xs1) = xs
    val () = split (xs1, n1-1, res)
  in
    fold@ (xs)
  end else let
    val () = res := xs
    val () = xs := list_vt_nil ()
  in
    // nothing
  end // end of [if]
// end of [split]
fun merge {n1,n2:nat} .<n1+n2>. (
    xs1: list_vt (a, n1)
  , xs2: list_vt (a, n2)
  , cmp: cmpref (a, vt), env: !vt
  , res: &List_vt a? >> list_vt (a, n1+n2)
  ) :<!wrt> void =
  case+ xs1 of
  | @list_vt_cons (x1, xs11) => (
    case+ xs2 of
    | @list_vt_cons (x2, xs21) => let
        val sgn =
          compref_elt_elt_env (x1, x2, cmp, env)
        // end of [val]
      in
        if sgn <= 0 then let
          prval () = fold@ {a} (xs2)
          val () = merge (xs11, xs2, cmp, env, xs11)
          prval () = fold@ {a} (xs1)
        in
          res := xs1
        end else let
          prval () = fold@ {a} (xs1)
          val () = merge (xs1, xs21, cmp, env, xs21)
          prval () = fold@ {a} (xs2)
        in
          res := xs2
        end // end of [if]
      end // end of [list_vt_cons]
    | ~list_vt_nil () => (fold@ (xs1); res := xs1)
    ) // end of [list_vt_cons]
  | ~list_vt_nil () => (res := xs2)
// end of [merge]
//
val n = list_vt_length<a> (xs)
//
in
//
if n >= 2 then let
  val+ @list_vt_cons (_, xs1) = xs
  var res: List_vt a? // uninitialized
  val () = split (xs1, (n-1)/2, res)
  prval () = fold@ (xs)
  val xs1 = list_vt_mergesort_env<a> (xs, cmp, env)
  val xs2 = list_vt_mergesort_env<a> (res, cmp, env)
  val () = merge (xs1, xs2, cmp, env, res)
in
  res
end else xs // end of [if]
//
end // end of [list_vt_mergesort_env]

#atscode_separator()

(*
** HX-2012-05:
** copy a list into an array, perform quicksort on the
** array and then copy it back into the list
*)
implement{a}
list_vt_quicksort
  {n} (xs, cmp) = let
//
  prval () =
    lemma_list_vt_param (xs)
  // end of [prval]
//
  val n = list_vt_length (xs)
  val nsz = g1int2uint(n)
  abst@ype a2 = a?
  val (
    pf, pfgc | p
  ) = array_ptr_alloc<a2> (nsz)
  val () = let
    val xs1 = $UN.castvwtp1 {list(a2,n)} (xs)
  in
    array_copy_from_list (!p, xs1)
  end // end of [val]
  val cmp = $UN.cast {cmpref(a2)} (cmp)
  val () = array_quicksort (!p, nsz, cmp)
  val () = let
    fun loop
      {l:addr}{n:nat} .<n>. (
      pf: !array_v (a2, l, n) | xs: !list_vt (a, n), p: ptr l
    ) :<!wrt> void =
      case+ xs of
      | @list_vt_cons (x, xs1) => let
          prval (
            pf1, pf2
          ) = array_v_uncons (pf)
          val p_x = $UN.cast2Ptr1 (addr@(x))
          val () = $UN.ptr_set<a2> (p_x, !p)
          val () = loop (pf2 | xs1, ptr1_add_int<a2> (p, 1))
          prval () = pf := array_v_cons (pf1, pf2)
          prval () = fold@ (xs)
        in
          // nothing
        end // end of [list_vt]
      | list_vt_nil () => ()
    // end of [loop]
  in
    loop (pf | xs, p)
  end // end of [val]
  val () = array_ptr_free {a2} (pf, pfgc | p)
in
  xs
end // end of [list_vt_quicksort]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "list_vt_atxt.txt")
%}\
