%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"char.sats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
//
fun
fprint_print_prerr_decl
  (tnm: string): atext = let
//
val ent = sprintf ("\
fun fprint_%s
  : fprint_type (%s) = \"mac#atspre_fprint_%s\"
overload fprint with fprint_%s
fun print_%s (x: %s): void
and prerr_%s (x: %s): void
overload print with print_%s
overload prerr with prerr_%s\
", @(
 tnm, tnm, tnm, tnm, tnm, tnm, tnm, tnm, tnm, tnm
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fprint_print_prerr_decl]
//
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()
\
#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/char.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("September, 2011")

#atscode_separator()

sortdef t0p = t@ype

#atscode_separator()

fun char_of_int (i: int):<> char = "mac\#atspre_char_of_int"
fun schar_of_int (i: int):<> schar = "mac\#atspre_schar_of_int"
fun uchar_of_uint (u: uint):<> uchar = "mac\#atspre_uchar_of_uint"

#atscode_separator()

fun int_of_char (c: char):<> int = "mac\#atspre_int_of_char"
fun int_of_schar (c: schar):<> int = "mac\#atspre_int_of_schar"
fun int_of_uchar (c: uchar):<> int = "mac\#atspre_int_of_uchar"

fun uint_of_char (c: char):<> uint = "mac\#atspre_uint_of_char"
fun uint_of_schar (c: schar):<> uint = "mac\#atspre_uint_of_schar"
fun uint_of_uchar (c: uchar):<> uint = "mac\#atspre_uint_of_uchar"

#atscode_separator()

fun add_char_int
  (c1: char, i2: int):<> char = "mac\#atspre_add_char_int"
overload + with add_char_int
fun sub_char_int
  (c1: char, i2: int):<> char = "mac\#atspre_sub_char_int"
overload - with sub_char_int
fun sub_char_char
  (c1: char, c2: char):<> int = "mac\#atspre_sub_char_char"
overload - with sub_char_char

#atscode_separator()

%{
fun
fun_char_cmp0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_char_char
  (c1: char, c2: char):<> bool = \"mac#atspre_%s_char_char\"
overload %s with %s_char_char of 0\
", @(
 opr, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_char_cmp0_decl]
%}\
\
#fun_char_cmp0_decl("lt")
#fun_char_cmp0_decl("lte")

#fun_char_cmp0_decl("gt")
#fun_char_cmp0_decl("gte")

#fun_char_cmp0_decl("eq")
#fun_char_cmp0_decl("neq")
overload <> with neq_char_char of 0

fun compare_char_char
  (c1: char, c2: char):<> int = "atspre_compare_char_char"
overload compare with compare_char_char of 0

#atscode_separator()
#atscode_decl_strcst('\
//
// HX: the return is dynamically allocated
//
fun tostring_char
  (c: char):<> strnptr(1) = "atspre_tostring_char"
overload tostring with tostring_char
')\

#atscode_separator()
//
castfn
char1_of_schar1 {c:int} (c: schar (c)):<> char (c)
castfn
schar1_of_char1 {c:int} (c: char (c)):<> schar (c)
//
castfn
char1_of_uchar1 {c:int} (c: uchar (c)):<> char (u2i8(c))
castfn
uchar1_of_char1 {c:int} (c: char (c)):<> uchar (i2u8(c))
//
#atscode_separator()

%{
fun
fun_char_cmp1_decl (
  opr: string
) : atext = let
//
val fopr_s = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "==" | "neq" => "!="
  | _ => opr
) : string // end of [val]
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_char1_char1
  {c1,c2:int} (
  c1: char (c1), c2: char (c2)
) :<> bool (c1 %s c2) = \"mac#atspre_%s_char1_char1\"
overload %s with %s_char1_char1 of 20\
", @(
 opr, fopr_s, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_char_cmp1_decl]
%}\
\
#fun_char_cmp1_decl("lt")
#fun_char_cmp1_decl("lte")

#fun_char_cmp1_decl("gt")
#fun_char_cmp1_decl("gte")

#fun_char_cmp1_decl("eq")
#fun_char_cmp1_decl("neq")
overload <> with neq_char1_char1 of 20

#atscode_decl_strcst('\
fun compare_char1_char1
  {c1,c2:int} (
  c1: char c2, c2: char c2
) :<> int (c1-c2)
  = "mac\#atspre_compare_char1_char1"
overload compare with compare_char1_char1 of 20
')\

#atscode_separator()
//
// unsigned characters
//
#atscode_separator()

%{
fun
fun_uchar_cmp0_decl (
  opr: string, fopr: string
) : atext = let
//
val ent = sprintf ("\
fun %s_uchar_uchar
  (c1: uchar, c2: uchar):<> bool = \"mac#atspre_%s_uchar_uchar\"
overload %s with %s_uchar_uchar of 0\
", @(
 opr, opr, fopr, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_uchar_cmp0_decl]
%}\
\
#fun_uchar_cmp0_decl("lt", "<")
#fun_uchar_cmp0_decl("lte", "<=")

#fun_uchar_cmp0_decl("gt", ">")
#fun_uchar_cmp0_decl("gte", ">=")

#fun_uchar_cmp0_decl("eq", "=")
#fun_uchar_cmp0_decl("neq", "!=")
overload <> with neq_uchar_uchar of 0

#atscode_decl_strcst('\
fun compare_uchar_uchar
  (c1: uchar, c2: uchar):<> int = "mac\#atspre_compare_uchar_uchar"
overload compare with compare_uchar_uchar of 0
')\

#atscode_separator()

%{
fun
fun_uchar_cmp1_decl (
  opr: string
) : atext = let
//
val fopr_s = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "==" | "neq" => "!="
  | _ => opr
) : string // end of [val]
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_uchar1_uchar1
  {c1,c2:int} (
  c1: uchar (c1), c2: uchar (c2)
) :<> bool (c1 %s c2) = \"mac#atspre_%s_uchar1_uchar1\"
overload %s with %s_uchar1_uchar1 of 20\
", @(
 opr, fopr_s, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_uchar_cmp1_decl]
%}\
\
#fun_uchar_cmp1_decl("lt")
#fun_uchar_cmp1_decl("lte")

#fun_uchar_cmp1_decl("gt")
#fun_uchar_cmp1_decl("gte")

#fun_uchar_cmp1_decl("eq")
#fun_uchar_cmp1_decl("neq")
overload <> with neq_uchar1_uchar1 of 20

#atscode_decl_strcst('\
fun compare_uchar1_uchar1
  {c1,c2:int} (
  c1: uchar c2, c2: uchar c2
) :<> int (c1-c2)
  = "mac\#atspre_compare_uchar1_uchar1"
overload compare with compare_uchar1_uchar1 of 20
')\

#atscode_separator()

sortdef tk = tkind

#atscode_separator()

fun{tk:tk}
g0int_of_char (c: char):<> g0int (tk)
fun{tk:tk}
g0int_of_schar (c: schar):<> g0int (tk)
fun{tk:tk}
g0int_of_uchar (c: uchar):<> g0int (tk)

fun{tk:tk}
g0uint_of_uchar (c: uchar):<> g0uint (tk)

#atscode_separator()

fun{tk:tk}
g1int_of_char1 // c:int8
  {c:int} (c: char (c)):<> g1int (tk, c)
// end of [g1int_of_char1]
fun{tk:tk}
g1int_of_schar1 // c:int8
  {c:int} (c: schar (c)):<> g1int (tk, c)
// end of [g1int_of_schar1]
fun{tk:tk}
g1int_of_uchar1 // c:uint8
  {c:int} (c: uchar (c)):<> g1int (tk, c)
// end of [g1int_of_uchar1]

#atscode_decl_strcst('\
(*
** HX: g1uint_of_schar1: schar -> int -> uint
*)
fun{tk:tk}
g1uint_of_uchar1
  {c:int} (c: uchar (c)):<> g1uint (tk, c)
// end of [g1uint_of_uchar1]
')\

#atscode_separator()

#fprint_print_prerr_decl("char")
#fprint_print_prerr_decl("schar")
#fprint_print_prerr_decl("uchar")

#atscode_separator()

%{
fun
fun_isX_decl (
  isX: string
) : atext = let
//
val ent = sprintf ("\
symintr %s
fun %s_int (c: int):<> bool = \"atspre_%s_int\"
fun %s_char (c: char):<> bool = \"atspre_%s_char\"
overload %s with %s_int of 0
overload %s with %s_char of 10\
", @(
 isX, isX, isX, isX, isX, isX, isX, isX, isX
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_isX_decl]
%}\
\
#fun_isX_decl("isalpha")
#fun_isX_decl("isalnum")

#fun_isX_decl("isascii")

#fun_isX_decl("isblank")
#fun_isX_decl("isspace")

#fun_isX_decl("iscntrl")

#fun_isX_decl("isdigit")
#fun_isX_decl("isxdigit")

#fun_isX_decl("isgraph")
#fun_isX_decl("isprint")
#fun_isX_decl("ispunct")

#fun_isX_decl("islower")
#fun_isX_decl("isupper")

#atscode_separator()

fun toascii_int (c: int):<> int = "atspre_toascii_int"
fun toascii_char (c: char):<> char = "atspre_toascii_char"
fun tolower_int (c: int):<> int = "atspre_tolower_int"
fun tolower_char (c: char):<> char = "atspre_tolower_char"
fun toupper_int (c: int):<> int = "atspre_toupper_int"
fun toupper_char (c: char):<> char = "atspre_toupper_char"

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "char_atxt.txt")
%}\
