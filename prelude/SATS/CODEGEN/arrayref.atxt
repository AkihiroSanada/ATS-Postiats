%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"arrayref.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayref.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

#atscode_separator()

sortdef tk = tkind

#atscode_separator()

sortdef t0p = t@ype and vt0p = viewt@ype

#atscode_separator()
//
// arrayref: a reference to an array with no size information attached
//
#atscode_separator()

abstype
arrayref_viewt0ype_int_type
  (a: viewt@ype(*invariant*), n: int(*size*))
stadef arrayref = arrayref_viewt0ype_int_type
(*
stadef array = arrayref // HX: backward compatibility?
*)

#atscode_separator()

praxi
lemma_arrayref_param
  {a:vt0p}{n:int} (A: arrayref (a, n)): [n >= 0] void
// end of [lemma_arrayref_param]

#atscode_separator()

(*
** HX-2012-06:
** this function essentially passes the proof of array-view
** to GC (leaks it if GC is unavailable)
*)
castfn
arrayptr_refize
  {a:vt0p}
  {l:addr}
  {n:int} (
  A: arrayptr (INV(a), l, n)
) :<> arrayref (a, n) // end of [arrayptr_refize]

castfn
arrayref_get_viewptr
  {a:vt0p}
  {n:int} (
  A: arrayref (a, n)
) :<> [l:addr] (vbox (array_v (a, l, n)) | ptr l)

#atscode_separator()

fun{a:t0p}
arrayref_make_elt
  {n:int} (asz: size_t n, x: a):<!wrt> arrayref (a, n)
// end of [arrayref_make_elt]

fun{a:t0p}
arrayref_make_listlen
  {n:int}
  (xs: list (INV(a), n), n: int n):<!wrt> arrayref (a, n)
// end of [arrayref_make_listlen]

#atscode_separator()

fun{a:vt0p}
fprint_arrayref_sep
  {n:int} (
  out: FILEref
, A: arrayref (a, n), asz: size_t n, sep: NSH(string)
) : void // end of [fprint_arrayref_sep]

#atscode_separator()

fun{a:t0p}
arrayref_get_at_size
  {n:int} (
  A: arrayref (a, n), i: sizeLt (n)
) :<!ref> a // end of [arrayref_get_at_size]

fun{
a:t0p}{tk:tk
} arrayref_get_at_gint
  {n:int} (
  A: arrayref (a, n), i: g1intLt (tk, n)
) :<!ref> a // end of [arrayref_get_at_gint]
overload [] with arrayref_get_at_gint
fun{
a:t0p}{tk:tk
} arrayref_get_at_guint
  {n:int} (
  A: arrayref (a, n), i: g1uintLt (tk, n)
) :<!ref> a // end of [arrayref_get_at_guint]
overload [] with arrayref_get_at_guint

symintr arrayref_get_at
overload arrayref_get_at with arrayref_get_at_gint
overload arrayref_get_at with arrayref_get_at_guint

#atscode_separator()

fun{a:t0p}
arrayref_set_at_size
  {n:int} (
  A: arrayref (a, n), i: sizeLt (n), x: a
) :<!refwrt> void // end of [arrayref_set_at_size]

fun{
a:t0p}{tk:tk
} arrayref_set_at_gint
  {n:int} (
  A: arrayref (a, n), i: g1intLt (tk, n), x: a
) :<!refwrt> void // end of [arrayref_set_at_gint]
overload [] with arrayref_set_at_gint
fun{
a:t0p}{tk:tk
} arrayref_set_at_guint
  {n:int} (
  A: arrayref (a, n), i: g1uintLt (tk, n), x: a
) :<!refwrt> void // end of [arrayref_set_at_guint]
overload [] with arrayref_set_at_guint

symintr arrayref_set_at
overload arrayref_set_at with arrayref_set_at_gint
overload arrayref_set_at with arrayref_set_at_guint

#atscode_separator()

fun{a:vt0p}
arrayref_exch_at_size
  {n:int} (
  A: arrayref (a, n), i: sizeLt (n), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_size]

fun{
a:vt0p}{tk:tk
} arrayref_exch_at_gint
  {n:int} (
  A: arrayref (a, n), i: g1intLt (tk, n), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_gint]
fun{
a:vt0p}{tk:tk
} arrayref_exch_at_guint
  {n:int} (
  A: arrayref (a, n), i: g1uintLt (tk, n), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_guint]

symintr arrayref_exch_at
overload arrayref_exch_at with arrayref_exch_at_gint
overload arrayref_exch_at with arrayref_exch_at_guint

#atscode_separator()

(*
fun{a:vt0p}{env:vt0p}
array_foreach__fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_foreach {n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_foreach]
fun{
a:vt0p}{env:vt0p
} arrayref_foreach_env {n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_foreach_env]

#atscode_separator()
(*
fun{a:vt0p}{env:vt0p}
array_rforeach__fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_rforeach {n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_rforeach_env {n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_rforeach_env]

#atscode_separator()
//
// arrszref: a reference to an array with size information attached
//
#atscode_separator()

abstype
arrszref_viewt0ype_type
  (a: viewt@ype(*invariant*))
stadef arrszref = arrszref_viewt0ype_type
(*
stadef array0 = arrszref // HX: backward compatibility?
*)

#atscode_separator()

fun
arrszref_make{a:vt0p}{n:int}
  (A: arrayref (a, n), n: size_t n):<> arrszref (a)
// end of [arrszref_make]
fun
arrszref_get_refsize{a:vt0p}
  (A: arrszref (a), n: &size_t? >> size_t n):<!wrt> #[n:int] arrayref (a, n)
// end of [arrszref_get_refsize]

#atscode_separator()

fun{a:t0p}
arrszref_make_elt (asz: size_t, x: a):<!wrt> arrszref (a)
// end of [arrszref_make_elt]

fun{a:t0p}
arrszref_make_list (xs: List (INV(a))):<!wrt> arrszref (a)
// end of [arrszref_make_list]

#atscode_separator()

fun{a:vt0p}
fprint_arrszref_sep (
  out: FILEref, A: arrszref (a), sep: NSH(string)
) : void // end of [fprint_arrszref_sep]

macdef
fprint_arrszref
  (out, A) = fprint_arrszref_sep (,(out), ,(A), ", ")
// end of [fprint_arrszref]

#atscode_separator()

fun{a:t0p}
arrszref_get_at_size
  (A: arrszref (a), i: size_t):<!exnref> a
// end of [arrszref_get_at_size]

fun{
a:t0p}{tk:tk
} arrszref_get_at_gint
  (A: arrszref (a), i: g0int (tk)):<!exnref> a
overload [] with arrszref_get_at_gint
fun{
a:t0p}{tk:tk
} arrszref_get_at_guint
  (A: arrszref (a), i: g0uint (tk)):<!exnref> a
overload [] with arrszref_get_at_guint

symintr arrszref_get_at
overload arrszref_get_at with arrszref_get_at_gint
overload arrszref_get_at with arrszref_get_at_guint

#atscode_separator()

fun{a:t0p}
arrszref_set_at_size
  (A: arrszref (a), i: size_t, x: a):<!exnrefwrt> void
// end of [arrszref_set_at_size]

fun{
a:t0p}{tk:tk
} arrszref_set_at_gint
  (A: arrszref (a), i: g0int (tk), x: a):<!exnrefwrt> void
overload [] with arrszref_set_at_gint
fun{
a:t0p}{tk:tk
} arrszref_set_at_guint
  (A: arrszref (a), i: g0uint (tk), x: a):<!exnrefwrt> void
overload [] with arrszref_set_at_guint

symintr arrszref_set_at
overload arrszref_set_at with arrszref_set_at_gint
overload arrszref_set_at with arrszref_set_at_guint

#atscode_separator()

fun{a:vt0p}
arrszref_exch_at_size
  (A: arrszref (a), i: size_t, x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_size]

fun{
a:vt0p}{tk:tk
} arrszref_exch_at_gint
  (A: arrszref (a), i: g0int (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_gint]
fun{
a:vt0p}{tk:tk
} arrszref_exch_at_guint
  (A: arrszref (a), i: g0uint (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_guint]

symintr arrszref_exch_at
overload arrszref_exch_at with arrszref_exch_at_gint
overload arrszref_exch_at with arrszref_exch_at_guint

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "arrayref_atxt.txt")
%}\
