%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"arrayref.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayref.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

\#define SHR(x) x // SHARED // HX: for commenting
\#define NSH(x) x // NSHARED // HX: for commenting

#atscode_separator()

sortdef t0p = t@ype and vt0p = viewt@ype

#atscode_separator()
//
// arrayref: a reference to an array with no size information attached
//
#atscode_separator()

abstype
arrayref_viewt0ype_int_type
  (a: viewt@ype(*invariant*), n: int(*size*))
stadef arrayref = arrayref_viewt0ype_int_type
(*
stadef array = arrayref // HX: backward compatibility?
*)

#atscode_separator()

praxi
lemma_arrayref_param
  {a:vt0p}{n:int} (A: arrayref (INV(a), n)): [n >= 0] void
// end of [lemma_arrayref_param]

#atscode_separator()

(*
** HX-2012-06:
** this function essentially passes the proof of array-view
** to GC (leaks it if GC is unavailable)
*)
castfn
arrayptr2ref
  {a:vt0p}
  {l:addr}
  {n:int} (
  A: arrayptr (INV(a), l, n)
) :<> arrayref (a, n) // end of [arrayptr2ref]

castfn
arrayref_get_viewptr
  {a:vt0p}
  {n:int} (
  A: arrayref (INV(a), n)
) :<> [l:addr] (vbox (array_v (a, l, n)) | ptr l)

#atscode_separator()

fun{a:t0p}
arrayref_make_elt
  {n:int} (asz: size_t n, x: a):<> arrayref (a, n)
// end of [arrayref_make_elt]

fun{a:t0p}
arrayref_make_listlen
  {n:int} (xs: list (INV(a), n), n: int n):<> arrayref (a, n)
// end of [arrayref_make_listlen]

#atscode_separator()

fun{a:t0p}
arrayref_get_at
  {n:int}{i:nat | i < n}
  (A: arrayref (INV(a), n), i: size_t i):<!ref> a
overload [] with arrayref_get_at
fun{a:t0p}
arrayref_set_at
  {n:int}{i:nat | i < n}
  (A: arrayref (INV(a), n), i: size_t i, x: a):<!refwrt> void
overload [] with arrayref_set_at

fun{
a:vt0p
} arrayref_exch_at
  {n:int}{i:nat | i < n}
  (A: arrayref (INV(a), n), i: size_t i, x: &a >> a):<!refwrt> void
// end of [arrayref_exch_at]

#atscode_separator()

(*
fun{a:vt0p}{env:vt0p}
array_foreach__fwork (x: &a >> a, env: &env): void
*)
fun{
a:vt0p
} arrayref_foreach {n:int} (
  A: arrayref (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_foreach]
fun{
a:vt0p}{env:vt0p
} arrayref_foreach_env {n:int} (
  A: arrayref (INV(a), n), asz: size_t (n), env: &INV(env) >> env
) : sizeLte(n) // end of [arrayref_foreach_env]

#atscode_separator()
(*
fun{a:vt0p}{env:vt0p}
array_rforeach__fwork (x: &a >> a, env: &env): void
*)
fun{
a:vt0p
} arrayref_rforeach {n:int} (
  A: arrayref (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_rforeach_env {n:int} (
  A: arrayref (INV(a), n), asz: size_t (n), env: &INV(env) >> env
) : sizeLte(n) // end of [arrayref_rforeach_env]

#atscode_separator()
//
// arrszref: a reference to an array with size information attached
//
#atscode_separator()

abstype
arrszref_viewt0ype_type
  (a: viewt@ype(*invariant*))
stadef arrszref = arrszref_viewt0ype_type
(*
stadef array0 = arrszref // HX: backward compatibility?
*)

#atscode_separator()

fun
arrszref_make{a:vt0p}{n:int}
  (A: arrayref (INV(a), n), n: size_t n):<> arrszref (a)
// end of [arrszref_make]
fun
arrszref_get_refsize{a:vt0p}
  (A: arrszref (INV(a)), n: &size_t? >> size_t n):<!wrt> #[n:int] arrayref (a, n)
// end of [arrszref_get_refsize]

#atscode_separator()

fun{a:t0p}
arrszref_make_elt (asz: size_t, x: a):<> arrszref (a)
// end of [arrszref_make_elt]

fun{a:t0p}
arrszref_make_list (xs: List (INV(a))):<> arrszref (a)
// end of [arrszref_make_list]

#atscode_separator()

fun{a:vt0p}
fprint_arrszref_sep (
  out: FILEref, A: arrszref (a), sep: NSH(string)
) : void // end of [fprint_arrszref_sep]

macdef
fprint_arrszref
  (out, A) = fprint_arrszref_sep (,(out), ,(A), ", ")
// end of [fprint_arrszref]

#atscode_separator()

fun{a:t0p}
arrszref_get_at
  (A: arrszref (INV(a)), i: size_t):<!exnref> a
overload [] with arrszref_get_at
fun{a:t0p}
arrszref_set_at
  (A: arrszref (INV(a)), i: size_t, x: a):<!exnrefwrt> void
overload [] with arrszref_set_at

#atscode_separator()

fun{
a:vt0p
} arrszref_exch_at
  (A: arrszref (INV(a)), i: size_t, x: &a >> a):<!exnrefwrt> void
// end of [arrszref_exch_at]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "arrayref_atxt.txt")
%}\
