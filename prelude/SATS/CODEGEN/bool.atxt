%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"bool.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/bool.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("September, 2011")

#atscode_separator()

castfn bool1_of_bool0 (x: bool):<> Bool

#atscode_separator()

fun int2bool0 (i: int):<> bool
fun bool2int0 (b: bool):<> natLt(2) // that is, Two

fun int2bool1 {i:int} (i: int i):<> bool (i != 0)
fun bool2int1 {b:bool} (b: bool b):<> int (int_of_bool b)

#atscode_separator()

(*
//
// HX: declared in [prelude/basics_dyn.sats]
//
val true : bool (true) and false : bool (false)
*)

#atscode_separator()

(*
** HX-2012-06:
** shortcut version of disjuction and conjuction
** note that these two cannot be declared as functions
*)
macdef || (b1, b2) = (if b1 then true else b2): bool
macdef && (b1, b2) = (if b1 then b2 else false): bool

#atscode_separator()

fun neg_bool0
  (b: bool):<> bool = "mac\#atspre_neg_bool"
overload ~ with neg_bool0 of 0
overload not with neg_bool0 of 0

#atscode_separator()

fun add_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac\#atspre_add_bool_bool"
overload + with add_bool0_bool0 of 0
fun mul_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac\#atspre_mul_bool_bool"
overload * with mul_bool0_bool0 of 0

#atscode_separator()

%{
fun
fun_bool_cmp0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_bool0_bool0
  (b1: bool, b2: bool):<> bool = \"mac#atspre_%s_bool_bool\"
overload %s with %s_bool0_bool0 of 0\
", @(
 opr, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_bool_cmp0_decl]
%}\
\
#fun_bool_cmp0_decl("lt")
#fun_bool_cmp0_decl("lte")

#fun_bool_cmp0_decl("gt")
#fun_bool_cmp0_decl("gte")

#fun_bool_cmp0_decl("eq")
#fun_bool_cmp0_decl("neq")
overload <> with neq_bool0_bool0 of 0

fun compare_bool0_bool0 // HX: this one is a function
  (b1: bool, b2: bool):<> Sgn = "atspre_compare_bool_bool"
overload compare with compare_bool0_bool0

#atscode_separator()

fun fprint_bool
  (out: FILEref, x: bool): void = "atspre_fprint_bool"
overload fprint with fprint_bool
fun print_bool (x: bool): void = "mac\#atspre_fprint_bool"
and prerr_bool (x: bool): void = "mac\#atspre_fprint_bool"
overload print with print_bool
overload prerr with prerr_bool

#atscode_separator()
//
// HX: the return is statically allocated
//
fun tostring_bool
  (b: bool):<> string = "atspre_tostring_bool"
overload tostring with tostring_bool

#atscode_separator()

fun neg_bool1 {b:bool}
  (b: bool b):<> bool (~b) = "mac\#atspre_neg_bool1"
overload ~ with neg_bool1 of 10
overload not with neg_bool1 of 10

#atscode_separator()

fun add_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> [b:bool | b1 <= b] bool (b)
  = "mac\#atspre_add_bool1_bool0"
overload + with add_bool1_bool0 of 10

fun add_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> [b:bool | b2 <= b] bool (b)
  = "mac\#atspre_add_bool0_bool1"
overload + with add_bool0_bool1 of 10

fun add_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 || b2)
  = "mac\#atspre_add_bool1_bool1"
overload + with add_bool1_bool1 of 20

#atscode_separator()

fun mul_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> [b:bool | b <= b1] bool (b)
  = "mac\#atspre_mul_bool1_bool0"
overload * with mul_bool1_bool0 of 10

fun mul_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> [b:bool | b <= b2] bool (b)
  = "mac\#atspre_mul_bool0_bool1"
overload * with mul_bool0_bool1 of 10

fun mul_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 && b2)
  = "mac\#atspre_mul_bool1_bool1"
overload * with mul_bool1_bool1 of 20

#atscode_separator()

%{
fun
fun_bool_cmp1_decl (
  opr: string
) : atext = let
//
val fopr_s = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "==" | "neq" => "!="
  | _ => opr
) : string // end of [val]
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_bool1_bool1
  {b1,b2:bool} (
  b1: bool (b1), b2: bool (b2)
) :<> bool (b1 %s b2) = \"mac#atspre_%s_bool1_bool1\"
overload %s with %s_bool1_bool1 of 20\
", @(
 opr, fopr_s, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_bool_cmp1_decl]
%}\
\
//
// (b1 < b2) == (~b1 && b2)
//
#fun_bool_cmp1_decl("lt")
//
// (b1 <= b2) == (~b1 || b2)
//
#fun_bool_cmp1_decl("lte")

//
// (b1 > b2) == (b1 && ~b2)
//
#fun_bool_cmp1_decl("gt")
//
// (b1 >= b2) == (b1 || ~b2)
//
#fun_bool_cmp1_decl("gte")

#fun_bool_cmp1_decl("eq")
#fun_bool_cmp1_decl("neq")
overload <> with neq_bool1_bool1 of 20

fun compare_bool1_bool1
  {b1,b2:bool} // HX: this one is a function
  (b1: bool b1, b2: bool b2):<> int (int_of_bool b1 - int_of_bool b2)
  = "atspre_compare_bool1_bool1"
overload compare with compare_bool1_bool1 of 20

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "bool_atxt.txt")
%}\
