%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT=="txt")
#include "utils/atsdoc/HATS/postiatsatxt_txt.hats"
#elif (ATSCODEFORMAT=="xml")
#include "utils/atsdoc/HATS/postiatsatxt_xml.hats"
#elif (ATSCODEFORMAT=="tex")
#include "utils/atsdoc/HATS/postiatsatxt_tex.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"array.sats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()
\
#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/array.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("September, 2011")

#atscode_separator()

#atscode_decl_strcst('\
castfn bool1_of_bool (x: bool):<> Bool
castfn bool1_of_bool0 (x: bool):<> Bool
')\

#atscode_separator()

#atscode_decl_strcst('\
fun bool_of_int (i: int):<> bool
fun int_of_bool (b: bool):<> natLt(2) // that is, Two
')\

#atscode_decl_strcst('\
fun bool1_of_int1 {i:int} (i: int i):<> bool (i != 0)
fun int1_of_bool1 {b:bool} (b: bool b):<> int (int_of_bool b)
')\

#atscode_separator()

#atscode_decl_strcst('\
fun neg_bool
  (b: bool):<> bool = "mac\#atspre_neg_bool"
overload ~ with neg_bool of 0
overload not with neg_bool of 0
')\

#atscode_decl_strcst('\
fun add_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_add_bool_bool"
overload + with add_bool_bool of 0
overload || with add_bool_bool of 0
')\

#atscode_decl_strcst('\
fun mul_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_mul_bool_bool"
overload * with mul_bool_bool of 0
overload && with mul_bool_bool of 0
')\

#atscode_separator()

#atscode_decl_strcst('\
fun lt_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_lt_bool_bool"
and lte_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_lte_bool_bool"
overload < with lt_bool_bool of 0
overload <= with lte_bool_bool of 0
')\

#atscode_decl_strcst('\
fun gt_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_gt_bool_bool"
and gte_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_gte_bool_bool"
overload > with gt_bool_bool of 0
overload >= with gte_bool_bool of 0
')\

#atscode_decl_strcst('\
fun eq_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_eq_bool_bool"
and neq_bool_bool
  (b1: bool, b2: bool):<> bool = "mac\#atspre_neq_bool_bool"
overload = with eq_bool_bool of 0
overload <> with neq_bool_bool of 0
overload != with neq_bool_bool of 0
')\

#atscode_decl_strcst('\
fun compare_bool_bool // HX: this one is a function
  (b1: bool, b2: bool):<> Sgn = "atspre_compare_bool_bool"
overload compare with compare_bool_bool
')\

#atscode_separator()

#atscode_decl_strcst('\
fun fprint_bool
  (out: FILEref, x: bool): void
overload fprint with fprint_bool
')\

#atscode_decl_strcst('\
fun print_bool (x: bool): void
and prerr_bool (x: bool): void
overload print with print_bool
overload prerr with prerr_bool
')\

#atscode_separator()
#atscode_decl_strcst('\
//
// HX: the return is statically allocated
//
fun tostring_bool
  (b: bool):<> string = "atspre_tostring_bool"
overload tostring with tostring_bool
')\

#atscode_separator()

#atscode_decl_strcst('\
fun neg_bool1 {b:bool}
  (b: bool b):<> bool (~b) = "mac\#atspre_neg_bool1"
overload ~ with neg_bool1 of 1
overload not with neg_bool1 of 1
')\

#atscode_separator()

#atscode_decl_strcst('\
fun add_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> [b:bool | b1 <= b] bool (b)
  = "mac\#atspre_add_bool1_bool0"
overload + with add_bool1_bool0 of 1
overload || with add_bool1_bool0 of 1
')\

#atscode_decl_strcst('\
fun add_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> [b:bool | b2 <= b] bool (b)
  = "mac\#atspre_add_bool0_bool1"
overload + with add_bool0_bool1 of 1
overload || with add_bool0_bool1 of 1
')\

#atscode_decl_strcst('\
fun add_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 || b2)
  = "mac\#atspre_add_bool1_bool1"
overload + with add_bool1_bool1 of 2
overload || with add_bool1_bool1 of 2
')\

#atscode_separator()

#atscode_decl_strcst('\
fun mul_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> [b:bool | b <= b1] bool (b)
  = "mac\#atspre_mul_bool1_bool0"
overload * with mul_bool1_bool0 of 1
overload && with mul_bool1_bool0 of 1
')\

#atscode_decl_strcst('\
fun mul_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> [b:bool | b <= b2] bool (b)
  = "mac\#atspre_mul_bool0_bool1"
overload * with mul_bool0_bool1 of 1
overload && with mul_bool0_bool1 of 1
')\

#atscode_decl_strcst('\
fun mul_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 && b2)
  = "mac\#atspre_mul_bool1_bool1"
overload * with mul_bool1_bool1 of 2
overload && with mul_bool1_bool1 of 2
')\

#atscode_separator()

#atscode_decl_strcst('\
fun lt_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 < b2) // ~b1 && b2
  = "mac\#atspre_lt_bool1_bool1"
and lte_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 <= b2) // ~b1 || b2
  = "mac\#atspre_lte_bool1_bool1"
overload < with lt_bool1_bool1 of 2
overload <= with lte_bool1_bool1 of 2
')\

#atscode_decl_strcst('\
fun gt_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 > b2) // b1 && ~b2
  = "mac\#atspre_gt_bool1_bool1"
and gte_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 >= b2) // b1 || ~b2
  = "mac\#atspre_gte_bool1_bool1"
overload > with gt_bool1_bool1 of 2
overload >= with gte_bool1_bool1 of 2
')\

#atscode_decl_strcst('\
fun eq_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 == b2)
  = "mac\#atspre_eq_bool1_bool1"
and neq_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 <> b2)
  = "mac\#atspre_neq_bool1_bool1"
overload = with eq_bool1_bool1 of 2
overload <> with neq_bool1_bool1 of 2
overload != with neq_bool1_bool1 of 2
')\

#atscode_separator()

#atscode_decl_strcst('\
fun compare_bool1_bool1
  {b1,b2:bool} // HX: this one is a function
  (b1: bool b1, b2: bool b2):<> int (int_of_bool b1 - int_of_bool b2)
  = "atspre_compare_bool1_bool1"
overload compare with compare_bool1_bool1 of 2
')\

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "array_atxt.txt")
%}\
