%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"list.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/list.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

#atscode_decl_strcst("sortdef t0p = t@ype")

#atscode_separator()

\#define SHR(x) x // SHARED // HX: for commenting
\#define NSH(x) x // NSHARED // HX: for commenting

#atscode_separator()

exception ListSubscriptExn of ()

#atscode_separator()

prfun
lemma_list_param
  {x:t0p}{n:int} (xs: list (x, n)): [n >= 0] void
// end of [lemma_list_param]

#atscode_separator()

castfn
list_of_list_vt
  {a:t0p}{n:int} (xs: list_vt (a, n)):<> list (a, n)
// end of [list_of_list_vt]

#atscode_separator()

\#define list_sing(x) list_cons(x, list_nil())
\#define list_pair(x) list_cons(x1, list_cons (x2, list_nil()))

#atscode_separator()

fun{}
list_is_nil {x:t0p}{n:int} (xs: list (x, n)):<> bool (n==0)
fun{}
list_is_cons {x:t0p}{n:int} (xs: list (x, n)):<> bool (n > 0)
fun{}
list_is_sing {x:t0p}{n:int} (xs: list (x, n)):<> bool (n==1)
fun{}
list_is_pair {x:t0p}{n:int} (xs: list (x, n)):<> bool (n==2)

#atscode_separator()

fun{a:t0p}
list_head {n:pos} (xs: list (a, n)):<> a
fun{a:t0p}
list_tail {n:pos} (xs: list (a, n)):<> list (a, n-1)

#atscode_separator()

fun{x:t0p}
list_length {n:int} (xs: list (x, n)):<> int (n)

#atscode_separator()

fun{
x:t0p // type for elements
} list_copy
  {n:int} (xs: list (INV(x), n)):<> list_vt (x, n)
// end of [list_copy]

#atscode_separator()

fun{a:t0p}
list_append {m,n:int} (
  xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))
) :<> list (a, m+n) // end of [list_append]

fun{
a:t0p // type for elements
} list_append1_vt {i,j:int} (
  xs: list_vt (INV(a), i), ys: SHR(list (a, j))
) :<!wrt> list (a, i+j) // endfun
fun{
a:t0p // type for elements
} list_append2_vt {i,j:int} (
  xs: NSH(list (INV(a), i)), ys: list_vt (a, j)
) :<!wrt> list_vt (a, i+j) // endfun

#atscode_separator()

fun{
a:t0p
} list_extend {n:int}
  (xs: NSH (list (INV(a), n)), x: a):<> list_vt (a, n+1)
// end of [list_extend]

macdef list_snoc = list_extend

#atscode_separator()

fun{x:t0p}
list_reverse
  {n:int} (xs: NSH(list (INV(x), n))):<> list_vt (x, n)
// end of [list_reverse]

#atscode_separator()

fun{a:t0p}
list_reverse_append {m,n:int}
  (xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))):<> list (a, m+n)
// end of [list_reverse_append]

fun{a:t0p}
list_reverse_append1_vt {m,n:int}
  (xs: list_vt (INV(a), m), ys: SHR(list (a, n))):<!wrt> list (a, m+n)
// end of [list_reverse_append1_vt]
fun{a:t0p}
list_reverse_append2_vt {m,n:int}
  (xs: NSH(list (INV(a), m)), ys: list_vt (a, n)):<!wrt> list_vt (a, m+n)
// end of [list_reverse_append2_vt]

#atscode_separator()

fun{a:t0p}
list_concat (xss: NSH(List (List (INV(a))))):<> List0_vt (a)

#atscode_separator()

fun{
a:t0p
} list_take
  {n:int}{i:nat | i <= n}
  (xs: list (INV(a), n), i: int i):<> list_vt (a, i)
// end of [list_take]

fun{
a:t@ype
} list_take_exn
  {n:int}{i:nat}
  (xs: list (INV(a), n), i: int i):<!exn> [i <= n] list_vt (a, i)
// end of [list_take_exn]

#atscode_separator()

fun{
a:t0p
} list_drop
  {n:int}{i:nat | i <= n}
  (xs: list (INV(a), n), i: int i):<> list (a, n-i)
// end of [list_drop]

(*
** HX: it may raise [ListSubscriptException]
*)
fun{
a:t0p
} list_drop_exn
  {n:int}{i:nat}
  (xs: list (INV(a), n), i: int i):<!exn> [i <= n] list (a, n-i)
// end of [list_drop_exn]

#atscode_separator()

fun{x:t0p}
list_make_elt
  {n:nat} (n: int n, x: x):<> list_vt (x, n)
// end of [list_make_elt]

#atscode_separator()

fun list_make_intrange
  {l,r:int | l <= r}
  (l: int l, r: int r):<> list_vt (intBtw (l, r), r-l)
// end of [list_make_intrange]

#atscode_separator()

symintr list
fun{a:vt0p}
list_make_arrpsz
  {n:int} (psz: arrpsz (INV(a), n)):<> list_vt (a, n)
overload list with list_make_arrpsz

#atscode_separator()

fun{x:t0p} list_exists__pred (x):<> bool
fun{x:t0p} list_exists (xs: NSH(List (x))):<> bool

fun{x:t0p} list_forall__pred (x):<> bool
fun{x:t0p} list_forall (xs: NSH(List (x))):<> bool

#atscode_separator()

fun{x:t0p} list_find__pred (x):<> bool
fun{x:t0p} list_find_exn (xs: NSH(List (x))):<!exn> x
fun{x:t0p} list_find_opt (xs: NSH(List (x))):<> Option_vt (x)

#atscode_separator()

fun{
x:t0p // type for elements
} list_foreach__fwork (x): void
fun{x:t0p}
list_foreach {n:int} (xs: NSH(list (x, n))): void

fun{
x:t0p // type for elements
} list_foreach_funenv
  {v:view}{env:viewtype}{fe:eff} (
  pfv: !v |
  xs: NSH(List (INV(x)))
, f: (!v | x, !env) -<fun,fe> void, env: !env
) :<fe> void // end of [list_foreach_funenv]

#atscode_separator()

fun{
x,y:t0p // type for elements
} list_foreach2__fwork (x, y): void
fun{x,y:t0p}
list_foreach2 {m,n:int} (xs: NSH(list (x, m)), NSH(list (y, n))): void

#atscode_separator()

fun{
x:t0p // type for elements
} list_iforeach__fwork (i: int, x: x): void
fun{x:t0p}
list_iforeach {n:int} (xs: NSH(list (x, n))): void

fun{
x:t0p // type for elements
} list_iforeach_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: NSH(list (INV(x), n))
, f: (!v | natLt(n), x, !vt) -<fun,fe> void, env: !vt
) :<fe> int n // end of [list_iforeach_funenv]

#atscode_separator()

fun{
x,y:t0p // type for elements
} list_iforeach2__fwork (int, x, y): void
fun{x,y:t0p}
list_iforeach2 {m,n:int} (xs: NSH(list (x, m)), NSH(list (y, n))): void

#atscode_separator()

fun{
res:vt0p}{x:t0p
} list_foldleft__fwork (acc: res, x: x): res
fun{
res:vt0p}{x:t0p
} list_foldleft (xs: NSH(List (x)), ini: res): res

fun{
x:t0p}{res:vt0p
} list_foldright__fwork (x: x, acc: res): res
fun{
x:t0p}{res:vt0p
} list_foldright (xs: NSH(List (x)), snk: res): res

#atscode_separator()

fun{
x:t0p
} list_labelize
  {n:int} (xs: NSH(list (INV(x), n))):<> list_vt (@(int, x), n)
// end of [list_labelize]

#atscode_separator()

fun{
x:t0p}{y:vt0p
} list_filter__pred (x): bool
fun{
x:t0p
} list_filter {n:int}
  (xs: NSH(list (INV(x), n))): listLte_vt (x, n)
// end of [list_filter]

fun{
x:t0p
} list_filter_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: NSH(list (INV(x), n))
, f: (!v | x, !vt) -<fun,fe> bool, env: !vt
) :<fe> listLte_vt (x, n) // end of [list_filter_funenv]

#atscode_separator()

fun{
x:t0p}{y:vt0p
} list_map__fwork (x): y
fun{
x:t0p}{y:vt0p
} list_map {n:int}
  (xs: NSH(list (INV(x), n))): list_vt (y, n)
// end of [list_map]

fun{
x:t0p}{y:t0p
} list_map_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: NSH(list (INV(x), n))
, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe> list_vt (y, n) // end of [list_map_funenv]

#atscode_separator()

fun{
x:t0p}{y:vt0p
} list_imap__fwork (int, x): y
fun{
x:t0p}{y:vt0p
} list_imap {n:int}
  (xs: NSH(list (INV(x), n))): list_vt (y, n)
// end of [list_imap]

#atscode_separator()

fun{
x1,x2:t0p}{y:vt0p
} list_map2__fwork (x1, x2): y
fun{
x1,x2:t0p}{y:vt0p
} list_map2 {n1,n2:int} (
  xs1: NSH(list (INV(x1), n1))
, xs2: NSH(list (INV(x2), n2))
) : list_vt (y, min(n1,n2)) // end of [list_map2]

fun{
x1,x2:t0p}{y:t0p
} list_map2_funenv
  {v:view}{vt:viewtype}{n1,n2:int}{fe:eff} (
  pfv: !v |
  xs1: NSH(list (INV(x1), n1))
, xs2: NSH(list (INV(x2), n2))
, f: (!v | x1, x2, !vt) -<fun,fe> y, env: !vt
) :<fe> list_vt (y, min(n1,n2)) // end of [list_map2_funenv]

#atscode_separator()

fun{
x:t0p}{y:vt0p
} list_mapopt__fwork (x): Option_vt (y)
fun{
x:t0p}{y:vt0p
} list_mapopt {n:int}
  (xs: NSH(list (INV(x), n))): listLte_vt (y, n)
// end of [list_mapopt]

fun{
x:t0p}{y:t0p
} list_mapopt_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: NSH(list (INV(x), n))
, f: (!v | x, !vt) -<fun,fe> Option_vt (y), env: !vt
) :<fe> listLte_vt (y, n) // end of [list_mapopt_funenv]

#atscode_separator()

fun{
a:vt0p
} list_tabulate__fwork (i: int): a
fun{
a:vt0p
} list_tabulate {n:nat} (n: int n): list_vt (a, n)

#atscode_separator()

fun{
x,y:t0p
} list_zip {m,n:int} (
  xs: NSH(list (INV(x), m)), ys: NSH(list (INV(y), n))
) :<> list_vt ((x, y), min(m,n)) // end of [list_zip]

#atscode_separator()

macdef list_zipwith = list_map2

#atscode_separator()

fun{a:t0p}
list_mergesort__cmp (x1: a, x2: a):<> int

fun{
a:t0p
} list_mergesort
  {n:int} (
  xs: NSH(list (INV(a), n))
) :<> list_vt (a, n) // end of [list_mergesort]

fun{
a:t0p
} list_mergesort_fun
  {n:int} (
  xs: NSH(list (INV(a), n)), cmp: cmpval (a)
) :<> list_vt (a, n) // end of [list_mergesort_fun]

#atscode_separator()

fun{a:t0p}
list_quicksort__cmp (x1: a, x2: a):<> int

fun{
a:t0p
} list_quicksort
  {n:int} (
  xs: NSH(list (INV(a), n))
) :<> list_vt (a, n) // end of [list_quicksort]

fun{
a:t0p
} list_quicksort_fun
  {n:int} (
  xs: NSH(list (INV(a), n)), cmp: cmpval (a)
) :<> list_vt (a, n) // end of [list_quicksort_fun]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "list_atxt.txt")
%}\
