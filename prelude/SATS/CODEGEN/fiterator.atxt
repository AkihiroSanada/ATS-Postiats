%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"fiterator.sats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/fiterator.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

sortdef t0p = t@ype
sortdef vtp = viewtype

#atscode_separator()

absviewtype
fiterator ( // HX: boxed
  xs: t@ype, x: t@ype+, f: int, r: int
) // end of [absviewtype]

prfun lemma_iterator_param
  {xs:t0p}{x:t0p}{f,r:int}
  (iter: !fiterator (xs, x, f, r)): [f>=0;r>=0] void
// end of [lemma_iterator_param]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_make (xs: xs):<> [r:nat] fiterator (xs, x, 0, r)

fun{
xs:t0p}{x:t0p
} iter_free {f,r:int} (iter: fiterator (xs, x, f, r)):<> void

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_is_atend {f,r:int}
  (iter: !fiterator (xs, x, f, r)):<> bool (r==0)
// end of [iter_is_atend]

fun{
xs:t0p}{x:t0p
} iter_isnot_atend {f,r:int}
  (iter: !fiterator (xs, x, f, r)):<> bool (r > 0)
// end of [iter_isnot_atend]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_get_at
  {f,r:int | r > 0} (iter: !fiterator (xs, x, f, r)):<> x
// end of [iter_get_at]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_getinc_at
  {f,r:int | r > 0} (
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f+1, r-1)
) :<> x // end of [iter_getinc_at]

fun{
xs:t0p}{x:t0p
} iter_getdec_at
  {f,r:int | f > 0; r > 0} (
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f-1, r+1)
) :<> x // end of [iter_getdec_at]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_inc {f,r:int | r > 0} (
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f+1, r-1)
) :<> void // end of [iter_inc]

fun{
xs:t0p}{x:t0p
} iter_dec {f,r:int | f > 0} (
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f-1, r+1)
) :<> void // end of [iter_dec]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_foreach_funenv
  {v:view}{vt:vtp}{f,r:int}{fe:eff} (
  pfv: !v
| iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f+r, 0)
, f: (!v | x, !vt) -<fe> void, env: !vt
) :<fe> void // end of [iter_foreach_funenv]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_exists_funenv
  {v:view}{vt:vtp}{f,r:int}{fe:eff} (
  pfv: !v
| iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f1, r1)
, pred: (!v | x, !vt) -<fe> bool, env: !vt
) :<fe> #[
  f1,r1:int | f1>=f; f+r==f1+r1
] bool (r1 > 0) // end of [iter_exists_funenv]

#atscode_separator()

fun{
xs:t0p}{x:t0p
} iter_jump {f,r:int}{i:nat | i <= r} (
//
// HX: O(log(n))-time complexity is expected
//
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f+i, r-i)
) :<> void // end of [iter_jump]

#atscode_separator()

(*
** HX-2012-05:
** [iter] should support at least log-time random-access
*)
fun{
xs:t0p}{x:t0p
} iter_bsearch_funenv
  {env:vtp}{f,r:int} (
  iter: !fiterator (xs, x, f, r) >> fiterator (xs, x, f1, r1)
, cmp: (x, x, !env) -<fun> int, env: !env
) :<> #[
  f1,r1:int | f1>=f;f1+r1==f+r
] bool(*found*) // end of [iter_bsearch_funenv]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "fiterator_atxt.txt")
%}\
