%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"lazy_vt.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/lazy_vt.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

sortdef t0p = t@ype and vt0p = viewt@ype

#atscode_separator()
//
// HX: [lazy_vt(VT)] :
// suspended computation of a linear value of viewtype VT
//
absviewtype
lazy_viewt0ype_viewtype
  (a:viewt@ype+) // boxed linear type // unnamed
stadef lazy_vt = lazy_viewt0ype_viewtype
//
#atscode_separator()

fun{a:vt0p}
lazy_vt_free (x: lazy_vt (a)):<!wrt> void
overload ~ with lazy_vt_free

#atscode_separator()
//
// HX: lazy linear streams
//
dataviewtype
stream_vt_con (a:viewt@ype+) =
  | stream_vt_cons (a) of (a, stream_vt a) | stream_vt_nil (a) of ()
where stream_vt (a:viewt@ype) = lazy_vt (stream_vt_con a)
//
#atscode_separator()

fun{a:vt0p}
stream2list_vt
  (xs: stream_vt (INV(a))): List0_vt (a)
// end of [stream2list_vt]

#atscode_separator()

fun{a:t0p}
stream_vt_free (xs: stream_vt a):<!wrt> void

#atscode_separator()

fun{
env:vt0p
} stream_vt_foreach__cont (env: &env): bool
fun{
a:vt0p}{env:vt0p
} stream_vt_foreach__fwork
  (x: &a >> a?!, env: &env): void // lin-cleared
fun{a:vt0p}
stream_vt_foreach (xs: stream_vt (a)): void
fun{
a:vt0p}{env:vt0p
} stream_vt_foreach_env (xs: stream_vt (a), &env): void

#atscode_separator()
//
fun{a:vt0p}
stream_vt_filter__pred
  (x: &a >> opt(a, b)): #[b:bool] bool (b)
fun{a:t0p}
stream_vt_filter (xs: stream_vt (INV(a))): stream_vt (a)
//
fun{a:t0p}
stream_vt_filter_fun (
  xs: stream_vt (INV(a)), pred: (&a) -<fun> bool
) :<> stream_vt (a) // end of [stream_vt_filter_fun]
fun{a:t0p}
stream_vt_filter_cloptr (
  xs: stream_vt (INV(a)), pred: (&a) -<cloptr> bool
) :<> stream_vt (a) // end of [stream_vt_filter_cloptr]
//
fun{a:vt0p}
stream_vt_filterlin__clear (x: &a >> a?):<!wrt> void
fun{a:vt0p}
stream_vt_filterlin (xs: stream_vt (INV(a))): stream_vt (a)
//
#atscode_separator()
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map__fwork (x: &a >> a?!): b // lin-cleared
fun{
a:vt0p}{b:vt0p
} stream_vt_map (xs: stream_vt (INV(a))): stream_vt (b)
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map_fun
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<fun> b): stream_vt (b)
fun{
a:vt0p}{b:vt0p
} stream_vt_map_cloptr
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<cloptr> b): stream_vt (b)
//
#atscode_separator()
//
fun{
a1,a2:vt0p}{b:vt0p
} stream_vt_map2__fwork
  (x1: &a1 >> a1?!, x2: &a2 >> a2?!): b
fun{
a1,a2:vt0p}{b:vt0p
} stream_vt_map2 (
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
) : stream_vt (b) // end of [stream_vt_map2]
//
fun{
a1,a2:vt0p}{b:vt0p
} stream_vt_map2_fun (
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> a1?!, &a2 >> a2?!) -<fun> b
) : stream_vt (b) // end of [stream_vt_map2_fun]
fun{
a1,a2:vt0p}{b:vt0p
} stream_vt_map2_cloptr (
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> a1?!, &a2 >> a2?!) -<cloptr> b
) : stream_vt (b) // end of [stream_vt_map2_cloptr]
//
#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "lazy_vt_atxt.txt")
%}\
