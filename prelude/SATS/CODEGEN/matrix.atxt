%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"matrix.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrix.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("Feburary, 2012")

#atscode_separator()

vtypedef
RD(a:vt0p) = a // for commenting: read-only
\#define NSH (x) x // for commenting: no sharing
\#define SHR (x) x // for commenting: it is shared

#atscode_separator()

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

#atscode_separator()

absviewt@ype
matrix_viewt0ype_int_int_viewt0ype
  (a:viewt@ype+, row:int, col:int) = array(a, row*col)
stadef matrix = matrix_viewt0ype_int_int_viewt0ype

viewdef
matrix_v (
  a:viewt@ype+, l:addr, row:int, col:int
) = matrix (a, row, col) @ l

praxi matrix2array_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: matrix_v (INV(a), l, m, n)): array_v (a, l, m*n)
praxi array2matrix_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (INV(a), l, m*n)): matrix_v (a, l, m, n)

#atscode_separator()
//
// HX: ATS matrices is of row-major style
//
absview
matrow_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matrow_v = matrow_view
absview
matcol_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matcol_v = matcol_view
//
#atscode_separator()

symintr matrix_getref_at

fun{a:vt0p}
matrix_getref_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> cPtr1 (a) // endfun

fun{a:vt0p}
matrix_getref_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> cPtr1 (a) // endfun

overload matrix_getref_at with matrix_getref_at_int
overload matrix_getref_at with matrix_getref_at_size

#atscode_separator()

fun{a:t0p}
matrix_get_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> (a) // end of [matrix_get_at_int]

fun{a:t0p}
matrix_get_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> (a) // end of [matrix_get_at_size]

overload [] with matrix_get_at_int
overload [] with matrix_get_at_size

#atscode_separator()

fun{a:t0p}
matrix_set_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: a
) :<!wrt> void // end of [matrix_set_at_int]

fun{a:t0p}
matrix_set_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!wrt> void // end of [matrix_set_at_size]

overload [] with matrix_set_at_int
overload [] with matrix_set_at_size

#atscode_separator()

symintr matrix_exch_at

fun{a:vt0p}
matrix_exch_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a>>a
) :<!wrt> void // end of [matrix_exch_at_int]

fun{a:vt0p}
matrix_exch_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a>>a
) :<!wrt> void // end of [matrix_exch_at_size]

overload matrix_exch_at with matrix_exch_at_int
overload matrix_exch_at with matrix_exch_at_size

#atscode_separator()

fun{
} fprint_matrix$sep1 (out: FILEref): void // col separation
fun{
} fprint_matrix$sep2 (out: FILEref): void // row separation

fun{a:vt0p}
fprint_matrix{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
) : void // end of [fprint_matrix]

fun{a:vt0p}
fprint_matrix_sep{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrix_sep]

#atscode_separator()

fun{a:vt0p}
matrix_ptr_takeout_elt
  {l0:addr}
  {m,n:int}
  {i,j:nat | i < m; j < n} (
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n, j: size_t j
) :<> [l:addr] (
  a @ l
, a @ l -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_elt]

fun{a:vt0p}
matrix_ptr_takeout_row
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matrow_v (a, l, m, n)
, matrow_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_row]

fun{a:vt0p}
matrix_ptr_takeout_col
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matcol_v (a, l, m, n)
, matcol_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_col]

#atscode_separator()

fun{
a:vt0p}{env:vt0p
} matrix_foreachrow$fwork{n:int}
  (x: &array (a, n) >> _, n: size_t n, env: &(env) >> _): void
// end of [matrix_foreachrow$fwork]

fun{
a:vt0p
} matrix_foreachrow{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrix_foreachrow]
fun{
a:vt0p}{env:vt0p
} matrix_foreachrow_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachrow_env]

#atscode_separator()

fun{
a:vt0p}{env:vt0p
} matrix_foreachcol$fwork{m:int}
  (x: &array (a, m) >> _, m: size_t m, env: &(env) >> _): void
// end of [matrix_foreachcol$fwork]

fun{
a:vt0p
} matrix_foreachcol{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrix_foreachcol]
fun{
a:vt0p}{env:vt0p
} matrix_foreachcol_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachcol_env]

#atscode_separator()

fun{
a:t0p
} matrix_add$fop (x: a, y: a): a

fun{
a:t0p
} matrix_add
  {m,n:int}
(
  A: &matrix (INV(a), m, n), B: &matrix (a, m, n), C: &matrix (a?, m, n) >> matrix (a, m, n)
) : void // end of [matrix_add]

#atscode_separator()

fun{
a:t0p
} matrix_mul
  {p,q,r:int}
(
  A: &matrix (INV(a), p, q), B: &matrix (a, q, r), C: &matrix (a?, p, r) >> matrix (a, p, r)
) : void // end of [mul_matrix_matrix]

overload + with matrix_add
overload * with matrix_mul

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "matrix_atxt.txt")
%}\
