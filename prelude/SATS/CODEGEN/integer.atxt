%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"integer.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
//
fun
fprint_print_prerr_decl
  (tnm1: string, tnm2: string): atext = let
//
val ent = sprintf ("\
fun fprint_%s
  : fprint_type (%s) = \"mac#atspre_fprint_%s\"
overload fprint with fprint_%s
fun print_%s (x: %s): void
and prerr_%s (x: %s): void
overload print with print_%s
overload prerr with prerr_%s
", @(
 tnm1, tnm2, tnm1, tnm1, tnm1, tnm2, tnm1, tnm2, tnm1, tnm1
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fprint_print_prerr_decl]
//
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("September, 2011")

#atscode_separator()
//
// HX: for unindexed integer types
//
#atscode_separator()

sortdef tk = tkind

#atscode_separator()

\#define SHR(x) x // shared // for commenting
\#define NSH(x) x // not-shared // for commenting

#atscode_separator()

fun{k1,k2:tk}
g0int2int (x: g0int (k1)):<> g0int (k2)

#atscode_separator()

fun{tk:tk}
g0int_of_string (str: NSH(string)):<> g0int (tk)

#atscode_separator()

fun{tk:tk}
g0int_neg (x: g0int (tk)):<> g0int (tk)
overload ~ with g0int_neg of 0

fun{tk:tk}
g0int_succ (x: g0int (tk)):<> g0int (tk)
overload succ with g0int_succ of 0
fun{tk:tk}
g0int_pred (x: g0int (tk)):<> g0int (tk)
overload pred with g0int_pred of 0

fun{tk:tk}
g0int_half (x: g0int (tk)):<> g0int (tk)
overload half with g0int_half of 0

#atscode_separator()

%{
fun
fun_gint_aop0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "add" => "+" | "sub" => "-"
  | "mul" => "*" | "div" => "/" | "mod" => "mod"
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun{
tk:tk
} g0int_%s
  (x: g0int (tk), y: g0int (tk)):<> g0int (tk)
overload %s with g0int_%s of 0\
", @(
 opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_gint_cmp0_decl]
%}\
#fun_gint_aop0_decl("add")
#fun_gint_aop0_decl("sub")
#fun_gint_aop0_decl("mul")
#fun_gint_aop0_decl("div")
#fun_gint_aop0_decl("mod")

#atscode_separator()

%{
fun
fun_gint_cmp0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun{
tk:tk
} g0int_%s
  (x: g0int (tk), y: g0int (tk)):<> bool
overload %s with g0int_%s of 0\
", @(
 opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_gint_cmp0_decl]
%}\
#fun_gint_cmp0_decl("lt")
#fun_gint_cmp0_decl("lte")

#fun_gint_cmp0_decl("gt")
#fun_gint_cmp0_decl("gte")

#fun_gint_cmp0_decl("eq")
#fun_gint_cmp0_decl("neq")
overload <> with g0int_neq of 0

fun{tk:tk}
g0int_compare
  (x: g0int (tk), y: g0int (tk)):<> int
overload compare with g0int_compare of 0

#atscode_separator()

fun{tk:tk}
g0int_max
  (x: g0int (tk), y: g0int (tk)):<> g0int (tk)
overload max with g0int_max of 0
fun{tk:tk}
g0int_min
  (x: g0int (tk), y: g0int (tk)):<> g0int (tk)
overload min with g0int_min of 0

#atscode_separator()
//
// HX: for indexed integer types
//
castfn
g1ofg0_int {tk:tk} (x: g0int tk):<> g1int (tk)
castfn
g0tog1_int {tk:tk} (x: g0int tk):<> g1int (tk)

fun{k1,k2:tk}
g1int2int // i2i
  {i:int} (x: g1int (k1, i)):<> g1int (k2, i)
// end of [g1int2int]

#atscode_separator()

fun{tk:tk}
g1int_of_string (str: NSH(string)):<> g1int (tk)

#atscode_separator()

fun{tk:tk}
g1int_neg {i:int}
  (x: g1int (tk, i)):<> g1int (tk, ~i)
overload ~ with g1int_neg of 10

#atscode_separator()

fun{tk:tk}
g1int_succ
  {i:int} (x: g1int (tk, i)):<> g1int (tk, i+1)
overload succ with g1int_succ of 10
fun{tk:tk}
g1int_pred
  {i:int} (x: g1int (tk, i)):<> g1int (tk, i-1)
overload pred with g1int_pred of 10

fun{tk:tk}
g1int_half
  {i:int} (x: g1int (tk, i)):<> g1int (tk, i/2)
overload half with g1int_half of 10

#atscode_separator()

fun{tk:tk}
g1int_add {i,j:int} (
  x: g1int (tk, i), y: g1int (tk, j)
) :<> g1int (tk, i+j)
overload + with g1int_add of 20

fun{tk:tk}
g1int_sub {i,j:int} (
  x: g1int (tk, i), y: g1int (tk, j)
) :<> g1int (tk, i-j)
overload - with g1int_sub of 20

fun{tk:tk}
g1int_mul {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> g1int (tk, i*j)
overload * with g1int_mul of 20

fun{tk:tk}
g1int_mul2 {i,j:int} (
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [ij:int] (MUL (i, j, ij) | g1int (tk, ij))

fun{tk:tk}
g1int_div {i,j:int | j != 0}
  (x: g1int (tk, i), y: g1int (tk, j)):<> g1int (tk, i/j)
overload / with g1int_div of 20

fun{tk:tk}
g1int_ndiv {i,j:int | j > 0}
  (x: g1int (tk, i), y: g1int (tk, j)):<> g1int (tk)
fun{tk:tk}
g1int_ndiv2 {i,j:int | j > 0} (
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [q,r:int | 0 <= r; r < j] (DIVMOD (i, j, q, r) | g1int (tk, q))

#atscode_separator()

fun{tk:tk}
g1int_lt {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i < j)
overload < with g1int_lt of 20
fun{tk:tk}
g1int_lte {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i <= j)
overload <= with g1int_lte of 20

fun{tk:tk}
g1int_gt {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i > j)
overload > with g1int_gt of 20
fun{tk:tk}
g1int_gte {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i >= j)
overload >= with g1int_gte of 20

fun{tk:tk}
g1int_eq {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i == j)
overload = with g1int_eq of 20
fun{tk:tk}
g1int_neq {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> bool (i != j)
overload != with g1int_neq of 20
overload <> with g1int_neq of 20

fun{tk:tk}
g1int_compare {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> int (i-j)
overload compare with g1int_compare of 20

#atscode_separator()

fun{tk:tk}
g1int_lt_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i < j)
overload < with g1int_lt_int of 21
fun{tk:tk}
g1int_lte_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i <= j)
overload <= with g1int_lte_int of 21

fun{tk:tk}
g1int_gt_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i > j)
overload > with g1int_gt_int of 21
fun{tk:tk}
g1int_gte_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i >= j)
overload >= with g1int_gte_int of 21

fun{tk:tk}
g1int_eq_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i == j)
overload = with g1int_eq_int of 21
fun{tk:tk}
g1int_neq_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> bool (i != j)
overload != with g1int_neq_int of 21
overload <> with g1int_neq_int of 21

fun{tk:tk}
g1int_compare_int {i,j:int}
  (x: g1int (tk, i), y: g1int (int_kind, j)):<> int (i-j)
overload compare with g1int_compare_int of 21

#atscode_separator()

fun{tk:tk}
g1int_sgn {i:int} (x: g1int (tk, i)): int(sgn(i))

#atscode_separator()

fun{tk:tk}
g1int_max {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> g1int (tk, max(i, j))
overload max with g1int_max of 20
fun{tk:tk}
g1int_min {i,j:int}
  (x: g1int (tk, i), y: g1int (tk, j)):<> g1int (tk, min(i, j))
overload min with g1int_min of 20

#atscode_separator()
//
// HX: for unsigned unindexed integer types
//
#atscode_separator()

fun{k1,k2:tk}
g0int2uint (x: g0int (k1)):<> g0uint (k2)
fun{k1,k2:tk}
g0uint2int (x: g0uint (k1)):<> g0int (k2)
fun{k1,k2:tk}
g0uint2uint (x: g0uint (k1)):<> g0uint (k2)

#atscode_separator()

fun{tk:tk}
g0uint_of_string (str: NSH(string)):<> g0uint (tk)

#atscode_separator()

fun{tk:tk}
g0uint_succ (x: g0uint (tk)):<> g0uint (tk)
overload succ with g0uint_succ
fun{tk:tk}
g0uint_pred (x: g0uint (tk)):<> g0uint (tk)
overload pred with g0uint_pred

fun{tk:tk}
g0uint_half (x: g0uint (tk)):<> g0uint (tk)
overload half with g0uint_half

#atscode_separator()

%{
fun
fun_guint_aop0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "add" => "+" | "sub" => "-"
  | "mul" => "*" | "div" => "/" | "mod" => "mod"
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun{
tk:tk
} g0uint_%s
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload %s with g0uint_%s of 0\
", @(
 opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_guint_aop0_decl]
%}\
#fun_guint_aop0_decl("add")
#fun_guint_aop0_decl("sub")
#fun_guint_aop0_decl("mul")
#fun_guint_aop0_decl("div")
#fun_guint_aop0_decl("mod")

#atscode_separator()

%{
fun
fun_guint_cmp0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun{
tk:tk
} g0uint_%s
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload %s with g0uint_%s of 0\
", @(
 opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_guint_cmp0_decl]
%}\
#fun_guint_cmp0_decl("lt")
#fun_guint_cmp0_decl("lte")

#fun_guint_cmp0_decl("gt")
#fun_guint_cmp0_decl("gte")

#fun_guint_cmp0_decl("eq")
#fun_guint_cmp0_decl("neq")
overload <> with g0uint_neq of 0

fun{tk:tk}
g0uint_compare (x: g0uint (tk), y: g0uint (tk)):<> int
overload compare with g0uint_compare of 0

#atscode_separator()

fun{tk:tk}
g0uint_max (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload max with g0uint_max of 0

fun{tk:tk}
g0uint_min (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload min with g0uint_min of 0

#atscode_separator()
//
// HX: for unsigned indexed integer types
//
praxi
lemma_g1uint_param
  {tk:tk} {i:int} (x: g1uint (tk, i)):<> [i >= 0] void
// end of [lemma_g1uint_param]

#atscode_separator()

castfn
size_of_int {i:nat} (x: int i):<> size_t (i)
castfn
ssize_of_int {i:int} (x: int i):<> ssize_t (i)

#atscode_separator()

castfn
g1ofg0_uint
  {tk:tk} (x: g0uint tk):<> [i:nat] g1uint (tk, i)
// end of [g1ofg0_uint]
castfn
g0tog1_uint
  {tk:tk} (x: g0uint tk):<> [i:nat] g1uint (tk, i)
// end of [g0tog1_uint]

#atscode_separator()

fun{k1,k2:tk}
g1int2uint // i2u
  {i:nat} (x: g1int (k1, i)):<> g1uint (k2, i)
// end of [g1int2uint]
fun{k1,k2:tk}
g1uint2int // u2i
  {u:int} (x: g1uint (k1, u)):<> [u>=0] g1int (k2, u)
// end of [g1uint2int]
fun{k1,k2:tk}
g1uint2uint // u2u
  {u:int} (x: g1uint (k1, u)):<> [u>=0] g1uint (k2, u)
// end of [g1uint2uint]

#atscode_separator()

fun{tk:tk}
g1uint_succ
  {i:int} (x: g1uint (tk, i)):<> g1uint (tk, i+1)
overload succ with g1uint_succ of 10
fun{tk:tk}
g1uint_pred
  {i:int | i > 0} (x: g1uint (tk, i)):<> g1uint (tk, i-1)
overload pred with g1uint_pred of 10

fun{tk:tk}
g1uint_half
  {i:int} (x: g1uint (tk, i)):<> g1uint (tk, i ndiv 2)
overload half with g1uint_half of 10

#atscode_separator()

fun{tk:tk}
g1uint_add {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk, i+j)
overload + with g1uint_add of 20

fun{tk:tk}
g1uint_sub {i,j:int | i >= j}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk, i-j)
overload - with g1uint_sub of 20

fun{tk:tk}
g1uint_mul {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk, i*j)
overload * with g1uint_mul of 20

fun{tk:tk}
g1uint_mul2 {i,j:int} (
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> [ij:int] (MUL (i, j, ij) | g1uint (tk, ij))

fun{tk:tk}
g1uint_div {i,j:int | j != 0}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk)
overload / with g1uint_div of 20

#atscode_separator()

fun{tk:tk}
g1uint_lt {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i < j)
overload < with g1uint_lt of 20

fun{tk:tk}
g1uint_lte {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i <= j)
overload <= with g1uint_lte of 20

fun{tk:tk}
g1uint_gt {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i > j)
overload > with g1uint_gt of 20

fun{tk:tk}
g1uint_gte {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i >= j)
overload >= with g1uint_gte of 20

fun{tk:tk}
g1uint_eq {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i == j)
overload = with g1uint_eq of 20
fun{tk:tk}
g1uint_neq {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> bool (i != j)
overload != with g1uint_neq of 20
overload <> with g1uint_neq of 20

fun{tk:tk}
g1uint_compare
  {i,j:int} (
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> int (sgn(i-j))
overload compare with g1uint_compare of 20

#atscode_separator()

fun{tk:tk}
g1uint_lt_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1int (int_kind, j)):<> bool (i < j)
overload < with g1uint_lt_int of 21
fun{tk:tk}
g1uint_lte_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1int (int_kind, j)):<> bool (i <= j)
overload <= with g1uint_lte_int of 21

fun{tk:tk}
g1uint_gt_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1int (int_kind, j)):<> bool (i > j)
overload > with g1uint_gt_int of 21
fun{tk:tk}
g1uint_gte_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1int (int_kind, j)):<> bool (i >= j)
overload >= with g1uint_gte_int of 21

fun{tk:tk}
g1uint_eq_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1uint (int_kind, j)):<> bool (i == j)
overload = with g1uint_eq_int of 21
fun{tk:tk}
g1uint_neq_int {i:int;j:nat}
  (x: g1uint (tk, i), y: g1int (int_kind, j)):<> bool (i != j)
overload != with g1uint_neq_int of 21

#atscode_separator()

fun{tk:tk}
g1uint_max {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk, max(i, j))
overload max with g1uint_max of 20

fun{tk:tk}
g1uint_min {i,j:int}
  (x: g1uint (tk, i), y: g1uint (tk, j)):<> g1uint (tk, min(i, j))
overload min with g1uint_min of 20

#atscode_separator()
//
%{
local
//
staload _(*anon*) = "prelude/DATS/list.dats"
staload _(*anon*) = "prelude/DATS/list_vt.dats"
//
(*
fun f_intofstr (
  tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0int_of_string_%s (str: NSH(string)):<> %s\n", @(tnm1, tnm2))
in
  atext_strptr (ent)
end // end of [f_intofstr]
*)
fun f_int_int (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0int_%s_%s (x: %s):<> %s\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_int_int]
fun f_int2_int (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0int_%s_%s (x: %s, y: %s):<> %s\n", @(fnm, tnm1, tnm2, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_int2_int]
fun f_int2_bool (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0int_%s_%s (x: %s, y: %s):<> bool\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_int2_bool]
fun f_compare (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0int_%s_%s (x: %s, y: %s):<> int\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_compare]
//
in
//
fun
fun_gint_type_aop0_cmp0_decl (
  tnm1: string, tnm2: string
) : atext = let
var res: atextlst = list_nil
(*
val () = res := list_cons (f_intofstr (tnm1, tnm2), res)
*)
val () = res := list_cons (f_int_int ("neg", tnm1, tnm2), res)
val () = res := list_cons (f_int_int ("succ", tnm1, tnm2), res)
val () = res := list_cons (f_int_int ("pred", tnm1, tnm2), res)
//
val () = res := list_cons (f_int2_int ("add", tnm1, tnm2), res)
val () = res := list_cons (f_int2_int ("sub", tnm1, tnm2), res)
val () = res := list_cons (f_int2_int ("mul", tnm1, tnm2), res)
val () = res := list_cons (f_int2_int ("div", tnm1, tnm2), res)
val () = res := list_cons (f_int2_int ("mod", tnm1, tnm2), res)
//
val () = res := list_cons (f_int2_bool ("lt", tnm1, tnm2), res)
val () = res := list_cons (f_int2_bool ("lte", tnm1, tnm2), res)
val () = res := list_cons (f_int2_bool ("gt", tnm1, tnm2), res)
val () = res := list_cons (f_int2_bool ("gte", tnm1, tnm2), res)
val () = res := list_cons (f_int2_bool ("eq", tnm1, tnm2), res)
val () = res := list_cons (f_int2_bool ("neq", tnm1, tnm2), res)
//
val () = res := list_cons (f_compare ("compare", tnm1, tnm2), res)
//
val () = res := list_cons (f_int2_int ("max", tnm1, tnm2), res)
val () = res := list_cons (f_int2_int ("min", tnm1, tnm2), res)
val res = list_reverse (res)
in
  atext_concatxt (list_of_list_vt (res))
end // end of [fun_gint_type_aop0_cmp0_decl]
//
end // end of [local]
%}\
#fun_gint_type_aop0_cmp0_decl("int", "int")\
//
#fun_gint_type_aop0_cmp0_decl("lint", "lint")\
//
#fun_gint_type_aop0_cmp0_decl("llint", "llint")\
//
#fun_gint_type_aop0_cmp0_decl("ssize", "ssize_t")\
//
#atscode_separator()
//
#fprint_print_prerr_decl("int", "int")\
//
#fprint_print_prerr_decl("lint", "lint")\
//
#fprint_print_prerr_decl("llint", "llint")\
//
#fprint_print_prerr_decl("ssize", "ssize_t")\
//
#atscode_separator()
//
%{
local
//
staload _(*anon*) = "prelude/DATS/list.dats"
staload _(*anon*) = "prelude/DATS/list_vt.dats"
//
(*
fun f_uintofstr (
  tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0uint_of_string_%s (str: NSH(string)):<> %s\n", @(tnm1, tnm2))
in
  atext_strptr (ent)
end // end of [f_uintofstr]
*)
fun f_uint_uint (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0uint_%s_%s (x: %s):<> %s\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_uint_uint]
fun f_uint2_uint (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0uint_%s_%s (x: %s, y: %s):<> %s\n", @(fnm, tnm1, tnm2, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_uint2_uint]
fun f_uint2_bool (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0uint_%s_%s (x: %s, y: %s):<> bool\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_uint2_bool]
fun f_compare (
  fnm: string, tnm1: string, tnm2: string
) : atext = let
val ent = sprintf
  ("fun g0uint_%s_%s (x: %s, y: %s):<> int\n", @(fnm, tnm1, tnm2, tnm2))
in
  atext_strptr (ent)
end // end of [f_compare]
//
in
//
fun
fun_guint_type_aop0_cmp0_decl (
  tnm1: string, tnm2: string
) : atext = let
var res: atextlst = list_nil
(*
val () = res := list_cons (f_uintofstr (tnm1, tnm2), res)
*)
val () = res := list_cons (f_uint_uint ("succ", tnm1, tnm2), res)
val () = res := list_cons (f_uint_uint ("pred", tnm1, tnm2), res)
//
val () = res := list_cons (f_uint2_uint ("add", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_uint ("sub", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_uint ("mul", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_uint ("div", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_uint ("mod", tnm1, tnm2), res)
//
val () = res := list_cons (f_uint2_bool ("lt", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_bool ("lte", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_bool ("gt", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_bool ("gte", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_bool ("eq", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_bool ("neq", tnm1, tnm2), res)
//
val () = res := list_cons (f_compare ("compare", tnm1, tnm2), res)
//
val () = res := list_cons (f_uint2_uint ("max", tnm1, tnm2), res)
val () = res := list_cons (f_uint2_uint ("min", tnm1, tnm2), res)
val res = list_reverse (res)
in
  atext_concatxt (list_of_list_vt (res))
end // end of [fun_guint_type_aop0_cmp0_decl]
//
end // end of [local]
%}\
#fun_guint_type_aop0_cmp0_decl("uint", "uint")\
//
#fun_guint_type_aop0_cmp0_decl("ulint", "ulint")\
//
#fun_guint_type_aop0_cmp0_decl("ullint", "ullint")\
//
#fun_guint_type_aop0_cmp0_decl("size", "size_t")\
//
#atscode_separator()
//
#fprint_print_prerr_decl("uint", "uint")\
//
#fprint_print_prerr_decl("ulint", "ulint")\
//
#fprint_print_prerr_decl("ullint", "ullint")\
//
#fprint_print_prerr_decl("size", "size_t")\
//
#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "integer_atxt.txt")
%}\
