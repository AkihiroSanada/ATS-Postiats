%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"iterator.sats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/iterator.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

#atscode_separator()

absviewtype
iterator ( // HX: boxed
  knd: t@ype
, kpm: t@ype
, x: viewt@ype+, f: int, r: int
) // end of [absviewtype]

prfun lemma_iterator_param
  {knd:t0p}{kpm:t0p}{x:vt0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)): [f>=0;r>=0] void
// end of [lemma_iterator_param]

#atscode_separator()

abst@ype
iter_flist_kind // for fun list itrs

fun{x:t0p}
iter_make_list
  (xs: List (x))
  :<> [r:nat] iterator (iter_flist_kind, (), x, 0, r)
// end of [iter_make_list]

fun iter_free_list
  {x:t0p}{f,r:int}
  (itr: iterator (iter_flist_kind, (), x, f, r)):<> void
// end of [iter_free_list]

#atscode_separator()

//
// HX: for linear array itrs
//
abst@ype iter_array_kind
abst@ype iter_array_param (addr)

fun{x:vt0p}
iter_make_array
  {l:addr}{n:int} (
  pf: array_v (x, l, n) | p: ptr l, n: size_t n
) :<> iterator (
  iter_array_kind, iter_array_param(l), x, 0, n
) // end of [iter_make_array]

fun iter_free_array
  {x:vt0p}{l:addr}{f,r:int} (
  itr: iterator
    (iter_array_kind, iter_array_param(l), x, f, r)
) :<> (array_v (x, l, f+r) | void) // end of [iter_free_array]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_is_atbeg
  {kpm:t0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (f==0)
// end of [iter_is_atbeg]

fun{
knd:t0p}{x:vt0p
} iter_isnot_atbeg
  {kpm:t0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (f > 0)
// end of [iter_isnot_atbeg]

fun{
knd:t0p}{x:vt0p
} iter_is_atend
  {kpm:t0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (r==0)
// end of [iter_is_atend]

fun{
knd:t0p}{x:vt0p
} iter_isnot_atend
  {kpm:t0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (r > 0)
// end of [iter_isnot_atend]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_get_offset
  {kpm:t0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> size_t (f)
// end of [iter_get_offset]

#atscode_separator()

fun{
knd:t0p}{x:t0p
} iter_get
  {kpm:t0p}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r)):<> x
// end of [iter_get]
fun{
knd:t0p}{x:vt0p
} iter_getref
  {kpm:t0p}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r)):<> Ptr1
// end of [iter_getref]

#atscode_separator()

fun{
knd:t0p}{x:t0p
} iter_get_inc
  {kpm:t0p}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) :<> x // end of [iter_get_inc]
fun{
knd:t0p}{x:vt0p
} iter_getref_inc
  {kpm:t0p}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) :<> Ptr1 // end of [iter_getref_inc]

#atscode_separator()

fun{
knd:t0p}{x:t0p
} iter_get_dec
  {kpm:t0p}{f,r:int | f > 0; r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) :<> x // end of [iter_get_dec]
fun{
knd:t0p}{x:vt0p
} iter_getref_dec
  {kpm:t0p}{f,r:int | f > 0; r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) :<> Ptr1 // end of [iter_getref_dec]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_inc
  {kpm:t0p}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) :<> void // end of [iter_inc]
fun{
knd:t0p}{x:vt0p
} iter_dec
  {kpm:t0p}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) :<> void // end of [iter_dec]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_fjmp // forward-jmp
  {kpm:t0p}
  {f,r:int}
  {i:int | 0 <= i; i <= r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f+i, r-i), i: size_t (i)
) :<> void // end of [iter_fjmp]

fun{
knd:t0p}{x:t0p
} iter_fget_at // forward-get
  {kpm:t0p}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i)
) :<> x // end of [iter_fget_at]
fun{
knd:t0p}{x:vt0p
} iter_fgetref_at // forward-get
  {kpm:t0p}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i)
) :<> Ptr1 // end of [iter_fgetref_at]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_fbjmp // forward/backward-jmp
  {kpm:t0p}
  {f,r:int}
  {i:int | ~f <= i; i <= r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f+i, r-i), i: ssize_t (i)
) :<> void // end of [iter_fbjmp]

fun{
knd:t0p}{x:t0p
} iter_fbget_at // forward/backward-get
  {kpm:t0p}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i)
) :<> x // end of [iter_fbget_at]
fun{
knd:t0p}{x:vt0p
} iter_fbgetref_at // forward/backward-get
  {kpm:t0p}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
//
// HX: O(log(n))-time complexity is expected
//
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i)
) :<> Ptr1 // end of [iter_fbgetref_at]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_foreach_funenv
  {kpm:t0p}{v:view}{vt:vtp}{f,r:int}{fe:eff} (
  pfv: !v
| itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+r, 0)
, f: (!v | &x, !vt) -<fe> void, env: !vt
) :<fe> void // end of [fiter_foreach_funenv]

#atscode_separator()

fun{
knd:t0p}{x:vt0p
} iter_exists_funenv
  {kpm:t0p}{v:view}{vt:vtp}{f,r:int}{fe:eff} (
  pfv: !v
| itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
, pred: (!v | &x, !vt) -<fe> bool, env: !vt
) :<fe> #[
  f1,r1:int | f1>=f; f+r==f1+r1
] bool (r1 > 0) // end of [fiter_exists_funenv]

#atscode_separator()

(*
** HX-2012-05:
** Note that [iter] should support at least log-time
** fjmp and fget in order to make binary search meaningful.
**
** pord (x) = cmp (x0, x), where [x0] is the key being searched
**
** The after-interator points to the left-most location
** where the value [x0] can be inserted without violating
** orderedness.
*)
fun{
knd:t0p}{x:vt0p
} iter_bsearch_funenv
  {kpm:t0p}
  {env:vtp}
  {f,r:int}
  {ra:int | ra <= r} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
, pord: (&x, !env) -<fun> int, env: !env
, ra: size_t (ra) // range being searched
) :<> #[
  f1,r1:int | f1>=f;f+ra>=f1;f1+r1==f+r
] void // end of [iter_bsearch_funenv]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "iterator_atxt.txt")
%}\
