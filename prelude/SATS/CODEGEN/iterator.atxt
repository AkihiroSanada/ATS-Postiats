%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"iterator.sats"
val () = theTextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/iterator.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

sortdef tk = tkind
sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

#atscode_separator()
//
absviewtype
iterator_viewtype ( // HX: boxed
  knd: tkind, kpm: tkind, x: viewt@ype+, f: int, r: int
) // end of [iterator_viewtype]
stadef iterator_5 = iterator_viewtype
//
viewtypedef iterator_3 (
  knd: tkind, kpm: tkind, x: vt0p
) = [f,r:int] iterator_viewtype (knd, kpm, x, f, r)
viewtypedef iterator_4 (
  knd: tkind, kpm: tkind, x: vt0p, fr:int
) = [f,r:int | f+r==fr] iterator_viewtype (knd, kpm, x, f, r)
//
stadef iterator = iterator_3
stadef iterator = iterator_4
stadef iterator = iterator_5
//
#atscode_separator()

prfun lemma_iterator_param
  {knd:tk}{kpm:tk}{x:vt0p}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)): [f>=0;r>=0] void
// end of [lemma_iterator_param]

#atscode_separator()
//
// HX: for fun list iterators
//
stacst iter_flist_kind : tkind
stacst iter_flist_param : () -> tkind

fun{x:t0p}
iter_make_list
  {n:int} (xs: list (x, n))
  : iterator (
  iter_flist_kind, iter_flist_param(), x, 0, n
) // end of [iter_make_list]

fun iter_free_list
  {x:t0p}{f,r:int} (
  itr: iterator
    (iter_flist_kind, iter_flist_param(), x, f, r)
) : list (x, r) // end of [iter_free_list]

#atscode_separator()
//
// HX: for singly-linked list iterators
//
stacst iter_slist_kind : tkind
stacst iter_slist_param : () -> tkind

fun{x:t0p}
iter_make_list_vt
  {n:int} (xs: list_vt (x, n))
  : iterator (
  iter_slist_kind, iter_slist_param(), x, 0, n
) // end of [iter_make_list_vt]

fun iter_free_list_vt
  {x:t0p}{f,r:int} (
  itr: iterator
    (iter_slist_kind, iter_slist_param(), x, f, r)
) : list_vt (x, f+r) // end of [iter_free_list_vt]

#atscode_separator()
//
// HX: for linear array iterators
//
stacst iter_array_kind : tkind
stacst iter_array_param : (addr) -> tkind

fun{x:vt0p}
iter_make_array
  {l:addr}{n:int} (
  pf: array_v (x, l, n) | p: ptr l, n: size_t n
) : iterator (
  iter_array_kind, iter_array_param(l), x, 0, n
) // end of [iter_make_array]
fun{x:vt0p}
iter_make_array_end
  {l:addr}{n:int} (
  pf: array_v (x, l, n) | p: ptr l, n: size_t n
) : iterator (
  iter_array_kind, iter_array_param(l), x, n, 0
) // end of [iter_make_array_end]

fun iter_free_array
  {x:vt0p}{l:addr}{f,r:int} (
  itr: iterator
    (iter_array_kind, iter_array_param(l), x, f, r)
) : (array_v (x, l, f+r) | void) // endfun

#atscode_separator()
//
// HX: for functional string iterators
//
stacst iter_string_kind : tkind
stacst iter_string_param : () -> tkind

fun iter_make_string
  {n:int} (
  str: string (n)
) : iterator (
  iter_string_kind, iter_string_param(), char, 0, n
) // end of [iter_make_string]

fun iter_free_string
  {f,r:int} (
  itr: iterator
    (iter_string_kind, iter_string_param(), char, f, r)
) : string (f+r) // end of [iter_free_string]

#atscode_separator()

macdef BEG = 0 and END = 1

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_is_atbeg
  {kpm:tk}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (f==0)
// end of [iter_is_atbeg]

fun{
knd:tk}{x:vt0p
} iter_isnot_atbeg
  {kpm:tk}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (f > 0)
// end of [iter_isnot_atbeg]

fun{
knd:tk}{x:vt0p
} eq_int_iter
  {kpm:tk}{f,r:int} (
  BEG: int(0), itr: !iterator (knd, kpm, x, f, r)
) : bool (f==0) // end of [eq_int_iter]
fun{
knd:tk}{x:vt0p
} lt_int_iter
  {kpm:tk}{f,r:int} (
  BEG: int(0), itr: !iterator (knd, kpm, x, f, r)
) : bool (f > 0) // end of [lt_int_iter]

overload = with eq_int_iter
overload < with lt_int_iter

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_is_atend
  {kpm:tk}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (r==0)
// end of [iter_is_atend]
fun{
knd:tk}{x:vt0p
} iter_isnot_atend
  {kpm:tk}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)):<> bool (r > 0)
// end of [iter_isnot_atend]

fun{
knd:tk}{x:vt0p
} eq_iter_int
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r), END: int(1)
) : bool (r==0) // end of [eq_iter_int]
fun{
knd:tk}{x:vt0p
} lt_iter_int
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r), END: int(1)
) : bool (r > 0) // end of [lt_iter_int]

overload = with eq_iter_int
overload < with lt_iter_int

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_get_offset
  {kpm:tk}{f,r:int}
  (itr: !iterator (knd, kpm, x, f, r)): size_t (f)
// end of [iter_get_offset]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_getref
  {kpm:tk}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r)): Ptr1
// end of [iter_getref]

fun{
knd:tk}{x:vt0p
} iter_vget
  {kpm:tk}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r)): vttakeout (void, x)
// end of [iter_vget]

fun{
knd:tk}{x:t0p
} iter_get
  {kpm:tk}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r)): x
// end of [iter_get]

fun{
knd:tk}{x:t0p
} iter_set
  {kpm:tk}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r), x: x): void
// end of [iter_set]

fun{
knd:tk}{x:vt0p
} iter_exch
  {kpm:tk}{f,r:int | r > 0}
  (itr: !iterator (knd, kpm, x, f, r), x: &x >> x): void
// end of [iter_exch]

overload get with iter_get
overload set with iter_set
overload exch with iter_exch

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) : void // end of [iter_inc]
fun{
knd:tk}{x:vt0p
} iter_dec
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) : void // end of [iter_dec]

overload ++ with iter_inc
overload -- with iter_dec
overload inc with iter_inc
overload dec with iter_dec 

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_getref_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) : Ptr1 // end of [iter_getref_inc]

fun{
knd:tk}{x:vt0p
} iter_vget_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) : vttakeout (void, x) // end of [iter_vget_inc]

fun{
knd:tk}{x:t0p
} iter_get_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
) : x // end of [iter_get_inc]

fun{
knd:tk}{x:t0p
} iter_set_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1), x: x
) : void // end of [iter_set_inc]

fun{
knd:tk}{x:vt0p
} iter_exch_inc
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r-1)
, x: &x >> x
) : void // end of [iter_exch_inc]

overload !++ with iter_get_inc
overload =++ with iter_set_inc
overload getinc with iter_get_inc
overload setinc with iter_set_inc
overload exchinc with iter_exch_inc

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_dec_getref
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) : Ptr1 // end of [iter_dec_getref]

fun{
knd:tk}{x:vt0p
} iter_dec_vget
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) : vttakeout (void, x) // end of [iter_dec_vget]

fun{
knd:tk}{x:t0p
} iter_dec_get
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
) : x // end of [iter_dec_get]

fun{
knd:tk}{x:t0p
} iter_dec_set
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1), x: x
) : void // end of [iter_dec_set]

fun{
knd:tk}{x:vt0p
} iter_dec_exch
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r+1)
, x: &x >> x
) : void // end of [iter_dec_exch]

overload --! with iter_dec_get
overload --= with iter_dec_set
overload decget with iter_dec_get
overload decset with iter_dec_set
overload decexch with iter_dec_exch

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_fjmp // forward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i <= r} (
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f+i, r-i), i: size_t (i)
) : void // end of [iter_fjmp]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_fgetref_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i)
) : Ptr1 // end of [iter_fgetref_at]

fun{
knd:tk}{x:t0p
} iter_fget_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i)
) : x // end of [iter_fget_at]
fun{
knd:tk}{x:t0p
} iter_fset_at // forward-set
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i), x: x
) : void // end of [iter_fset_at]

fun{
knd:tk}{x:vt0p
} iter_fexch_at // forward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: size_t (i), x: &x >> x
) : void // end of [iter_fexch_at]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_fbjmp // forward/backward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i <= r} (
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f+i, r-i), i: ssize_t (i)
) : void // end of [iter_fbjmp]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_fbgetref_at // forward/backward-getref
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i)
) : Ptr1 // end of [iter_fbgetref_at]

fun{
knd:tk}{x:t0p
} iter_fbget_at // forward/backward-get
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i)
) : x // end of [iter_fbget_at]
fun{
knd:tk}{x:t0p
} iter_fbset_at // forward/backward-set
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i), x: x
) : void // end of [iter_fbset_at]

fun{
knd:tk}{x:vt0p
} iter_fbexch_at // forward/backward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r} (
  itr: !iterator (knd, kpm, x, f, r), i: ssize_t (i), x: &x >> x
) : void // end of [iter_fbexch_at]

#atscode_separator()

fun{
knd:tk}{x:t0p
} iter_fgetlst
//
// forward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat} (
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f+i1, r-i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, r)
] list_vt (x, i1) // end of [iter_fgetlst]

fun{
knd:tk}{x:t0p
} iter_bgetlst
//
// backward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat} (
  itr: !iterator (knd, kpm, x, f, r)
         >> iterator (knd, kpm, x, f-i1, r+i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, f)
] list_vt (x, i1) // end of [iter_bgetlst]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_ins
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f, r+1), x: x
) : void // end of [iter_ins]

fun{
knd:tk}{x:vt0p
} iter_ins_inc
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+1, r), x: x
) : void // end of [iter_ins_inc]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_rmv
  {kpm:tk}{f,r:int | r > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f, r-1)
) : x(*removed*) // end of [iter_rmv]

fun{
knd:tk}{x:vt0p
} iter_dec_rmv
  {kpm:tk}{f,r:int | f > 0} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f-1, r)
) : x(*removed*) // end of [iter_dec_rmv]

#atscode_separator()
//
// HX: some common generic functions on iterators
//
#atscode_separator()

fun{
knd:tk}{x:t0p
} iter_listize_cpy {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [iter_listize_cpy]
fun{
knd:tk}{x:t0p
} iter_rlistize_cpy {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [iter_rlistize_cpy]

#atscode_separator()

fun{
knd:tk}{x:vt0p
} iter_listize_rmv {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [iter_listize_rmv]
fun{
knd:tk}{x:vt0p
} iter_rlistize_rmv {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [iter_rlistize_rmv]

#atscode_separator()

fun{
x:vt0p}{env:vt0p
} iter_foreach__cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} iter_foreach__fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} iter_foreach
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [iter_foreach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} iter_foreach_env
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
, env: &INV(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [iter_foreach_env]

#atscode_separator()

fun{
x:vt0p}{env:vt0p
} iter_rforeach__cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} iter_rforeach__fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} iter_rforeach
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f >= f1; f+r==f1+r1] void // end of [iter_rforeach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} iter_rforeach_env
  {kpm:tk}{f,r:int} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
, env: &INV(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [iter_rforeach_env]

#atscode_separator()

(*
** HX-2012-05:
** Note that [iter] should support at least log-time
** fjmp and fget in order to make binary search meaningful.
**
** ford (x) = cmp (x0, x), where [x0] is the key being searched
**
** The after-interator points to the left-most location
** where the value [x0] can be inserted without violating
** orderedness.
*)
fun{x:vt0p}
iter_bsearch__ford (x: &x): int
fun{
knd:tk}{x:vt0p
} iter_bsearch
  {kpm:tk}
  {f,r:int}
  {ra:int | ra <= r} (
  itr: !iterator (knd, kpm, x, f, r) >> iterator (knd, kpm, x, f1, r1)
, ra: size_t (ra) // range being searched
) : #[
  f1,r1:int | f1>=f;f+ra>=f1;f1+r1==f+r
] void // end of [iter_bsearch]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "iterator_atxt.txt")
%}\
