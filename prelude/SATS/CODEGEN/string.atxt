%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"string.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/string.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("September, 2011")

#atscode_separator()

(*
** HX: a string is a null-terminated arrayref of characters
*)

#atscode_separator()

sortdef tk = tkind

#atscode_separator()

\#define SHR(x) x // = SHARED
\#define NSH(x) x // = NSHARED

#atscode_separator()

dataprop
string_index_p (
  n: int, int(*i*), int(*c*)
) =
  | string_index_p_eq (n, n, 0)
  | {i:int | n > i}
    {c:int8 | c != 0}
    string_index_p_gt (n, i, c)
// end of [string_index_p]

#atscode_separator()

castfn string2ptr (x: string):<> Ptr1
castfn string1_of_string0 (x: string):<> [n:int] string (n)

#atscode_separator()

fun string_make_list
  {n:int} (cs: list(charNZ, n)):<> strnptr (n)
fun string_make_listlen
  {n:int} (cs: list(charNZ, n), n: int n):<> strnptr (n)

fun string_make_list_rev
  {n:int} (cs: list(charNZ, n)):<> strnptr (n)
fun string_make_listlen_rev
  {n:int} (cs: list(charNZ, n), n: int n):<> strnptr (n)

fun string_make_substring
  {n:int}{st,ln:nat | st+ln <= n}
  (str: string (n), st: size_t st, ln: size_t ln):<> strnptr (ln)
// end of [string_make_substring]

#atscode_separator()

fun{} string_is_empty (x: string):<> bool
fun{} string_isnot_empty (x: string):<> bool

#atscode_separator()

fun{tk:tk}
string_is_atend_int
  {n:int}{i:nat | i <= n}
  (s: NSH(string n), i: g1int (tk, i)):<> bool (i==n)
// end of [string_is_atend_int]
fun{tk:tk}
string_is_atend_uint
  {n:int}{i:int | i <= n}
  (s: NSH(string n), i: g1uint (tk, i)):<> bool (i==n)
// end of [string_is_atend_uint]

symintr string_is_atend
overload string_is_atend with string_is_atend_int
overload string_is_atend with string_is_atend_uint

(* ****** ****** *)

fun{tk:tk}
string_get_at_int
  {n:int}{i:nat | i < n}
  (s: NSH(string n), i: g1int (tk, i)):<> charNZ
overload [] with string_get_at_int
fun{tk:tk}
string_get_at_uint
  {n:int}{i:int | i < n}
  (s: NSH(string n), i: g1uint (tk, i)):<> charNZ
overload [] with string_get_at_uint

symintr string_get_at
overload string_get_at with string_get_at_int
overload string_get_at with string_get_at_uint

(* ****** ****** *)

fun{tk:tk}
string_test_at_int
  {n:int}{i:nat | i <= n} (
  s: NSH(string n), i: g1int (tk, i)
) :<> [c:int] (string_index_p (n, i, c) | char (c))
fun{tk:tk}
string_test_at_uint
  {n:int}{i:int | i <= n} (
  s: NSH(string n), i: g1uint (tk, i)
) :<> [c:int] (string_index_p (n, i, c) | char (c))

symintr string_test_at
overload string_test_at with string_test_at_int
overload string_test_at with string_test_at_uint

#atscode_separator()

%{
fun
fun_string_cmp_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_string_string
  (x1: string, x2: string):<> bool = \"mac#atspre_%s_string_string\"
overload %s with %s_string_string\
", @(
 opr, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_string_cmp_decl]
%}\
\
#fun_string_cmp_decl("lt")
#fun_string_cmp_decl("lte")

#fun_string_cmp_decl("gt")
#fun_string_cmp_decl("gte")

#fun_string_cmp_decl("eq")
#fun_string_cmp_decl("neq")
overload <> with neq_string_string

fun compare_string_string
  (x1: string, x2: string):<> Sgn = "mac\#atspre_compare_string_string"
overload compare with compare_string_string

#atscode_separator()

fun strcmp (x1: string, x2: string):<> int

fun strintcmp
  {n1,n2:int | n2 >=0}
  (x1: string n1, n2: int n2):<> int(sgn(n1-n2))
// end of [strintcmp]

fun strlencmp
  {n1,n2:int}
  (x1: string n1, x2: string n2):<> int(sgn(n1-n2))
// end of [strlencmp]

#atscode_separator()

fun fprint_string
  (out: FILEref, x: string): void
overload fprint with fprint_string
fun print_string (x: string): void
and prerr_string (x: string): void
overload print with print_string
overload prerr with prerr_string

#atscode_separator()

fun strchr {n:int}
  (str: NSH(string n), c0: char):<> ssizeBtw (~1, n)
// end of [strchr]

fun strrchr {n:int}
  (str: NSH(string n), c0: char):<> ssizeBtw (~1, n)
// end of [strrchr]

fun strstr {n:int}
  (haystack: NSH(string n), needle: NSH(string)):<> ssizeBtw (~1, n)
// end of [strstr]

#atscode_separator()

fun strspn {n:int} // spanning
  (str: NSH(string n), accept: NSH(string)):<> sizeLte (n)
// end of [strspn]
fun strcspn {n:int} // complement spanning
  (str: NSH(string n), accept: NSH(string)):<> sizeLte (n)
// end of [strcspn]

#atscode_separator()

fun string_index {n:int}
  (str: NSH(string n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_index]
fun string_rindex {n:int}
  (str: NSH(string n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_rindex]

#atscode_separator()

symintr string_length
fun string0_length (x: string):<> size_t
overload string_length with string0_length
fun string1_length {n:int} (x: string n):<> size_t (n)
overload string_length with string1_length

#atscode_separator()

fun string0_copy
  {n:int} (xs: NSH(string)):<> Strptr1
// end of [string0_copy]

fun string1_copy
  {n:int} (xs: NSH(string(n))):<> strnptr (n)
// end of [string1_copy]

#atscode_separator()

fun string0_append (
  x1: NSH(string), x2: NSH(string)
) :<> Strptr1 // end of [string0_append]

fun string1_append
  {n1,n2:int} (
  x1: NSH(string(n1)), x2: NSH(string(n2))
) :<> strnptr (n1+n2) // end of [string1_append]

#atscode_separator()

fun stringlst_concat (xs: NSH(List(string))):<> Strptr1

#atscode_separator()

fun string_explode
  {n:int} (x: NSH(string(n))): list_vt (charNZ, n)
// end of [string_explode]

#atscode_separator()

fun string_tabulate__fwork (size_t): charNZ
fun string_tabulate {n:int} (n: size_t n): strnptr (n)

#atscode_separator()

fun{env:vt0p}
string_foreach__cont (c: char, env: &env): bool
fun{env:vt0p}
string_foreach__fwork (c: char, env: &env): void
fun{}
string_foreach {n:int} (str: NSH(string(n))): sizeLte(n)
fun{env:vt0p}
string_foreach_env {n:int}
  (str: NSH(string(n)), env: &INV(env) >> env): sizeLte(n)
// end of [string_foreach_env]

#atscode_separator()

fun{env:vt0p}
string_rforeach__cont (c: char, env: &env): bool
fun{env:vt0p}
string_rforeach__fwork (c: char, env: &env): void
fun{}
string_rforeach {n:int} (str: NSH(string(n))): sizeLte(n)
fun{env:vt0p}
string_rforeach_env {n:int}
  (str: NSH(string(n)), env: &INV(env) >> env): sizeLte(n)
// end of [string_rforeach_env]

#atscode_separator()

(*
** HX: [stropt_none] is just the null pointer
*)

#atscode_separator()

fun{} stropt_none (): stropt (~1)
castfn stropt_some {n:int} (x: SHR(string n)): stropt (n)

fun stropt_is_none {n:int} (x: stropt n): bool (n < 0)
fun stropt_is_some {n:int} (x: stropt n): bool (n >= 0)

castfn stropt_unsome {n:nat} (x: stropt n): string (n)

fun stropt_length
  {n:int} (x: stropt (n)): ssize_t (n)
// end of [stropt_length]

#atscode_separator()

fun fprint_stropt (out: FILEref, x: Stropt0): void

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "string_atxt.txt")
%}\
