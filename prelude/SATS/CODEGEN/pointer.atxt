%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT=="txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"pointer.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/pointer.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("March, 2012")

#atscode_separator()

sortdef tk = tkind

#atscode_separator()

sortdef t0p = t@ype and vt0p = viewt@ype

#atscode_separator()

castfn ptr1_of_ptr0 (p: ptr):<> [l:addr] ptr (l)

#atscode_separator()

prfun ptr_get_index
  {l1:addr} (p: ptr l1): [l2:addr] ADDREQ (l1, l2)
// end of [ptr_get_index]

#atscode_separator()

symintr ptr_is_null
symintr ptr_isnot_null
//
// ptr_succ(p) = ptr_add(p, 1)
// ptr_pred(p) = ptr_sub(p, 1)
//
symintr ptr_succ
symintr ptr_pred
//
// ptr_add<a> (p, ofs) = p + ofs*sizeof<a>
// ptr_sub<a> (p, ofs) = p - ofs*sizeof<a>
//
symintr ptr_add ptr_sub
//
#atscode_separator()

fun ptr0_is_null
  (p: ptr):<> bool = "mac\#atspre_ptr_is_null"
overload ptr_is_null with ptr0_is_null of 0

fun ptr0_isnot_null
  (p: ptr):<> bool = "mac\#atspre_ptr_isnot_null"
overload ptr_isnot_null with ptr0_isnot_null of 0

#atscode_separator()

fun{a:vt0p}
ptr0_succ (p: ptr):<> ptr
fun{a:vt0p}
ptr0_pred (p: ptr):<> ptr
(*
overload ptr_succ with ptr0_succ of 0
overload ptr_pred with ptr0_pred of 0
*)

#atscode_separator()
//
fun{
a:vt0p}{tk:tk
} ptr0_add_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_add_guint (p: ptr, ofs: g0uint (tk)):<> ptr
(*
overload ptr_add with ptr0_add_gint of 0
overload ptr_add with ptr0_add_guint of 0
*)
//
fun{
a:vt0p}{tk:tk
} ptr0_sub_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_sub_guint (p: ptr, ofs: g0uint (tk)):<> ptr
(*
overload ptr_sub with ptr0_sub_gint of 0
overload ptr_sub with ptr0_sub_guint of 0
*)
//
#atscode_separator()

fun sub_ptr0_ptr0
  (p1: ptr, p2: ptr):<> ssize_t = "mac\#atspre_sub_ptr0_ptr0"
overload - with sub_ptr0_ptr0 of 0 // end of [overload]

#atscode_separator()

%{
fun
fun_ptr_cmp0_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = \"mac#atspre_%s_ptr0_ptr0\"
overload %s with %s_ptr0_ptr0 of 0\
", @(
 opr, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_ptr_cmp0_decl]
%}\
\
#fun_ptr_cmp0_decl("lt")
#fun_ptr_cmp0_decl("lte")
#fun_ptr_cmp0_decl("gt")
#fun_ptr_cmp0_decl("gte")
#fun_ptr_cmp0_decl("eq")
#fun_ptr_cmp0_decl("neq")
overload <> with neq_ptr0_ptr0 of 0

fun
compare_ptr0_ptr0 (
  p1: ptr, p2: ptr
) :<> int = "mac\#atspre_compare_ptr0_ptr0"
overload compare with compare_ptr0_ptr0 of 0

#atscode_separator()

fun gt_ptr0_intz (p: ptr, i: int(0)):<> bool
overload > with gt_ptr0_intz of 0
fun eq_ptr0_intz (p: ptr, i: int(0)):<> bool
overload = with eq_ptr0_intz of 0
fun neq_ptr0_intz (p: ptr, i: int(0)):<> bool
overload != with neq_ptr0_intz of 0
overload <> with neq_ptr0_intz of 0

#atscode_separator()

fun fprint_ptr (out: FILEref, p: ptr): void

#atscode_separator()

praxi ptr1_is_gtez
  {l:addr} (p: ptr l):<> [l >= null] void

#atscode_separator()

fun ptr1_is_null {l:addr}
  (p: ptr l):<> bool (l==null) = "atspre_ptr_is_null"
fun ptr1_isnot_null {l:addr}
  (p: ptr l):<> bool (l > null) = "atspre_ptr_isnot_null"

#atscode_separator()

fun{a:vt0p}
ptr1_succ {l:addr} (p: ptr l):<> ptr (l+sizeof(a))
fun{a:vt0p}
ptr1_pred {l:addr} (p: ptr l):<> ptr (l-sizeof(a))
(*
overload ptr_succ with ptr1_succ of 1
overload ptr_pred with ptr1_pred of 1
*)

#atscode_separator()

fun{
a:vt0p}{tk:tk
} ptr1_add_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l+i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_add_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l+i*sizeof(a))
(*
overload ptr_add with ptr1_add_gint of 2
overload ptr_add with ptr1_add_guint of 2
*)

fun{
a:vt0p}{tk:tk
} ptr1_sub_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l-i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_sub_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l-i*sizeof(a))
(*
overload ptr_sub with ptr1_sub_gint of 2
overload ptr_sub with ptr1_sub_guint of 2
*)

#atscode_separator()

%{
fun
fun_ptr_cmp1_decl (
  opr: string
) : atext = let
//
val fopr_s = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "==" | "neq" => "!="
  | _ => opr
) : string // end of [val]
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 %s l2) = \"mac#atspre_%s_ptr1_ptr1\"
overload %s with %s_ptr1_ptr1 of 2\
", @(
 opr, fopr_s, opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_ptr_cmp1_decl]
%}\
\
#fun_ptr_cmp1_decl("lt")
#fun_ptr_cmp1_decl("lte")
#fun_ptr_cmp1_decl("gt")
#fun_ptr_cmp1_decl("gte")
#fun_ptr_cmp1_decl("eq")
#fun_ptr_cmp1_decl("neq")
overload <> with neq_ptr1_ptr1 of 2

fun
compare_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr l1, p2: ptr l2
) :<> int = "mac\#atspre_compare_ptr1_ptr1"
overload compare with compare_ptr1_ptr1 of 2

#atscode_separator()

fun gt_ptr1_intz
  {l:addr} (p: ptr l, i: int(0)):<> bool(l > null)
overload > with gt_ptr1_intz of 1
fun eq_ptr1_intz
  {l:addr} (p: ptr l, i: int(0)):<> bool(l==null)
overload = with eq_ptr1_intz of 1
fun neq_ptr1_intz
  {l:addr} (p: ptr l, i: int(0)):<> bool(l > null)
overload != with neq_ptr1_intz of 1
overload <> with neq_ptr1_intz of 1

#atscode_separator()
//
// HX: implemented in [prelude/DATS/pointer.dats]
//
fun{a:t0p}
ptr_get {l:addr}
  (pf: !INV(a) @ l | p: ptr l):<> a
fun{a:t0p}
ptr_get_vt {l:addr}
  (pf: !INV(a) @ l >> a?! @ l | p: ptr l):<> a
// end of [ptr_get_vt]

fun{a:vt0p}
ptr_set {l:addr} (
  pf: !a? @ l >> a @ l | p: ptr l, x: INV(a)
) :<!wrt> void // end of [ptr_set]

fun{a:vt0p}
ptr_exch {l:addr}
  (pf: !INV(a) @ l | p: ptr l, x: &a >> a):<!wrt> void
// end of [ptr_exch]

#atscode_separator()

abstype
cptr_viewt0ype_addr_type
  (a:viewt@ype+, addr) // HX: for simulating C pointers
stadef cptr = cptr_viewt0ype_addr_type
stadef cPtr0 (a:vt0p) = [l:addr] cptr (a, l)
stadef cPtr1 (a:vt0p) = [l:addr | l > null] cptr (a, l)

castfn
cptr2ptr
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> ptr (l)
// end of [castfn]

typedef voidptr (l:addr) = cptr (void, l)
typedef voidptr0 = [l:addr] voidptr (l)
typedef voidptr1 = [l:addr | l > null] voidptr (l)

typedef charptr (l:addr) = cptr (char, l)
typedef charptr0 = [l:addr] charptr (l)
typedef charptr1 = [l:addr | l > null] charptr (l)

typedef constcharptr (l:addr) = charptr (l) // HX: commenting
typedef constcharptr0 = charptr0 // HX: for commenting purpose
typedef constcharptr1 = charptr1 // HX: for commenting purpose

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "pointer_atxt.txt")
%}\
