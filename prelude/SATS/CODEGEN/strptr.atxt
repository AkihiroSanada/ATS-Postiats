%{
#define ATSCODEFORMAT "txt"
#if (ATSCODEFORMAT == "txt")
#include "utils/atsdoc/HATS/postiatsatxt.hats"
#endif // end of [ATSCCODEFORMAT]
val _thisfilename = atext_strcst"strptr.sats"
val () = theAtextMap_insert_str ("thisfilename", _thisfilename)
%}\
\
#atscode_banner()
#atscode_copyright_LGPL()

#atscode_separator()

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/strptr.atxt
** Time of generation: #timestamp()
*)

#atscode_separator()

#atscode_author("Hongwei Xi")
#atscode_authoremail("hwxi AT cs DOT bu DOT edu")
#atscode_start_time("February, 2012")

#atscode_separator()

(*
** HX-2012:
** a Strptr0 is either the null-pointer or Strptr1
** a Strptr1 is a null-terminated arrayptr of characters
*)

#atscode_separator()

absview
strbuf_view (l:addr, m:int, n:int)
stadef strbuf = strbuf_view

#atscode_separator()

praxi
lemma_strptr_param
  {l:addr} (x: !strptr l): [l>=null] void
// end of [lemma_strptr_param]

praxi
lemma_strnptr_param
  {l:addr}{n:int}
(
  x: !strnptr (l, n)
) : [(l>null&&n>=0) || (l==null&&n==(~1))] void
// end of [lemma_strnptr_param]

#atscode_separator()

praxi
lemma_strbuf_param
  {l:addr}{m,n:int} (pf: !strbuf (l, m, n)): [l>null;m>n] void
// end of [lemma_strbuf_param]

#atscode_separator()

castfn
strptr2ptr {l:addr} (x: !strptr l):<> ptr (l)
castfn
strnptr2ptr
  {l:addr}{n:int} (x: !strnptr (l, n)):<> ptr (l)
// end of [strnptr2ptr]

#atscode_separator()
//
castfn
strnptr2strptr
  {l:addr}{n:int} (x: strnptr (l, n)):<> strptr (l)
// end of [strnptr2strptr]

castfn
strptr2strnptr
  {l:addr} (x: strptr (l)):<> [n:int] strnptr (l, n)
// end of [strptr2strnptr]
//
#atscode_separator()
//
symintr strptr2opt
symintr strnptr2opt
//
castfn
stropt_of_strptr
  {l:addr} (
  x: strptr (l)
) :<> [n:int|(l==null&&n < 0)||(l>null&&n>=0)] stropt (n)
castfn stropt0_of_strptr0 (x: Strptr0):<> Stropt0
castfn stropt1_of_strptr1 (x: Strptr1):<> Stropt1
//
castfn
stropt_of_strnptr
  {l:addr}{n:int} (x: strnptr (l, n)):<> stropt (n)
//
overload strptr2opt with stropt_of_strptr
overload strptr2opt with stropt_of_strnptr
overload strnptr2opt with stropt_of_strnptr
//
#atscode_separator()
//
symintr strptr2str
symintr strnptr2str
//
castfn
string_of_strptr (x: Strptr1):<> String
castfn
string_of_strnptr
  {l:addr}{n:nat} (x: strnptr (l, n)):<> string (n)
//
overload strptr2str with string_of_strptr of 0
overload strptr2str with string_of_strnptr of 10
overload strnptr2str with string_of_strnptr of 10
//
#atscode_separator()

fun{}
strptr_null ():<> strptr (null)

#atscode_separator()

praxi
strptr_free_null
   {l:addr | l <= null} (x: strptr (l)):<> void
// end of [strptr_free_null]

#atscode_separator()

fun{}
strptr_is_null {l:addr} (x: !strptr l):<> bool (l==null)
fun{}
strptr_isnot_null {l:addr} (x: !strptr l):<> bool (l > null)

#atscode_separator()

fun{}
strnptr_get_at {n:int}
  (str: !strnptr (n), i: sizeLt n):<> charNZ
overload [] with strnptr_get_at

fun{}
strnptr_set_at {n:int}
  (str: !strnptr (n), i: sizeLt n, c: charNZ):<> void
overload [] with strnptr_set_at

#atscode_separator()

%{
fun
fun_strptr_cmp_decl (
  opr: string
) : atext = let
//
val fopr_d = (
  case+ opr of
  | "lt" => "<" | "lte" => "<="
  | "gt" => ">" | "gte" => ">="
  | "eq" => "=" | "neq" => "!="
  | _ => opr
) : string // end of [val]
//
val ent = sprintf ("\
fun %s_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = \"mac#%%\"
overload %s with %s_strptr_strptr\
", @(
 opr, fopr_d, opr
)
) // end of [sprintf] // end of [val]
//
in
  atext_strptr (ent)
end // end of [fun_strptr_cmp_decl]
%}\
\
#fun_strptr_cmp_decl("lt")
#fun_strptr_cmp_decl("lte")

#fun_strptr_cmp_decl("gt")
#fun_strptr_cmp_decl("gte")

#fun_strptr_cmp_decl("eq")
#fun_strptr_cmp_decl("neq")
overload <> with neq_strptr_strptr

fun compare_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> Sgn = "mac\#%"
overload compare with compare_strptr_strptr

#atscode_separator()

fun fprint_strptr
(
  out: FILEref, x: !Strptr0
) : void = "mac\#%"
overload fprint with fprint_strptr
fun print_strptr (x: !Strptr0): void = "mac\#%"
fun prerr_strptr (x: !Strptr0): void = "mac\#%"
overload print with print_strptr
overload prerr with prerr_strptr

#atscode_separator()

fun strptr_free (x: Strptr0):<!wrt> void = "mac\#%"
fun strnptr_free (x: Strnptr0):<!wrt> void = "mac\#%"

#atscode_separator()

fun{
} strptr_length (x: !Strptr0):<> ssize_t
fun{
} strnptr_length {n:int} (x: !strnptr n):<> ssize_t (n)

#atscode_separator()
//
fun{
} strptr0_copy (x: !Strptr0):<!wrt> Strptr0
fun{
} strptr1_copy (x: !Strptr1):<!wrt> Strptr1
fun{
} strnptr_copy
  {n:int} (x: !strnptr (n)):<!wrt> strnptr (n)
//
#atscode_separator()
//
fun{
} strptr_append (x1: !Strptr0, x2: !Strptr0):<!wrt> Strptr0
fun{
} strnptr_append {n1,n2:nat}
  (x1: !strnptr n1, x2: !strnptr n2):<!wrt> strnptr (n1+n2)
//
#atscode_separator()

fun strptrlst_concat (xs: List_vt (Strptr0)):<!wrt> Strptr0

#atscode_separator()

fun{env:vt0p}
strnptr_foreach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_foreach$fwork (c: &charNZ >> _, env: &env): void
fun{}
strnptr_foreach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_foreach_env
  {n:nat} (str: !strnptr n, env: &(env) >> env): sizeLte(n)
// end of [strnptr_foreach_env]

#atscode_separator()

fun{env:vt0p}
strnptr_rforeach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_rforeach$fwork (c: &charNZ>>charNZ, env: &env): void
fun{}
strnptr_rforeach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_rforeach_env
  {n:nat} (str: !strnptr n, env: &(env) >> env): sizeLte(n)
// end of [strnptr_rforeach_env]

#atscode_separator()

#atscode_eof_strsub("\#thisfilename$")\

%{
implement main () = fprint_filsub (stdout_ref, "strptr_atxt.txt")
%}\
