(* ****** ****** *)

%{
val () = patscode_count_reset()
val () = patscode_prefix_set("TRYIT/prelude_list")
%}

(* ****** ****** *)

#decltitle("\
ATSLIB/prelude/list\
")

(* ****** ****** *)

#declpreamble('\

#para('
This package contains a variety of common functions for creating and
manipulationg functional lists.
')

#para('
A functional data structure is one that is immutable after creation; the
memory it occupies is heap-allocated, which can only be safely freed by a
garbage collector (GC).  The type for a singly-linked functional list
containing N elements of type T is denoted by #stacode("list(T, N)"), where
T is nonlinear. Note that the type constructor #stacode("list") is
co-variant in its first argument, that is, #stacode("list(T1, N)") is a
subtype of #stacode("list(T2, N)") if T1 is a subtype of T2.
')

')#comment("declpreamble")

(* ****** ****** *)

#declname("list")
#declsynop2('\
#para('\
The full name for the list-type constructor #stacode("list") is
#stacode("list_t0ype_int_type"), which is given to the datatype declared as
follows:
#pats2xhtmls('\
datatype // t@ype+: covariant
list_t0ype_int_type (a:t@ype+, int) =
  | {n:int | n >= 0}
    list_cons (a, n+1) of (a, list_t0ype_int_type (a, n))
  | list_nil (a, 0) of ()
// end of [datatype]
')\
')')
#decldescrpt('\

There are two data constructors #dyncode("list_nil") and
#dyncode("list_cons") associated with #stacode("list"); the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.\

')

(* ****** ****** *)

#declname("List")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef List (a:t@ype) = [n:int] list (a, n)
')')
')
#declname("List0")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef List0 (a:t@ype) = [n:int | n >= 0] list (a, n)
')')
')
#declname("List1")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef List1 (a:t@ype) = [n:int | n >= 1] list (a, n)
')')
')

(* ****** ****** *)

#declname("listLt")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listLt
  (a:t0p, n:int) = [k:nat | k < n] list (a, k)
')')
')
#declname("listLte")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listLte
  (a:t0p, n:int) = [k:nat | k <= n] list (a, k)
')')
')
#declname("listGt")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listGt
  (a:t0p, n:int) = [k:int | k > n] list (a, k)
')')
')
#declname("listGte")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listGte
  (a:t0p, n:int) = [k:int | k >= n] list (a, k)
')')
')

(* ****** ****** *)

#declname("listBtw")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listBtw
  (a:t0p, m:int, n:int) = [k:int | m <= k; k < n] list (a, k)
')')
')
#declname("listBtwe")
#declsynop2('\
#para('\
#pats2xhtmls('\
typedef listBtwe
  (a:t0p, m:int, n:int) = [k:int | m <= k; k <= n] list (a, k)
')')
')

(* ****** ****** *)

#declnamesynop("ListSubscriptExn")
#decldescrpt('\

By convention, this exception is raised to indicate a situation where a
list expected to be non-empty is actually empty.  ')

(* ****** ****** *)

#declnamesynop("lemma_list_param")
#decldescrpt('\
This proof function establishes that the integer n in any list type
#stacode("list(T, n)") is a natural number, where T is a nonlinear type.
')

(* ****** ****** *)

#declnamesynop("list_of_list_vt")
#decldescrpt("\
This function casts a linear list-value to a nonlinear list-value.
")

(* ****** ****** *)

#declnamesynop("list_make_elt")
#decldescrpt('\

Given a natural number n and an element x, this function returns a list
consisting of n occurrences of x.

')

(* ****** ****** *)

#declnamesynop("list_make_intrange")
#decldescrpt('\

Given integers l and r satisfying l <= r, this function returns a list of
integers ranging from l until r-1, inclusive.

')

(* ****** ****** *)

#declnamesynop("list_make_array")
#decldescrpt('\

Given an array of size n, this function returns a linear list of length n
such that element i in the list is the element stored in cell i of the
array, where i ranges from 0 until n-1, inclusive.  ')

(* ****** ****** *)

#declnamesynop("list_make_arrpsz")
#decldescrpt("\

This function, which overloads the symbol #dyncode("list"), is often
conveniently employed to build a list of some fixed length. Note that the
argument of #dyncode("list_make_arrpsz") is a linear arrpsz-value, which is
consumed after #dyncode("list_make_arrpsz") returns.

")
#declexample("\

The following code demonstrates two ways of constructing
lists of fixed length:

#pats2xhtmld_tryit('\
implement
main () = 0 where {
  typedef T = int
  val xs1 = $lst{T}(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  val xs2 = list$arrpsz{T}(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  val xs2 = list_of_list_vt (xs2)
  val () = assert (list_equal<T> (xs1, xs2))
} // end pf [main]
')
")

(* ****** ****** *)

#declnamesynop("fprint_list__sep")
#declnamesynop("fprint_list")
#decldescrpt("\

This function prints the elements in a given list to the output
channel provided as its first argument, and it calls the function
#dyncode("fprint_list__sep") before printing an element as long as the
element is not the first one.  Note that printing each list element is
handled by calling the function #dyncode("fprint_val").  ")

#declnamesynop("fprint_list_sep")
#decldescrpt("\

This function prints the elements in a given list to the output channel
provided as its first argument, interspersing the string #dyncode('sep')
between the printed list elements. Note that printing each list element is
handled by calling the function #dyncode("fprint_val").

")
#declexample("\

The following code builds a list of digits and then prints them onto the
standard output channel:

#pats2xhtmld_tryit('\
implement
main () = let
  typedef T = int
  val out = stdout_ref
  val xs =
    $lst{T}(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  val () =
    fprint_list<T> (out, xs)
  val () = fprint_newline (out)
in
  0(*normal*)
end // end of [main]
')
")

(* ****** ****** *)

%{
(*
#declnamesynop("fprint_listlist_sep")
*)
%}

(* ****** ****** *)

#declnamesynop("list_append")
#decldescrpt('\

This function, which overloads the symbol #dyncode("+"), returns a
concatenation of its first argument xs and second argument ys.  The
time-complexity of this function is O(m), where m is the length of xs. What
is special about the implementation of this function in ATSLIB is that it
is tail-recursive.

')

#declnamesynop("list_append1_vt")
#decldescrpt('\

Given a linear list xs and a list ys, this function returns a concatenation
of xs and ys. Note that the linear list xs is consumed in the construction of
the concatenation.

')

#declnamesynop("list_append2_vt")
#decldescrpt('\

Given a list xs and a linear list ys, this function returns a concatenation
of xs and ys. Note that the linear list ys is consumed in the construction of
the concatenation.

')

(* ****** ****** *)

#declnamesynop("list_extend")
#decldescrpt('\

Given a list xs and an element x, this function returns a list that is the
concatenation of xs and [x], which [x] refers to the singleton list
consisting of x alone. Note that the time-complexity of this is function is
O(n), where n is the length of xs.

')

#declnamesynop("list_snoc")

(* ****** ****** *)

#declnamesynop("list_reverse")
#decldescrpt('\

This function returns a list that is the reverse of its argument.

')

(* ****** ****** *)

#declnamesynop("list_reverse_append")
#decldescrpt('\

This function returns a list that is the concatenation of the reverse of
its first argument and its second argument.

')

#declnamesynop("list_reverse_append1_vt")
#decldescrpt('\

Given a linear list xs and a list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list xs is consumed in
the construction of the concatenation.

')

#declnamesynop("list_reverse_append2_vt")
#decldescrpt('\

Given a list xs and a linear list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list ys is consumed in
the construction of the concatenation.

')

(* ****** ****** *)

#declnamesynop("list_concat")
#decldescrpt("\

Given a list xss, this function builds a concatenation of xss[0],
xss[1], ..., and xss[n-1], where n is the length of xss and each xss[i]
refers to element i in xss.
")
#declexample("\

The following code makes a simple use of #dyncode("list_vt_concat"):

#pats2xhtmld_tryit('\
implement
main () = 0 where {
//
  typedef T = int
  val xs1 = $lst{T}(1)
  val xs2 = $lst{T}(2)
  val xs3 = $lst{T}(3)
  val xss = $lst{List(T)}(xs1, xs2, xs3)
  val xs123 = list_concat (xss) // xs123 = [1, 2, 3]
//
  val out = stdout_ref
  val () = fprint_list_vt<T> (out, xs123) // printing out 1, 2, 3
  val () = fprint_newline (out)
//
  val () = list_vt_free (xs123)
//
} // end of [main]
')
")

(* ****** ****** *)

#declnamesynop("list_take")
#decldescrpt('\

This function returns a prefix of its first argument, where the length of
the prefix is specified by its second argument.

')
#declexample("\

The following code makes a simple use of #dyncode("list_take"):

#pats2xhtmld_tryit('\
implement
main () = 0 where {
  typedef T = int
  \#define l2l list_of_list_vt
  val out = stdout_ref
  val xs1 = $lst{T}(0, 1, 2, 3, 4)
  val n1 = list_length (xs1)
  val xs2 = $lst{T}(5, 6, 7, 8, 9)
  val () = assert (list_equal<T> (xs1, l2l (list_take (xs1 + xs2, n1))))
} // end of [main]
')
")

#declnamesynop("list_take_exn")
#decldescrpt('\

This function is like #dyncode("list_take") except that it raises an
exception (#dyncode("ListSubscriptExn")) if its second argument is negative
or exceeds the length of its first argument.

')

(* ****** ****** *)

#declnamesynop("list_drop")
#decldescrpt('\

This function returns a suffix of its first argument, where the length of
the suffix is the length of the first argument minus the integer provided
as its second argument.  ')
#declexample("\

The following code makes a simple use of #dyncode("list_drop"):

#pats2xhtmld_tryit('\
implement
main () = 0 where {
  typedef T = int
  val out = stdout_ref
  val xs1 = $lst{T}(0, 1, 2, 3, 4)
  val n1 = list_length (xs1)
  val xs2 = $lst{T}(5, 6, 7, 8, 9)
  val () = assert (list_equal<T> (xs2, list_drop (xs1 + xs2, n1)))
} // end of [main]
')
")

#declnamesynop("list_drop_exn")
#decldescrpt('\

This function is like #dyncode("list_drop") except that it raises an
exception (#dyncode("ListSubscriptExn")) if its second argument is negative
or exceeds the length of its first argument.

')

(* ****** ****** *)

#declnamesynop("list_foreach__cont")
#declnamesynop("list_foreach__fwork")

#declnamesynop("list_foreach")
#decldescrpt("\

Given a list xs of length n, this function applies to xs[i] the function
implemented by #dyncode("list_foreach__fwork"), where i ranges from 0 until
n-1, inclusive, and xs[i] refers to element i in xs.  ")

#declnamesynop("list_foreach_env")
#decldescrpt('\

This function does essentially the same as #dyncode("list_foreach")
except for taking an additional argument that serves as an environment.  ')

#declexample("\
#pats2xhtmld_tryit('\
//
staload "contrib/atshwxi/testing/SATS/randgen.sats"
//
implement
main () = let
//
typedef T = int
\#define N 1000000
val xs = randgen_list<T> (N)
val xs = list_of_list_vt (xs)
//
typedef env = T
implement
list_foreach__fwork<T><env> (x, env) = env := env + x
//
var res: env = 0
val () = list_foreach_env<T><env> (xs, res)
//  
val () = (
  print ("The total equals "); print res; print_newline ()
) // end of [val]
//
in
  0(*normal*)
end // end of [main]
')
")

(* ****** ****** *)

#declnamesynop("list_foreach2__cont")
#declnamesynop("list_foreach2__fwork")

#declnamesynop("list_foreach2")
#decldescrpt("\

Given two lists xs and ys of length m and n, respectively, this function
applies to each pair (xs[i], ys[i]) the function implemented by
#dyncode("list_foreach2__fwork"), where i ranges from 0 until min(m, n)-1,
inclusive, and xs[i] (ys[i]) refers to element i in xs (ys).  ")

#declnamesynop("list_foreach2_env")

(* ****** ****** *)

#declnamesynop("list_iforeach__cont")
#declnamesynop("list_iforeach__fwork")

#declnamesynop("list_iforeach")
#decldescrpt("\

Given a list xs, this function applies to (i, xs[i]) the function
implemented by #dyncode("list_iforeach__fwork"), where i ranges from 0
until the length of xs minus one, inclusive, and xs[i] refers to element
i in xs.  ")

#declnamesynop("list_iforeach_env")

(* ****** ****** *)

#declnamesynop("list_iforeach2__cont")
#declnamesynop("list_iforeach2__fwork")

#declnamesynop("list_iforeach2")
#decldescrpt("\

Given two lists xs and ys of length m and n, respectively, this function
applies to each tuple (i, xs[i], ys[i]) the function implemented by
#dyncode("list_iforeach2__fwork"), where i ranges from 0 until min(m, n)-1,
inclusive, and xs[i] (ys[i]) refers to element i in xs (ys).  ")

#declnamesynop("list_iforeach2_env")

(* ****** ****** *)

#declnamesynop("list_foldleft__fwork")

#declnamesynop("list_foldleft")
#decldescrpt("\

Given a list xs of length n, this function return the value of f(...f(ini,
xs[0])..., xs[n-1]), where the notation xs[i] refers element i in xs and f
is the function implemented by #dyncode("list_foldleft__fwork").

")
#declexample("\

The following code computes factorial of n for a given natural number n:\

#pats2xhtmld_tryit('\
//
staload UN = "prelude/SATS/unsafe.sats"
//
fun factorial
  {n:nat} (n: int n): int = let
//
val xs = list_make_intrange (0, n)
implement
list_foldleft__fwork<int><int> (acc, x) = acc * (x+1)
val res = list_foldleft<int><int> ($UN.linlst2lst(xs), 1(*ini*))
val () = list_vt_free (xs)
//
in
  res
end // end of [factorial]
')
")

(* ****** ****** *)

#declnamesynop("list_exists__pred")
#declnamesynop("list_exists")
#decldescrpt('\

Given a list xs, this function returns true if and only if there exists an
element in xs that satisfies the predicate implemented by
#dyncode("list_exists__pred").

')

#declexample('\

The following code implements a function for removing the duplicates in a
given list:

#pats2xhtmld_tryit('\
//
staload UN = "prelude/SATS/unsafe.sats"
//
fun{a:t0p}
list_remove_dup (
  xs: List (a), eq: (a, a) -<0> bool
) : List_vt (a) = let
  fun loop (
    xs: List (a), ys: List0_vt (a)
  ) : List_vt (a) =
    case+ xs of
    | list_cons (x, xs) => let
        implement
        list_exists__pred<a> (y) = eq (x, y)
        val found = list_exists<a> ($UN.linlst2lst(ys))
      in
        if found then loop (xs, ys) else loop (xs, list_vt_cons (x, ys))
      end // end of [list_cons]
    | list_nil () => ys
  // end of [loop]
in
  list_vt_reverse (loop (xs, list_vt_nil))
end // end of [list_remove_dup]
')\

Note that the order of elements in the returned list is consistent with
their order in the original list.

')

(* ****** ****** *)

#declnamesynop("list_forall__pred")
#declnamesynop("list_forall")
#decldescrpt('\

Given a list xs, this function returns true if and only if every element in
xs satisfies the predicate implemented by #dyncode("list_forall__pred").

')

(* ****** ****** *)

#declnamesynop("list_equal__pred")
#decldescrpt("\

This function is called in the implementation of #dyncode("list_equal") to
perform equality test on list elements, and its default implementation is
based on #dyncode("gequal_val"):

#pats2xhtmld_tryit("\
implement{a}
list_equal__pred (x, y) = gequal_val<a> (x, y)
")
")
#declnamesynop("list_equal")
#decldescrpt('\

Given two lists xs1 and xs2, this function returns true if and only if xs1
and xs2 are of the same length and the predicate implemented by
#dyncode("list_equal__pred") holds on each pair (xs1[i], xs2[i]), where i
ranges from 0 until the length of xs1 minus 1, inclusive, and xs1[i]
(xs2[i]) refers to element i in xs1 (xs2). ')

(* ****** ****** *)

#declnamesynop("list_find__pred")
#declnamesynop("list_find_exn")
#decldescrpt('\

Given a list xs, this function returns xs[i] (element i in xs) for the
least index i such that xs[i] satisfies the predicate implemented by
#dyncode("list_find__pred"). In case there is no such an element, the
function raises an exception (#dyncode("NotFoundExn")).

')
#declnamesynop("list_find_opt")
#decldescrpt('\

This function is the optional version of #dyncode("list_find_exn").

')

(* ****** ****** *)

#declnamesynop("list_filter__pred")

#declnamesynop("list_filter")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting elements in
xs that satisfy the predicate implemented by #dyncode("list_filter__pred").
The implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_labelize")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting pairs
(i, xs[i]), where i ranges from 0 until the lenght of xs minus 1 and xs[i]
refers to element i in xs. The implementation of this function in ATSLIB
is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_map__fwork")

#declnamesynop("list_map")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting f(xs[i]),
where i ranges from 0 until the lenght of xs minus 1, xs[i] refers to
element i in xs and f is the function implemented by
#dyncode("list_map__fwork").  The implementation of this function in ATSLIB
is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_imap__fwork")

#declnamesynop("list_imap")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting f(i,
xs[i]), where i ranges from 0 until the lenght of xs minus 1, xs[i] refers
to element i in xs and f is the function implemented by
#dyncode("list_imap__fwork").  The implementation of this function in
ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_mapopt__fwork")
#declnamesynop("list_mapopt")

(* ****** ****** *)

#declnamesynop("list_map2__fwork")

#declnamesynop("list_map2")
#decldescrpt('\

Given lists xs1 and xs2 of length n1 and n2, respectively, this function
returns a linear list consisting f(xs1[i], xs2[i]), where i ranges from 0
until min(n1,n2)-1, xs1[i] (xs2[i]) refers to element i in xs1 (xs2) and f is
the function implemented by #dyncode("list_map2__fwork").  The
implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_tabulate__fwork")

#declnamesynop("list_tabulate")
#decldescrpt('\

Given a natural number n, this function returns a linear list consisting of
f(i) for i ranging from 0 until n-1, inclusive, where f is the function
implemented by #dyncode("list_tabulate__fwork"). The implementation of this
function in ATSLIB is tail-recursive.

')
#declexample('\

The following code implements a function that returns a list of integers
between two given arguments:

#pats2xhtmld_tryit('\
fun list_make_intrange
  {l,r:int | l <= r} (
  l: int l, r: int r
) : list_vt (int, r-l) = let
//
implement
list_tabulate__fwork<int> (i) = l + i
//
in
  list_tabulate<int> (r-l)
end // end of [list_make_intrange]
')
')

(* ****** ****** *)

#declnamesynop("list_zip")
#decldescrpt('\

Given two lists xs and ys of length m and n, respectively, this function
zips them into a linear list xys of length equal to the minimum of m and n
such that element i in xys is the pair of element i in xs and element i in
ys, where i ranges from 0 until the length of xys minus 1, inclusive.
The implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_zipwith")
#decldescrpt('\

This function does the same as #dyncode("list_map2").

')

(* ****** ****** *)

#declnamesynop("list_mergesort__cmp")
#decldescrpt("\

This function is called in the implementation of #dyncode("list_mergesort") to
perform comparison test on list elements, and its default implementation is
based on #dyncode("gcompare_val"):

#pats2xhtmld_tryit("\
implement{a}
list_mergesort__cmp (x, y) = gcompare_val<a> (x, y)
")
")
#declnamesynop("list_mergesort")
#decldescrpt('\

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its argument according to the
ordering implemented by #dyncode("list_mergesort__cmp") and returns a
linear list that is a sorted permutation of the argument. ')

#declexample('\

The following code mergesorts a given list of integers into a list of
ascending integers and a list of descending integers.\

#pats2xhtmld_tryit('\
implement
main () = let
//
val N = 10
val out = stdout_ref
//
typedef T = int
val xs =
  $lst{T}(0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () =
  fprint_list<T> (out, xs)
val () = fprint_newline (out)
//
implement
list_mergesort__cmp<T>
  (x1, x2) = compare (x1, x2)
//
val ys_inc =
  list_mergesort<T> (xs)
val () =
  fprint_list_vt<T> (out, ys_inc)
val () = fprint_newline (out)
val () = list_vt_free<T> (ys_inc)
//
implement
list_mergesort__cmp<T>
  (x1, x2) = ~compare (x1, x2)
//
val zs_dec =
  list_mergesort<T> (xs)
val () =
  fprint_list_vt<T> (out, zs_dec)
val () = fprint_newline (out)
val () = list_vt_free<T> (zs_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

#declnamesynop("list_quicksort__cmp")
#decldescrpt("\

This function is called in the implementation of #dyncode("list_quicksort") to
perform comparison test on list elements, and its default implementation is
based on #dyncode("gcompare_val"):

#pats2xhtmld_tryit("\
implement{a}
list_quicksort__cmp (x, y) = gcompare_val<a> (x, y)
")
")
#declnamesynop("list_quicksort")
#decldescrpt('\

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its argument according to the ordering implemented by
#dyncode("list_quicksort__cmp") and returns a linear list that is a sorted
permutation of the argument. ')

#declexample('\

The following code quicksorts a given list of integers into a list of
ascending integers and a list of descending integers.\

#pats2xhtmld_tryit('\
implement
main () = let
//
val N = 10
val out = stdout_ref
//
typedef T = int
val xs = $lst{T}
  (0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () =
  fprint_list<T> (out, xs)
val () = fprint_newline (out)
//
implement
list_quicksort__cmp<T> (x1, x2) = compare (x1, x2)
//
val ys_inc =
  list_quicksort<T> (xs)
val () =
  fprint_list_vt<T> (out, ys_inc)
val () = fprint_newline (out)
val () = list_vt_free<T> (ys_inc)
//
implement
list_quicksort__cmp<T> (x1, x2) = ~compare (x1, x2)
//
val zs_dec =
  list_quicksort<T> (xs)
val () =
  fprint_list_vt<T> (out, zs_dec)
val () = fprint_newline (out)
val () = list_vt_free<T> (zs_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

(* end of [list.atxt] *)
