#decltitle("\
ATSLIB/prelude/list\
")

(* ****** ****** *)

#declpreamble('\

#para('
This package contains a variety of common functions for creating and
manipulationg functional lists.
')

#para('
A functional data structure is one that is immutable after creation; the
memory it occupies is heap-allocated, which can only be safely freed by a
garbage collector (GC).  The type for a singly-linked functional list
containing N elements of type T is denoted by #stacode("list(T, N)"), where
T is nonlinear. Note that the type constructor #stacode("list") is
co-variant in its first argument, that is, #stacode("list(T1, N)") is a
subtype of #stacode("list(T2, N)") if T1 is a subtype of T2.
')

')#comment("declpreamble")

(* ****** ****** *)

#declname("list")
#declsynopsis2('\
#para('\
The full name for the list-type constructor #stacode("list") is
#stacode("list_t0ype_int_type"), which is given to the datatype declared as
follows:
#pats2xhtmls('\
datatype // t@ype+: covariant
list_t0ype_int_type (a:t@ype+, int) =
  | {n:int | n >= 0}
    list_cons (a, n+1) of (a, list_t0ype_int_type (a, n))
  | list_nil (a, 0) of ()
// end of [datatype]
')\
')')
#decldescrpt('\

There are two data constructors #dyncode("list_nil") and
#dyncode("list_cons") associated with #stacode("list"); the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.\

')

(* ****** ****** *)

#declname("List")
#declsynopsis2('\
#para('\
#pats2xhtmls('\
typedef List (a:t@ype) = [n:nat] list (a, n)\
')')
')

(* ****** ****** *)

#declnamesynop("ListSubscriptExn")
#decldescrpt('\

By convention, this exception is raised to indicate a situation where a
list expected to be non-empty is actually empty.  ')

(* ****** ****** *)

#declnamesynop("lemma_list_param")
#decldescrpt('\
This proof function establishes that the integer n in any list type
#stacode("list(T, n)") is a natural number, where T is a nonlinear type.
')

(* ****** ****** *)

#declnamesynop("list_of_list_vt")
#decldescrpt("\
This function casts a linear list-value to a nonlinear list-value.
")

(* ****** ****** *)

#declnamesynop("list_append")
#decldescrpt('\

This function returns a concatenation of its first argument xs and second
argument ys.  The time-complexity of this function is O(m), where m is the
length of xs. What is special about the implementation of this function in
ATSLIB is that it is tail-recursive.

')

#declnamesynop("list_append1_vt")
#decldescrpt('\

Given a linear list xs and a list ys, this function returns a concatenation
of xs and ys. Note that the linear list xs is consumed in the construction of
the concatenation.

')

#declnamesynop("list_append2_vt")
#decldescrpt('\

Given a list xs and a linear list ys, this function returns a concatenation
of xs and ys. Note that the linear list ys is consumed in the construction of
the concatenation.

')

(* ****** ****** *)

#declnamesynop("list_extend")
#decldescrpt('\

Given a list xs and an element x, this function returns a list that is the
concatenation of xs and [x], which [x] refers to the singleton list
consisting of x alone. Note that the time-complexity of this is function is
O(n), where n is the length of xs.

')

(* ****** ****** *)

#declnamesynop("list_reverse")
#decldescrpt('\

This function returns a list that is the reverse of its argument.

')

(* ****** ****** *)

#declnamesynop("list_reverse_append")
#decldescrpt('\

This function returns a list that is the concatenation of the reverse of
its first argument and its second argument.

')

#declnamesynop("list_reverse_append1_vt")
#decldescrpt('\

Given a linear list xs and a list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list xs is consumed in
the construction of the concatenation.

')

#declnamesynop("list_reverse_append2_vt")
#decldescrpt('\

Given a list xs and a linear list ys, this function returns a concatenation
of the reverse of xs and ys. Note that the linear list ys is consumed in
the construction of the concatenation.

')

(* ****** ****** *)

#declnamesynop("list_concat")
#decldescrpt('\

This function returns a concatenation of the lists in its argument, which
is a list of lists.

')

(* ****** ****** *)

#declnamesynop("list_take")
#decldescrpt('\

This function returns a prefix of its first argument, where the length of
the prefix is specified by its second argument.

')

#declnamesynop("list_take_exn")
#decldescrpt('\

This function is like #dyncode("list_take") except that it raises an
exception (ListSubscriptExn) if its second argument is negative or exceeds
the length of its first argument.

')

(* ****** ****** *)

#declnamesynop("list_drop")
#decldescrpt('\

This function returns a suffix of its first argument, where the length of
the suffix is the length of the first argument minus the integer provided as
its second argument.

')

#declnamesynop("list_drop_exn")
#decldescrpt('\

This function is like #dyncode("list_drop") except that it raises an
exception (ListSubscriptExn) if its second argument is negative or exceeds
the length of its first argument.

')

(* ****** ****** *)

#declnamesynop("list_make_elt")
#decldescrpt('\

Given a natural number n and an element x, this function returns a list
consisting of n occurrences of x.

')

(* ****** ****** *)

#declnamesynop("list_make_intrange")
#decldescrpt('\

Given integers l and r satisfying l <= r, this function returns a list of
integers ranging from l until r-1, inclusively.

')

(* ****** ****** *)

#declnamesynop("list_exists__pred")
#declnamesynop("list_exists")
#decldescrpt('\

Given a list xs, this function returns true if and only if there exists an
element in xs that satisfies the predicate implemented by
#dyncode("list_exists__pred").

')

#declnamesynop("list_forall__pred")
#declnamesynop("list_forall")
#decldescrpt('\

Given a list xs, this function returns true if and only if every element in
xs satisfies the predicate implemented by #dyncode("list_forall__pred").

')

(* ****** ****** *)

#declnamesynop("list_find__pred")
#declnamesynop("list_find_exn")
#decldescrpt('\

Given a list xs, this function returns xs[i] (element i in xs) for the
least index i such that xs[i] satisfies the predicate implemented by
#dyncode("list_find__pred"). In case there is no such an element, the
function raises an exception (NotFoundExn).

')
#declnamesynop("list_find_opt")
#decldescrpt('\

This function is the optional version of #dyncode("list_find_exn").

')

(* ****** ****** *)

#declnamesynop("list_foreach__fwork")

#declnamesynop("list_foreach")
#decldescrpt("\

This function applies to each element in its argument the function
implemented by #dyncode("list_foreach__fwork").

")

(* ****** ****** *)

#declnamesynop("list_foreach2__fwork")

#declnamesynop("list_foreach2")
#decldescrpt("\

Given two lists xs and ys of length m and n, respectively, this function
applies to each pair (xs[i], ys[i]) the function implemented by
#dyncode("list_foreach2__fwork"), where i ranges from 0 until min(m, n)-1,
inclusively, and xs[i] (ys[i]) refers to element i in xs (ys).

")

(* ****** ****** *)

#declnamesynop("list_iforeach__fwork")

#declnamesynop("list_iforeach")
#decldescrpt("\

Given a list xs, this function applies to (i, xs[i]) the function
implemented by #dyncode("list_iforeach__fwork"), where i ranges from 0
until the length of xs minus one, inclusively, and xs[i] refers to element
i in xs.

")

(* ****** ****** *)

#declnamesynop("list_iforeach2__fwork")

#declnamesynop("list_iforeach2")
#decldescrpt("\

Given two lists xs and ys of length m and n, respectively, this function
applies to each tuple (i, xs[i], ys[i]) the function implemented by
#dyncode("list_iforeach2__fwork"), where i ranges from 0 until min(m, n)-1,
inclusively, and xs[i] (ys[i]) refers to element i in xs (ys).

")

(* ****** ****** *)

#declnamesynop("list_foldleft__fwork")

#declnamesynop("list_foldleft")
#decldescrpt("\

Given a list xs of length n, this function return the value of f(...f(ini,
xs[0])..., xs[n-1]), where the notation xs[i] refers element i in xs and f
is the function implemented by #dyncode("list_foldleft__fwork").

")
#declexample("\

The following code computes factorial of n for a given natural number n:\

#pats2xhtmld_tryit('
//
staload UN = "prelude/SATS/unsafe.sats"
//
fun factorial
  {n:nat} (n: int n): int = let
//
val xs = list_make_intrange (0, n)
implement
list_foldleft__fwork<int><int> (acc, x) = acc * (x+1)
val res = list_foldleft<int><int> ($UN.listcast(xs), 1(*ini*))
val () = list_vt_free (xs)
//
in
  res
end // end of [factorial]
')
")

(* ****** ****** *)

#declnamesynop("list_labelize")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting pairs
(i, xs[i]), where i ranges from 0 until the lenght of xs minus 1 and xs[i]
refers to element i in xs. The implementation of this function in ATSLIB
is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_filter__pred")

#declnamesynop("list_filter")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting elements in
xs that satisfy the predicate implemented by #dyncode("list_filter__pred").
The implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_map__fwork")

#declnamesynop("list_map")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting f(xs[i]),
where i ranges from 0 until the lenght of xs minus 1, xs[i] refers to
element i in xs and f is the function implemented by
#dyncode("list_map__fwork").  The implementation of this function in ATSLIB
is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_imap__fwork")

#declnamesynop("list_imap")
#decldescrpt('\

Given a list xs, this function returns a linear list consisting f(i,
xs[i]), where i ranges from 0 until the lenght of xs minus 1, xs[i] refers
to element i in xs and f is the function implemented by
#dyncode("list_imap__fwork").  The implementation of this function in
ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_mapopt__fwork")
#declnamesynop("list_mapopt")

(* ****** ****** *)

#declnamesynop("list_map2__fwork")

#declnamesynop("list_map2")
#decldescrpt('\

Given lists xs1 and xs2 of length n1 and n2, respectively, this function
returns a linear list consisting f(xs1[i], xs2[i]), where i ranges from 0
until min(n1,n2)-1, xs1[i] (xs2[i]) refers to element i in xs1 (xs2) and f is
the function implemented by #dyncode("list_map2__fwork").  The
implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_tabulate__fwork")

#declnamesynop("list_tabulate")
#decldescrpt('\

Given a natural number n, this function returns a linear list consisting of
f(i) for i ranging from 0 until n-1, inclusively, where f is the function
implemented by #dyncode("list_tabulate__fwork"). The implementation of this
function in ATSLIB is tail-recursive.

')
#declexample('\

The following code implements a function that returns a list of integers
between two given arguments:

#pats2xhtmld_tryit('\
fun list_make_intrange
  {l,r:int | l <= r} (
  l: int l, r: int r
) : list_vt (int, r-l) = let
//
implement
list_tabulate__fwork<int> (i) = l + i
//
in
  list_tabulate<int> (r-l)
end // end of [list_make_intrange]
')
')

(* ****** ****** *)

#declnamesynop("list_zip")
#decldescrpt('\

Given two lists xs and ys of length m and n, respectively, this function
zips them into a linear list xys of length equal to the minimum of m and n
such that element i in xys is the pair of element i in xs and element i in
ys, where i ranges from 0 until the length of xys minus 1, inclusively.
The implementation of this function in ATSLIB is tail-recursive.

')

(* ****** ****** *)

#declnamesynop("list_zipwith")
#decldescrpt('\

This function does the same as #dyncode("list_map2").

')

(* ****** ****** *)

#declnamesynop("list_mergesort__cmp")

#declnamesynop("list_mergesort")
#decldescrpt('\

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its argument according to the
ordering implemented by #dyncode("list_mergesort__cmp") and returns a
linear list that is a sorted permutation of the argument. ')

#declexample('\

The following code mergesorts a given list of integers into a list of
ascending integers and a list of descending integers.\

#pats2xhtmld_tryit('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val out = stdout_ref
//
val xs = $lst{int}(0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () = fprint_list_sep (out, xs, ", ")
val () = fprint_newline (out)
//
implement
list_mergesort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys_inc = list_mergesort<int> (xs)
val () = fprint_list_vt_sep (out, ys_inc, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys_inc)
//
implement
list_mergesort__cmp<int> (x1, x2) = ~compare_val<int> (x1, x2)
//
val ys_dec = list_mergesort<int> (xs)
val () = fprint_list_vt_sep (out, ys_dec, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

#declnamesynop("list_quicksort__cmp")

#declnamesynop("list_quicksort")
#decldescrpt('\

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its argument according to the ordering implemented by
#dyncode("list_quicksort__cmp") and returns a linear list that is a sorted
permutation of the argument. ')

#declexample('\

The following code quicksorts a given list of integers into a list of
ascending integers and a list of descending integers.\

#pats2xhtmld_tryit('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val out = stdout_ref
//
val xs = $lst{int}(0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () = fprint_list_sep (out, xs, ", ")
val () = fprint_newline (out)
//
implement
list_quicksort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys_inc = list_quicksort<int> (xs)
val () = fprint_list_vt_sep (out, ys_inc, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys_inc)
//
implement
list_quicksort__cmp<int> (x1, x2) = ~compare_val<int> (x1, x2)
//
val ys_dec = list_quicksort<int> (xs)
val () = fprint_list_vt_sep (out, ys_dec, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

(* end of [list.atxt] *)
