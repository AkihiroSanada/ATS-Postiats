#decltitle("\
ATSLIB/prelude/string\
")

(* ****** ****** *)

#declpreamble('\
#para("\

This package contains various common functions for processing (immutable)
strings.

") ')#comment("declpreamble")

(* ****** ****** *)

#declnamesynop("string_index_p")
#decldescript('\

Given a string str of length n and an index i,
#stacode("string_index_p(n, i, c)") means that str[i] in the string is
of the type #stacode("char(c)").  If str[i] equals the null character, then
i equals n.

')

(* ****** ****** *)

#declnamesynop("string_is_empty")
#decldescript('\
This funtion returns true if and only if its string argument is empty.
')

#declnamesynop("string_isnot_empty")
#decldescript('\
This funtion returns true if and only if its string argument is non-empty.
')

(* ****** ****** *)

#declnamesynop("string_is_atend")

(* ****** ****** *)

#declnamesynop("string_is_atend_int")
#decldescript('\

Given a string of length n and an index i &lt;= n, this function returns true
if and only if i equals n.  ')

#declnamesynop("string_is_atend_uint")
#decldescript('\

This function does the same as #dyncode("string_is_atend_int") except for
taking an unsigned integer as the string index.  ')

(* ****** ****** *)

#declnamesynop("string_get_at")

(* ****** ****** *)

#declnamesynop("string_get_at_int")
#decldescript('\

Given a string of length n and an index i &lt; n, this function returns the
char stored in cell i of the string.  Note that the returned character is
non-null. ')

#declnamesynop("string_get_at_uint")
#decldescript('\

This function does the same as #dyncode("string_get_at_int") except for
taking an unsigned signed integer as the string index.  ')

(* ****** ****** *)

#declnamesynop("string_test_at")

(* ****** ****** *)

#declnamesynop("string_test_at_int")
#decldescript('\

Given a string of length n and an index i &lt;= n, this function returns a
char c paired with a proof stating that i &lt; n holds if and only if c is
non-null. ')

#declnamesynop("string_test_at_uint")
#decldescript('\

This function does the same as #dyncode("string_test_at_int") except for
taking an unsigned integer as the string index.  ')

#declexample('\

The following code implements a function for computing the length of a
given string:

#pats2xhtmld('\
fun string1_length
  {n:int} .<>.
  (str: string n): size_t (n) = let
//
\#define NUL \'\\\000\'
//
prval () = lemma_string_param (str)
//
fun loop
  {i:nat | i <= n} .<n-i>. (
  str: string n, i: size_t i
) :<> size_t (n) = let
  val (pf | c) = string_test_at_uint (str, i)
in
  if c != NUL then let
    prval string_index_p_gt () = pf in loop (str, succ(i))
  end else let
    prval string_index_p_eq () = pf in i // HX: i equals n
  end // end of [if]
end // end of [loop]
//
in
  loop (str, g1int2uint (0))
end // end of [string1_length]
')
')

(* ****** ****** *)

#declnamesynop("lt_string_string")
#decldescript('\

This function returns true if and only if its first argument is less than
its second argument according to the lexicographic ordering on signed
characters.  ')

#declnamesynop("lte_string_string")
#decldescript('\

This function returns true if and only if its first argument is less than
or equal to its second argument according to the lexicographic ordering on
signed characters.  ')

(* ****** ****** *)

#declnamesynop("gt_string_string")

#decldescript('\

This function returns true if and only if its first argument is greater
than its second argument according to the lexicographic ordering on
signed characters.  ')

#declnamesynop("gte_string_string")

#decldescript('\

This function returns true if and only if its first argument is greater
than or equal to its second argument according to the lexicographic
ordering on signed characters.  ')

(* ****** ****** *)

#declnamesynop("eq_string_string")

#decldescript('\

This function returns true if and only if its first argument is equal to
its second argument according to the lexicographic ordering on
signed characters. ')

#declnamesynop("neq_string_string")
#decldescript('\

This function returns true if and only if its first argument is unequal to
its second argument according to the lexicographic ordering on
signed characters. ')

(* ****** ****** *)

#declnamesynop("compare_string_string")
#decldescript('\

This function returns ~1, 0 and 1 if and only if its first argument is less
than, equal to and greater than its second argument according to the
lexicographic ordering on signed characters. ')

')

(* ****** ****** *)

#declnamesynop("strcmp")
#decldescript('\

This function returns ~1,0 and 1 to indicate that its first string argument
is less than, equal to and greater than its second string argument,
respectively, where the comparison is based on the lexicographic ordering
on signed chars.  ')

#declnamesynop("strintcmp")
#decldescript('\

This function returns ~1,0 and 1 to indicate that the length of its first
string argument is less than, equal to and greater than the value of its
second integer argument, respectively.  ')

#declnamesynop("strlencmp")
#decldescript('\

This function returns ~1,0 and 1 to indicate that the length of its first
string argument is less than, equal to and greater than the length of its
second string argument, respectively.  ')

(* ****** ****** *)

#declnamesynop("fprint_string")

(* ****** ****** *)

#declnamesynop("string_make_list")
#decldescript('\

This function returns a linear string consisting of the same sequence of
non-null chars in its argument.  ')
#declexample('\

The following code implements a function that returns a linear string
consisting of the reverse of the sequence of chars in its argument:

#pats2xhtmld('\
staload UN = "prelude/SATS/unsafe.sats"
//
fun string_reverse
  {n:int} .<>. (
  str: string(n)
) : strnptr(n) = let
//
  prval () = lemma_string_param (str)
//
  val cs = string_explode (str)
  val cs = list_vt_reverse (cs)
  val res = string_make_list ($UN.listcast(cs))
  val () = list_vt_free (cs)
in
  res
end // end of [string_reverse]
')
')

#declnamesynop("string_make_listlen")
#decldescript('\

This function does the same as #dyncode("string_make_list") except for
taking the length of the given string as the second argument.  ')

(* ****** ****** *)

#declnamesynop("string_make_list_rev")
#decldescript('\

This function returns a linear string consisting of the reverse of the
sequence of non-null chars in its argument.  ')

#declnamesynop("string_make_listlen_rev")
#decldescript('\

This function does the same as #dyncode("string_make_list_rev") except for
taking the length of the given string as the second argument.  ')

(* ****** ****** *)

#declnamesynop("string_make_substring")

(* ****** ****** *)

#declnamesynop("strchr")
#decldescript('\

Given a string str and a char c0, this function returns the index of the
first char in str that equals c0 if there is such a char.  Otherwise, it
returns ~1 (negative 1).  ')

#declnamesynop("strrchr")
#decldescript('\

Given a string str and a char c0, this function returns the index of the
last char in str that equals c0 if there is such a char.  Otherwise, it
returns ~1 (negative 1).  ')

#declnamesynop("strstr")
#decldescript('\

Given a string str1 and a string str2, this function returns the index of
the first substring in str1 that equals str2 if there is such a
substring. Otherwise, it returns ~1 (negative 1).  Note that the function
returns 0 in the special case where str2 is empty, ')

(* ****** ****** *)

#declnamesynop("strspn")
#declnamesynop("strcspn")

(* ****** ****** *)

#declnamesynop("string_index")
#decldescript('\

This function is the same as #dyncode("strchr") except for requiring that
its second argument be a non-null char.  ')

#declnamesynop("string_rindex")
#decldescript('\

This function is the same as #dyncode("strrchr") except for requiring that
its second argument be a non-null char.  ')

(* ****** ****** *)

#declnamesynop("string0_length")
#decldescript('\

This function computes the length of a given string.  ')

#declnamesynop("string1_length")
#decldescript('\

This function does the same as #dyncode("string0_length") but is assigned a
more informative type.  ')

(* ****** ****** *)

#declnamesynop("string0_copy")
#declnamesynop("string1_copy")

#declnamesynop("string0_append")
#declnamesynop("string1_append")

(* ****** ****** *)

#declnamesynop("stringlst_concat")
#decldescript("\

This function returns a linear string that is the concatenation of the
strings in its argument.  ")

#declexample('\

The following code forms the string "Hello!" by concatenating six singleton
strings and then prints it (plus a newline) onto the standard output channel:

#pats2xhtmld('\
implement
main () = 0 where {
  val xs = $lst{string} ("H", "e", "l", "l", "o", "!")
  val hello = stringlst_concat (xs)
  val () = fprint_strptr (stdout_ref, hello)
  val () = fprint_newline (stdout_ref)
  val () = strptr_free (hello)
} // end of [main]
')
')

(* ****** ****** *)

#declnamesynop("string_explode")
#decldescript('\

Given a string of length n, this function returns a linear list
such that element i in the list equals char i in the string for
0 &lt;= i &lt; n.

')

(* ****** ****** *)

#declnamesynop("string_tabulate__fwork")
#declnamesynop("string_tabulate")
#decldescript('\

Given an integer n, this function returns a string of length n such that
char i in the string equals f(i) for 0 &lt;= i &lt n, where f is the
function implemented by #dyncode("string_tabulate__fwork").

')
#declexample('\

The following code gives an implementation of
#dyncode("string_make_substring"), which constructs a linear string
consisting of the chars in a segment of a given string:

#pats2xhtmld('\
staload UN = "prelude/SATS/unsafe.sats"
//
implement
string_make_substring
  {n}{st,ln} (str, st, ln) = let
//
implement
string_tabulate__fwork (i) = let
  val i = $UN.cast{sizeLt(ln)} (i) in str[st+i]
end // end of [string_tabulate__fwork]
//
in
  $effmask_all (string_tabulate (ln))
end // end of [string_make_substring]
')
')

(* ****** ****** *)

#declnamesynop("string_foreach__cont")
#declnamesynop("string_foreach__fwork")

#declnamesynop("string_foreach")
#decldescript('\

This function traverses a given string from left to right and applies to
each encountered char the function implemented by
#dyncode("string_foreach__fwork"). The traversal stops if the function
implemented by #dyncode("string_foreach__cont") returns false.  ')

#declexample('\

The following code implements the function #dyncode("strspn") that computes
the length of the longest prefix of a given string consisting of only chars
contained in the second argument of this function:

#pats2xhtmld('\
implement
strspn (str, accept) = let
//
val accept = string1_of_string0 (accept)
//
implement{env}
string_foreach__cont (c, env) = strchr (accept, c) >= 0
//
in
  $effmask_all (string_foreach<> (str))
end // end of [strspn]
')
')

(* ****** ****** *)

#declnamesynop("string_foreach_env")
#decldescript('\

This function does essentially the same as #dyncode("string_foreach")
except for taking an additional argument that serves as an environment.  ')

#declexample('\
The following code implements a function that computes the value of an
unsigned integer represented as a sequence of digits (of base 10):

#pats2xhtmld('\
fun atoi
  (str: string): int = let
//
val str = string1_of_string0 (str)
//
var env: int = 0
implement
string_foreach__fwork<int>
  (c, env) = env := 10 * env + (c - \'0\')
val _ = string_foreach_env<int> (str, env)
//
in
  env
end // end of [atoi]
')
Note that this function assumes its string argument consisting of
a sequence of digits.
')

(* ****** ****** *)

#declnamesynop("string_rforeach__cont")
#declnamesynop("string_rforeach__fwork")

#declnamesynop("string_rforeach")
#decldescript('\

This function traverses a given string from right to left and applies to
each encountered char the function implemented by
#dyncode("string_rforeach__fwork"). The traversal stops if the function
implemented by #dyncode("string_rforeach__cont") returns false.

')
#declexample('\

The following code implements the function #dyncode("strrchr") that finds
the index of the last occurrence of a char in a given string. If there is
no such occurrence, then ~1 (negative 1) is returned.

#pats2xhtmld('\
implement
strrchr (str, c0) = let
//
implement{env}
string_rforeach__cont (c, env) = c0 != c
val i = $effmask_all (string_rforeach<> (str))
//
in
  if string_is_atend (str, i) then g1int2int(~1) else g1uint2int(i)
end // end of [strrchr]
')
')

(* ****** ****** *)

#declnamesynop("string_rforeach_env")
#decldescript('\

This function does essentially the same as #dyncode("string_rforeach")
except for taking an additional argument that serves as an environment.  ')

(* ****** ****** *)

#declnamesynop("stropt_some")
#declnamesynop("stropt_none")

#declnamesynop("stropt_is_some")
#declnamesynop("stropt_is_none")

#declnamesynop("stropt_unsome")

(* ****** ****** *)

#declnamesynop("fprint_stropt")

(* ****** ****** *)

(* end of [string.atxt] *)
