#decltitle("\
ATSLIB/prelude/list_vt\
")

(* ****** ****** *)

#declpreamble('\

#para('\

This package contains a variety of common functions for creating/freeing
and manipulating linear lists.  ')

#para('\

The type for a singly-linked linear list containing N elements of type T is
denoted by #stacode("list_vt(T, N)"), where T can be linear. The suffix
\"vt\" in the name list_vt stands for viewtype, which is the formal name
for linear type in ATS.  Note that the type constructor #stacode("list_vt")
is co-variant in its first argument, that is, #stacode("list_vt(T1, N)") is
a subtype of #stacode("list_vt(T2, N)") if T1 is a subtype of T2. The
low-level representation for list_vt is the same as that for a standard
singly-linked list in C, and it is fairly straightforward to implement
functions in C that can directly manipulate linear lists in ATS and vice
versa.  ')

')#comment("declpreamble")

(* ****** ****** *)

#declname("list_vt")
#declsynopsis2('\

The full name for the list-type constructor #stacode("list_vt") is
#stacode("list_viewt0ype_int_viewtype"), which is given to the
linear datatype (dataviewtype) declared as follows:
#pats2xhtmls('\
dataviewtype // viewt@ype+: covariant
list_viewt0ype_int_viewtype (a:viewt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_viewt0ype_int_viewtype (a, n))
  | list_vt_nil (a, 0) of ()
// end of [list_viewt0ype_int_viewtype]
// end of [dataviewtype]
')\

')
#decldescript('\

There are two data constructors #dyncode("list_vt_nil") and
#dyncode("list_vt_cons") associated with #stacode("list_vt"); the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.\

')

(* ****** ****** *)

#declname("List_vt")
#declsynopsis2('\
#pats2xhtmls('\
typedef List_vt (a:viewt@ype) = [n:nat] list_vt (a, n)\
')')

(* ****** ****** *)

#declnamesynop("lemma_list_vt_param")
#decldescript('\
This proof function establishes that the integer n in any linear list type
#stacode("list_vt(T, n)") is a natural number, where T can be a linear type.
')

(* ****** ****** *)

#declnamesynop("list_vt_is_nil")
#decldescript('\
This function returns true if and only if its argument is a linear list of
length 0.
')
#declnamesynop("list_vt_is_cons")
#decldescript('\
This function returns true if and only if its argument is a linear list of
some positive length.
')
#declnamesynop("list_vt_is_sing")
#decldescript('\
This function returns true if and only if its argument is a linear list of
length 1, that is, a singleton linear list.
')
#declnamesynop("list_vt_is_pair")
#decldescript('\
This function returns true if and only if its argument is a linear list of
length 2.
')

(* ****** ****** *)

#declnamesynop("list_vt_length")
#decldescript('\
This function returns the length of a given linear list.
')

(* ****** ****** *)

#declnamesynop("list_vt_make_array")
#decldescript('\

Given an array of size n, this function returns a linear list of length n
such that element i in the list is the element stored in cell i of the
array, where i ranges from 0 until n-1, inclusively.

')

(* ****** ****** *)

#declnamesynop("list_vt_free")
#decldescript('\
This function frees the memory occupied by a given linear list.
')

#declnamesynop("list_vt_free_fun")
#decldescript('\
This function frees the elements in a given linear list as well as
the memory occupied by the list.
')

#declnamesynop("list_vt_clear__fwork")
#declnamesynop("list_vt_clear")
#declnamesynop("list_vt_cfree")

#declnamesynop("list_vt_clear_fun")
#decldescript('\
This function frees the elements in a given linear list (but keeps
the list itself).
')

(* ****** ****** *)

#declnamesynop("list_vt_append")
#decldescript('\

This functions appends its first list argument to its second list argument.
Note that the two list arguments are consumed in the construction of the
resulting list and thus no longer available after the function returns.
There is no memory allocation/deallocation involved.

')

(* ****** ****** *)

#declnamesynop("list_vt_extend")

(* ****** ****** *)

#declnamesynop("list_vt_reverse")
#declnamesynop("list_vt_reverse_append")

(* ****** ****** *)

#declnamesynop("list_vt_concat")

(* ****** ****** *)

#declnamesynop("list_vt_split__pred")
#declnamesynop("list_vt_split")
#decldescript('\

This function splits a given linear list xs into two according to the
predicate implemented by #dyncode("list_vt_split__pred"): the elements
left in xs satisfy the predicate while those in the returned list do not.

')
#declexample('\

The following code implements the standard quicksort on linear lists:

#pats2xhtmld('\
staload UN = "prelude/SATS/unsafe.sats"
//
fun{a:vt0p}
qsort {n:int} (
  xs: list_vt (a, n), cmp: cmpref(a)
) : list_vt (a, n) = let
in
//
case+ xs of
| @list_vt_cons
    (x0, xs1) => let
    val p_x0 = addr@(x0)
//
    implement
    list_vt_split__pred<a> (x) = let
      prval (pf, fpf) =
        $UN.ptr_vget {a} (p_x0)
      val ans = cmp (x, x0) <= 0
      prval () = fpf (pf)
    in
      ans
    end // end of [list_vt_split__pred]
//
    var xs11 = xs1
    // HX: xs11/xs12: <= x0 / > x0
    val xs12 = list_vt_split<a> (xs11)
    val xs11 = qsort (xs11, cmp)
    val xs12 = qsort (xs12, cmp)
    val () = xs1 := xs12
    prval () = fold@ (xs)
  in
    list_vt_append (xs11, xs)
  end // end of [list_vt_cons]
| ~list_vt_nil () => list_vt_nil ()
//
end // end of [qsort]
')

Note that there is no memory allocation/deallocation involved in this
implementation. It is formally verified in the type system of ATS that the
list returned by #dyncode("qsort") is of the same length as its input.  On
a meta-level, it is evident that the returned list must be a permutation of
the input as linear elements cannot be ignored or duplicated.

')

(* ****** ****** *)

#declnamesynop("list_vt_foreach__fwork")

#declnamesynop("list_vt_foreach")
#decldescript('\

This function applies to each element (treated as a left-value) in its
argument the function implemented by #dyncode("list_vt_foreach__fwork").

')

(* ****** ****** *)

#declnamesynop("list_vt_iforeach__fwork")

#declnamesynop("list_vt_iforeach")
#decldescript("\

Given a linear list xs, this function applies to (i, xs[i]) the function
implemented by #dyncode("list_vt_iforeach__fwork"), where i ranges from 0
until the length of xs minus one, inclusively, and xs[i], treated as a
left-value, refers to element i in xs.

")

(* ****** ****** *)

#declnamesynop("list_vt_filter__pred")
#declnamesynop("list_vt_filter")

(* ****** ****** *)

#declnamesynop("list_vt_map__fwork")
#declnamesynop("list_vt_map")

#declnamesynop("list_vt_mapfree__fwork")
#declnamesynop("list_vt_mapfree")

(* ****** ****** *)

#declnamesynop("list_vt_mergesort__cmp")

#declnamesynop("list_vt_mergesort")
#decldescript('\

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its list argument according to the
ordering implemented by #dyncode("list_vt_mergesort__cmp"). Note that the
list argument is consumed in the construction of the resulting sorted list
and thus no longer available after the function returns.  There is no
memory allocation/deallocation involved in the implementation of
#dyncode("list_vt_mergesort").

')
#declexample('\

The following code mergesorts a list of integers into a list of ascending
integers:\

#pats2xhtmld('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val out = stdout_ref
//
val xs = $lst_vt{int}(0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () = fprint_list_vt_sep (out, xs, ", ")
val () = fprint_newline (out)
//
implement
list_mergesort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys = list_vt_mergesort<int> (xs)
val () = fprint_list_vt_sep (out, ys, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys)
//
in
  0(*normal*)
end // end of [main]
')
')

#declnamesynop("list_vt_mergesort_fun")
#decldescript('\
This function does essentially the same as #dyncode("list_vt_mergesort")
except for allowing the comparison function to be provided as an argument.
')

(* ****** ****** *)

#declnamesynop("list_vt_quicksort__cmp")

#declnamesynop("list_vt_quicksort")
#decldescript('\

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its list argument according to the ordering implemented
by #dyncode("list_vt_quicksort__cmp"). Note that the list argument is
consumed in the construction of the resulting sorted list and thus no
longer available after the function returns. An implementation of this
function may copy the list into an array, sort the array, copy the array
back into the list, and then free the array.

')
#declexample('\

The following code quicksorts a list of integers into a list of ascending
integers:\

#pats2xhtmld('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val out = stdout_ref
//
val xs = $lst_vt{int}(0, 9, 2, 7, 4, 5, 6, 3, 8, 1)
val () = fprint_list_vt_sep (out, xs, ", ")
val () = fprint_newline (out)
//
implement
list_quicksort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys = list_vt_quicksort<int> (xs)
val () = fprint_list_vt_sep (out, ys, ", ")
val () = fprint_newline (out)
val () = list_vt_free (ys)
//
in
  0(*normal*)
end // end of [main]
')
')

#declnamesynop("list_vt_quicksort_fun")
#decldescript('\
This function does essentially the same as #dyncode("list_vt_quicksort")
except for allowing the comparison function to be provided as an argument.
')

(* ****** ****** *)

(* end of [list_vt.atxt] *)
