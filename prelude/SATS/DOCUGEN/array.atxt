(* ****** ****** *)

%{
val () = patscode_count_reset()
val () = patscode_prefix_set("TRYIT/array")
%}

(* ****** ****** *)

#decltitle("\
ATSLIB/prelude/array\
")

(* ****** ****** *)

#declpreamble('\

#para('\
The type for a plain ungarnished array containing N elements of type T is
denoted by the special syntax #stacode("@[T][N]"). The size of this
array-type is N times the size of T and its linearity coincides with the
linearity of T, that is, the type #stacode("@[T][N]") is linear if and only
if T is linear.  It should be noted that a value of this form of array-type
can be passed to a function call only as a call-by-reference parameter
(unless certain special arrangement is made for it to be passed as a
call-by-value parameter).
')#comment("para")

')#comment("declpreamble")

(* ****** ****** *)

#declname("array_v")
#declsynop2('\
#para('\
#pats2xhtmls("\
viewtypedef array_v (a: viewt@ype, l:addr, n: int) = @[a][n] @ l\
")\
')')
#decldescrpt('\

Given a type T, an address L and an integer N, the view
#stacode("array_v(T, L, N)") means that a value of the type
#stacode("@[T][N]") is stored at the location L. An equivalent
definition of #stacode("array_v") can be given as follows:

#pats2xhtmls("\
dataview
array_v (a:viewt@ype+, l: addr, int) =
  | {n:nat}
    array_v_cons (a, l, n+1) of (a @ l, array_v (a, l+sizeof(a), n))
  | array_v_nil (a, l, 0)
// end of [array_v]
")

where #stacode("array_v") is (recursively) defined as a dataview.
')

(* ****** ****** *)

#declnamesynop("ArraySubscriptExn")
#decldescrpt('\

By convention, this exception is raised to indicate a situation where the
index involved in array subscripting is out-of-bounds.\

')

(* ****** ****** *)

#declnamesynop("lemma_array_param")
#decldescrpt('\
This proof function establishes that the integer n in any array-type
#stacode("@[T][n]") is a natural number.
')

(* ****** ****** *)

#declnamesynop("lemma_array_v_param")
#decldescrpt('\
This proof function establishes that the integer n in any array-view
#stacode("array_v(T, l, n)") is a natural number.
')

(* ****** ****** *)

#declnamesynop("array_v_nil")
#decldescrpt('\
This proof function generates a proof of empty array-view.
')

(* ****** ****** *)

#declnamesynop("array_v_unnil")
#decldescrpt('\
This proof function consumes a proof of empty array-view.
')

(* ****** ****** *)

#declnamesynop("array_v_unnil_nil")
#decldescrpt('\
This proof function consumes a proof of empty array-view and then generates
a proof of empty array-view. It is a combination of array_v_unnil and array_v_nil.
')

(* ****** ****** *)

#declnamesynop("array_v_cons")
#decldescrpt('\
This proof function composes a proof of at-view and
a proof of array-view of size n to form a proof of array-view of size n+1.
')

#declnamesynop("array_v_uncons")
#decldescrpt('\

This proof function is the inverse of #prfcode("array_v_cons"): It
decomposes a proof of array-view of size n into a proof of at-view and a
proof of array-view of size n-1, where n is positive.

')

(* ****** ****** *)

#declnamesynop("array_v_sing")
#decldescrpt('\
This proof function turns a proof of at-view into a proof of array-view of
size 1.
')

(* ****** ****** *)

#declnamesynop("array_v_unsing")
#decldescrpt('\

This proof function is the inverse of #prfcode("array_v_sing"): It turns a
proof of array-view of size 1 into a proof of at-view.

')

(* ****** ****** *)

#declnamesynop("array_getref_at")
#decldescrpt('\
This function returns the pointer to cell i of the given array A, that is,
the pointer equal to addr@(A)+i*#sizeof("a"), where addr@(A) refers to the
starting address of A.
')

#declexample('\
A typical use of
#dyncode("array_getref_at") is given in the following example:
#pats2xhtmld_tryit('\
//
staload UN = "prelude/SATS/unsafe.sats"
//
fun{a:t0p}
array_get_at {n:nat} (
  A: &(@[a][n]), i: sizeLt n
) : a = let
  val p = array_getref_at<a> (A, i) in $UN.ptr_get<a> (p)
end // end of [array_get_at]
')
Note that the unsafe version of #dyncode("ptr_get") is called
here to read from the pointer p.
')

(* ****** ****** *)

#declnamesynop("array_get_at")
#decldescrpt('\
This function returns the value stored in cell i of the given array A.
Note that the type for values stored in A is nonlinear.
')

(* ****** ****** *)

#declnamesynop("array_set_at")
#decldescrpt('\
This function stores a value into cell i of the given array A, overwriting
the original value. Note that the type of values stored in A is nonlinear.
')

(* ****** ****** *)

#declnamesynop("array_exch_at")
#decldescrpt('\
This function exchanges the value in cell i of the given array A and the
value in its second argument. Note that the type of these values can be linear.
')

(* ****** ****** *)

#declnamesynop("array_foreach__cont")
#declnamesynop("array_foreach__fwork")

#declnamesynop("array_foreach")
#decldescrpt('\

This function traverses a given array from left to right, applying to each
encountered array-cell the function implemented by
#dyncode("array_foreach__fwork").  The traversal stops if the function
implemented by #dyncode("array_foreach__cont") returns false, and the return
value of #dyncode("array_foreach") indicates the number of processed
array-cells.  ')
#declexample('\

The following code implements a function that searches for the index of the
first array-cell in a given array that contains an element satisfing the
predicate provided as the third argument of the function:

#pats2xhtmld_tryit('\
fun{a:t@ype}
array_find {n:int} (
  A: &(@[a][n]) >> @[a][n], n: size_t n, p: (a) -> bool
) : Option_vt (sizeLt(n)) = let
//
implement(env)
array_foreach__cont<a><env> (x, env) = ~p(x)
implement(env)
array_foreach__fwork<a><env> (x, env) = ((*nothing*))
val i = array_foreach (A, n)
//
in
  if n > i then Some_vt (i) else None_vt ()
end // end of [array_find]
')
')

#declnamesynop("array_foreach_env")
#decldescrpt('\

This function does essentially the same as #dyncode("array_foreach")
except for taking an additional argument that serves as an environment.  ')

#declexample('\

The following code implements the standard fold-from-left operation on a
given array:

#pats2xhtmld_tryit('
fun{
a:t0p}{res:t0p
} array_foldleft
  {n:int} (
  A: &(@[a][n])
, asz: size_t n
, ini: res
, f: (res, a) -> res
) : res = let
//
var env: res = ini
//
implement
array_foreach__fwork<a><res> (x, env) = env := f (env, x)
val _ = array_foreach_env (A, asz, env)
//
in
  env
end // end of [array_foldleft]
')
')

(* ****** ****** *)

#declnamesynop("array_foreach_funenv")
#decldescrpt('\

This function is like #dyncode("array_foreach") except that the function
to be applied to each array cell is provided as an argument.  ')

#declnamesynop("array_foreach_fun")
#decldescrpt('\

This function is a special case of #dyncode("array_foreach_funenv") in that
the provided function does not take an argument as its environment.  ')

(* ****** ****** *)

#declnamesynop("array_rforeach__cont")
#declnamesynop("array_rforeach__fwork")

#declnamesynop("array_rforeach")
#decldescrpt('\

This function traverses a given array from right to left, applying to each
encountered array-cell the function implemented by
#dyncode("array_rforeach__fwork"). The traversal stops is the function
implemented by #dyncode("array_rforeach__cont") returns false, and the
return value of #dyncode("array_rforeach") indicates the number of
processed array-cells.  ')
#declexample('\

The following code implements a function that searches for the index of the
last array-cell in a given array that contains an element satisfing the
predicate provided as the third argument of the function:

#pats2xhtmld_tryit('\
fun{a:t@ype}
array_rfind {n:int} (
  A: &(@[a][n]) >> @[a][n], n: size_t n, p: (a) -> bool
) : Option_vt (sizeLt(n)) = let
//
implement(env)
array_rforeach__cont<a><env> (x, env) = ~p(x)
implement(env)
array_rforeach__fwork<a><env> (x, env) = ((*nothing*))
val i = array_rforeach (A, n)
//
in
  if n > i then Some_vt (pred(n)-i) else None_vt ()
end // end of [array_rfind]
')
')

#declnamesynop("array_rforeach_env")
#decldescrpt('\

This function does essentially the same as #dyncode("array_rforeach")
except for taking an additional argument that serves as an environment.  ')

#declexample('\

The following code implements the standard fold-from-right operation on a
given array:

#pats2xhtmld_tryit('
fun{
a:t0p}{res:t0p
} array_foldright
  {n:int} (
  A: &(@[a][n])
, asz: size_t n
, f: (a, res) -> res
, snk: res
) : res = let
//
var env: res = snk
//
implement
array_rforeach__fwork<a><res> (x, env) = env := f (x, env)
val _ = array_rforeach_env (A, asz, env)
//
in
  env
end // end of [array_foldright]
')
')

(* ****** ****** *)

#declnamesynop("array_initize__fwork")
#declnamesynop("array_initize")

#declnamesynop("array_uninitize__fwork")
#declnamesynop("array_uninitize")

(* ****** ****** *)

#declnamesynop("array_quicksort__cmp")
#declnamesynop("array_quicksort")

(* ****** ****** *)

#declnamesynop("array_permute__randint")
#declnamesynop("array_permute")
#decldescrpt('\

This function permutes the contents of a given array according to the
random number generator implemented by #dyncode("array_permute__randint").
')
#declexample('\

The following code creates an array of integers 0, 1, 2, 3, 4, 5, 6, 7, 8
and 9, and then permutes the array contents to obtain an array of integers
9, 0, 1, 2, 3, 4, 5, 6, 7, and 8:

#pats2xhtmld_tryit('\
implement
main () =
  (0) where {
//
\#define N 10
val asz = g1int2uint (N)
//
val (pf, pfgc | p) = array_ptr_alloc<int> (asz)
//
implement
array_initize__fwork<int> (i, x) = x := g0uint2int (i)
val () = array_initize<int> (!p, asz) // array: 0, 1, 2, ..., N-1
//
implement
array_permute__randint<>
  (n) = pred(n) // this is not random
val () = array_permute<int> (!p, asz) // array: N-1, 0, 1, 2, ...
//
val () = array_ptr_free (pf, pfgc | p)
//
} // end of [main]
')\

Note that the created array is properly freed before the code exits.  ')

(* ****** ****** *)

(* end of [array.atxt] *)
