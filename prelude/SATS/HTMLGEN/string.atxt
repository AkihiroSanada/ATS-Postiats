#decltitle("\
ATSLIB/prelude/string\
")

(* ****** ****** *)

#declpreamble('\
#para("\

This package contains various common functions for processing (immutable)
strings.

") ')#comment("declpreamble")

(* ****** ****** *)

#declnamesynop("string_index_char")
#decldescript('\

Given a string str of length n and an index i,
#stacode("string_index_char(n, i, c)") means that str[i] in the string is
of the type #stacode("char(c)").  If str[i] equals the null character, then
i equals n.

')

(* ****** ****** *)

#declnamesynop("string_get_at_uint")
#decldescript('\

Given a string of length n and an index i < n, this function returns the
char stored in cell i of the string.  Note that the returned character is
non-null. ')

%{
(*
#declnamesynop("string_get_at_int")
#decldescript('\
This function does the same as #dyncode("string_get_at_uint") except for
taking a signed integer as the string index.  ')
*)
%}

(* ****** ****** *)

#declnamesynop("string_is_atend_uint")
#decldescript('\

Given a string of length n and an index i <= n, this function returns true
if and only if i equals n.  ')

%{
(*
#declnamesynop("string_is_atend_int")
#decldescript('\
This function does the same as #dyncode("string_is_atend_uint") except for
taking a signed integer as the string index.  ')
*)
%}

(* ****** ****** *)

#declnamesynop("string_test_at_uint")
#decldescript('\

Given a string of length n and an index i <= n, this function returns a
char c paired with a proof stating that i < n holds if and only if c is
non-null. ')

#declexample('\

The following code implements a function for computing the length of a
given string:

#pats2xhtmld('\
fun string1_length
  {n:int} .<>.
  (str: string n): size_t (n) = let
//
\#define NUL \'\\\000\'
//
prval () = lemma_string_param (str)
//
fun loop
  {i:nat | i <= n} .<n-i>. (
  str: string n, i: size_t i
) :<> size_t (n) = let
  val (pf | c) = string_test_at_uint (str, i)
in
  if c != NUL then let
    prval string_index_char_gt () = pf in loop (str, succ(i))
  end else let
    prval string_index_char_eq () = pf in i // HX: i equals n
  end // end of [if]
end // end of [loop]
//
in
  loop (str, g1int2uint (0))
end // end of [string1_length]
')
')

%{
(*
#declnamesynop("string_test_at_int")
#decldescript('\
This function does the same as #dyncode("string_test_at_uint") except for
taking a signed integer as the string index.  ')
*)
%}

(* ****** ****** *)

#declnamesynop("lt_string_string")
#decldescript('\

This function returns true if and only if its first argument is less than
its second argument according to the lexicographic ordering on characters.
')

#declnamesynop("lte_string_string")
#decldescript('\

This function returns true if and only if its first argument is less than
or equal to its second argument according to the lexicographic ordering on
characters.  ')

(* ****** ****** *)

#declnamesynop("gt_string_string")

#decldescript('\

This function returns true if and only if its first argument is greater
than its second argument according to the lexicographic ordering on
characters.  ')

#declnamesynop("gte_string_string")

#decldescript('\

This function returns true if and only if its first argument is greater
than or equal to its second argument according to the lexicographic
ordering on characters.  ')

(* ****** ****** *)

#declnamesynop("eq_string_string")

#decldescript('\

This function returns true if and only if its first argument is equal to
its second argument according to the lexicographic ordering on characters.
')

#declnamesynop("neq_string_string")
#decldescript('\

This function returns true if and only if its first argument is unequal to
its second argument according to the lexicographic ordering on characters.
')

(* ****** ****** *)

#declnamesynop("string0_length")
#decldescript('\

This function computes the length of a given string.  ')

#declnamesynop("string1_length")
#decldescript('\

This function does the same as #dyncode("string0_length") but is assigned a
more informative type.  ')

(* ****** ****** *)

#declnamesynop("strchr")
#declnamesynop("strrchr")
#declnamesynop("strstr")

#declnamesynop("strspn")
#declnamesynop("strcspn")

#declnamesynop("string_index")
#declnamesynop("string_rindex")

(* ****** ****** *)

#declnamesynop("string_foreach__cont")
#declnamesynop("string_foreach__fwork")

#declnamesynop("string_foreach")
#decldescript('\

This function traverses a given string from left to right and applies to
each encountered char the function implemented by
#dyncode("string_foreach__fwork"). The traversal stops if the function
implemented by #dyncode("string_foreach__cont") returns false.  ')

#declexample('\

The following code implements the function #dyncode("strspn") that computes
the length of the longest prefix of a given string consisting of only chars
contained in the second argument of this function:

#pats2xhtmld('\
implement
strspn (str, accept) = let
//
val accept = string1_of_string0 (accept)
//
implement{env}
string_foreach__cont (c, env) = strchr (accept, c) >= 0
//
in
  $effmask_all (string_foreach<> (str))
end // end of [strspn]
')
')

(* ****** ****** *)

#declnamesynop("string_foreach_env")
#decldescript('\

This function does essentially the same as #dyncode("string_foreach")
except for taking an additional argument that serves as an environment.  ')

#declexample('\
The following code implements a function that computes the value of an
unsigned integer represented as a sequence of digits (of base 10):

#pats2xhtmld('\
fun atoi
  (str: string): int = let
//
val str = string1_of_string0 (str)
//
var env: int = 0
implement
string_foreach__fwork<int>
  (c, env) = env := 10 * env + (c - \'0\')
val _ = string_foreach_env<int> (str, env)
//
in
  env
end // end of [atoi]
')
Note that this function assumes its string argument consisting of
a sequence of digits.
')

(* ****** ****** *)

#declnamesynop("string_rforeach__cont")
#declnamesynop("string_rforeach__fwork")

#declnamesynop("string_rforeach")
#decldescript('\

This function traverses a given string from right to left and applies to
each encountered char the function implemented by
#dyncode("string_rforeach__fwork"). The traversal stops if the function
implemented by #dyncode("string_rforeach__cont") returns false.

')
#declexample('\

The following code implements the function #dyncode("strrchr") that finds
the index of the last occurrence of a char in a given string. If there is
no such occurrence, then ~1 (negative 1) is returned.

#pats2xhtmld('\
implement
strrchr (str, c0) = let
//
implement{env}
string_rforeach__cont (c, env) = c0 != c
val i = $effmask_all (string_rforeach<> (str))
//
in
  if string_is_atend (str, i) then g1int2int(~1) else g1uint2int(i)
end // end of [strrchr]
')
')

(* ****** ****** *)

#declnamesynop("string_rforeach_env")
#decldescript('\

This function does essentially the same as #dyncode("string_rforeach")
except for taking an additional argument that serves as an environment.  ')

(* ****** ****** *)

(* end of [string.atxt] *)
