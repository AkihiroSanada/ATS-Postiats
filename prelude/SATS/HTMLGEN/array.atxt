#decltitle("\
ATSLIB/prelude/array\
")

(* ****** ****** *)

#declpreamble('\

The type for a plain ungarnished array containing N elements of type T is
denoted by the special syntax #stacode("@[T][N]"). The size of this
array-type is N times the size of T and its linearity coincides with the
linearity of T, that is, the type #stacode("@[T][N]") is linear if and only
if T is linear.  It should be noted that a value of this form of array-type
can be passed to a function call only as a call-by-reference parameter
(unless certain special arrangement is made for it to be passed as a
call-by-value parameter).\

')#comment("declpreamble")

(* ****** ****** *)

#declname("array_v")
#declsynopsis2('\
#pats2xhtmls("\
viewtypedef array_v (a: viewt@ype, l:addr, n: int) = @[a][n] @ l\
")\
')
#decldescript('\

Given a type T, an address L and an integer N, the view
#stacode("array_v(T, L, N)") means that a value of the type
#stacode("@[T][N]") is stored at the location L. An equivalent
definition of #stacode("array_v") can be given as follows:

#pats2xhtmls("\
dataview
array_v (a:viewt@ype+, l: addr, int) =
  | {n:nat}
    array_v_cons (a, l, n+1) of (a @ l, array_v (a, l+sizeof(a), n))
  | array_v_nil (a, l, 0)
")

where #stacode("array_v") is (recursively) defined as a dataview.
')

(* ****** ****** *)

#declnamesynop("lemma_array_param")
#decldescript('\
This proof function establishes that the integer n in any array-type
#stacode("@[T][n]") is a natural number.
')

(* ****** ****** *)

#declnamesynop("lemma_array_v_param")
#decldescript('\
This proof function establishes that the integer n in any array-view
#stacode("array_v(T, l, n)") is a natural number.
')

(* ****** ****** *)

#declnamesynop("array_v_nil")
#decldescript('\
This proof function generates a proof of empty array-view.
')

(* ****** ****** *)

#declnamesynop("array_v_unnil")
#decldescript('\
This proof function consumes a proof of empty array-view.
')

(* ****** ****** *)

#declnamesynop("array_v_unnil_nil")
#decldescript('\
This proof function consumes a proof of empty array-view and then generates
a proof of empty array-view. It is a combination of array_v_unnil and array_v_nil.
')

(* ****** ****** *)

#declnamesynop("array_v_cons")
#decldescript('\
This proof function composes a proof of at-view and
a proof of array-view of size n to form a proof of array-view of size n+1.
')

#declnamesynop("array_v_uncons")
#decldescript('\

This proof function is the inverse of #prfcode("array_v_cons"): It
decomposes a proof of array-view of size n into a proof of at-view and a
proof of array-view of size n-1, where n is positive.

')

(* ****** ****** *)

#declnamesynop("array_v_sing")
#decldescript('\
This proof function turns a proof of at-view into a proof of array-view of
size 1.
')

(* ****** ****** *)

#declnamesynop("array_v_unsing")
#decldescript('\

This proof function is the inverse of #prfcode("array_v_sing"): It turns a
proof of array-view of size 1 into a proof of at-view.

')

(* ****** ****** *)

#declnamesynop("array_getref_at")
#decldescript('\
This function returns the pointer to cell i of the given array A, that is,
the pointer equal to addr@(A)+i*#sizeof("a"), where addr@(A) refers to the
starting address of A.
')

#declexample('\
A typical use of
#dyncode("array_getref_at") is given in the following example:
#pats2xhtmld('\
staload UN = "prelude/SATS/unsafe.sats"
fun{a:t0p}
array_get_at (
  A: &(@[a][n]), i: sizeLt n
) : a = let
  val p = array_getref_at<a> (A, i) in $UN.ptr_get<a> (p)
end // end of [array_get_at]
')
Note that the unsafe version of #dyncode("ptr_get") is called
here to read from the pointer p.
')

(* ****** ****** *)

#declnamesynop("array_get_at")
#decldescript('\
This function returns the value stored in cell i of the given array A.
Note that the type for values stored in A is nonlinear.
')

(* ****** ****** *)

#declnamesynop("array_set_at")
#decldescript('\
This function stores a value into cell i of the given array A, overwriting
the original value. Note that the type of values stored in A is nonlinear.
')

(* ****** ****** *)

#declnamesynop("array_exch_at")
#decldescript('\
This function exchanges the value in cell i of the given array A and the
value in its second argument. Note that the type of these values can be linear.
')

(* ****** ****** *)

(* end of [array.atxt] *)
