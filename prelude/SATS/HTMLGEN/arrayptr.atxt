#decltitle("\
ATSLIB/prelude/arrayptr\
")

(* ****** ****** *)

#declnamesynop("arrayptr_encode")

(* ****** ****** *)

#declnamesynop("arrayptr2ptr")
#declnamesynop("arrayptrout2ptr")

(* ****** ****** *)

#declnamesynop("arrayptr_takeout")
#declnamesynop("arrayptr_addback")

(* ****** ****** *)

#declnamesynop("arrayptr_get_at")
#decldescript("\
This function reads out the nonlinear value stored at cell i
of the array associated with the first argument of the function.
")

#declnamesynop("arrayptr_set_at")
#decldescript("\
This function writes a nonlinear value x to cell i
of the array associated with the first argument of the function.
")

#declnamesynop("arrayptr_exch_at")
#decldescript("\
This function exchanges the content of cell i
of the array associated with the first argument of the function
with that of the variable x (third argument). Note that the type
for these contents can be linear.
")

(* ****** ****** *)

#declnamesynop("arrayptr_free")
#decldescript("\
This function frees the memory occupied by a given arrayptr-value,
which includes both the memory for the strructure of this value and
the memory for the array associated with it.
")

(* ****** ****** *)

#declnamesynop("arrayptr_make_uninitized")
#decldescript("\

This function creates an uninitialized arrayptr-value of a given size.

")

(* ****** ****** *)

#declnamesynop("arrayptr_make_elt")
#decldescript("\

This function creates an arrayptr-value of a given size
(first argument) and then initializes it with a given value
(second argument) of some nonlinear type.

")

(* ****** ****** *)

#declnamesynop("arrayptr_make_list")
#decldescript("\

This function creates an arrayptr-value of a given size n (first argument)
and then initializes it with a given list (second argument) of length n.

")

#declnamesynop("arrayptr_make_list_vt")
#decldescript("\

This function creates an arrayptr-value of a given size n (first argument)
and then initializes it with a given linear list (second argument) of
length n. Note that the linear list is consumed after the function returns.

")

(* ****** ****** *)

#declnamesynop("arrayptr_foreach")
#decldescript("

This function traverses the array associated with a given
arrayptr-value from left to right, applying the function implemented by
#dyncode("arrayptr_foreach__fwork") to each cell in the array.

")
#declexample('\

The following code creates an array of integers, computes the sum of the
integers in the created array and then frees it.

#pats2xhtmld('\
staload UN = "prelude/SATS/unsafe.sats"
//
implement
main () = let
//
val N = 10
val asz = g1int2uint (N)
val A = arrayptr_make_elt<int> (asz, 1)
//
var res: int = 0
val p_res = $UN.cast2Ptr1 (addr@(res))
//
implement
arrayptr_foreach__fwork<int> (x) = $UN.ptr_addby<int> (p_res, x)
val () = arrayptr_foreach (A, asz)
//
val () = arrayptr_free (A)
//
val () = assert (N = res)
//
in
  0(*normal*)
end // end of [main]
')')

#declnamesynop("arrayptr_foreach_funenv")
#decldescript("\

This function is like #dyncode("arrayptr_foreach") except that the function
to be applied to each array cell is provided as an argument.  ")

#declnamesynop("arrayptr_foreach_fun")
#decldescript("\

This function is a special case of #dyncode("arrayptr_foreach_funenv") in
that the provided function does not take an argument as its environment.

")

(* ****** ****** *)

#declnamesynop("arrayptr_iforeach")
#declnamesynop("arrayptr_iforeach_funenv")
#declnamesynop("arrayptr_iforeach_fun")

(* ****** ****** *)

#declnamesynop("arrayptr_initize")

(* ****** ****** *)

#declnamesynop("arrayptr_uninitize")

(* ****** ****** *)

(* end of [arrayptr.atxt] *)
