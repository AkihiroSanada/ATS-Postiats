#decltitle("\
ATSLIB/prelude/list\
")

(* ****** ****** *)

#declpreamble('\

The type for a singly-linked functional list containing N elements of type
T is denoted by #stacode("list(T, N)"), where T is nonlinear. Note that the
type constructor #stacode("list") is co-variant in its first argument, that
is, #stacode("list(T1, N)") is a subtype of #stacode("list(T2, N)") if T1
is a subtype of T2.

')#comment("declpreamble")

(* ****** ****** *)

#declname("list")
#declsynopsis2('\

The full name for the list-type constructor #stacode("list") is
#stacode("list_t0ype_int_type"), which is given to the datatype declared as
follows:
#pats2xhtmls('\
datatype // t@ype+: covariant
list_t0ype_int_type (a:t@ype+, int) =
  | {n:int | n >= 0}
    list_cons (a, n+1) of (a, list_t0ype_int_type (a, n))
  | list_nil (a, 0) of ()
// end of [datatype]
')\

')
#decldescript('\

There are two data constructors #dyncode("list_nil") and
#dyncode("list_cons") associated with #stacode("list"); the former
constructs a list of length 0, that is, an empty list while the latter
takes an element x and a list xs of length n to construct a list of length n+1
such that x and xs are the head and tail of the newly constructed list,
respectively.\

')

(* ****** ****** *)

#declname("List")
#declsynopsis2('\
#pats2xhtmls('\
typedef List (a:t@ype) = [n:nat] list (a, n)\
')')

(* ****** ****** *)

#declnamesynop("lemma_list_param")
#decldescript('\
This proof function establishes that the integer n in any list type
#stacode("list(T, n)") is a natural number, where T is a nonlinear type.
')

(* ****** ****** *)

#declnamesynop("ListSubscriptExn")
#decldescript('\

By convention, this exception is raised to indicate a situation where a
list expected to be non-empty is actually empty.  ')

(* ****** ****** *)

#declnamesynop("list_of_list_vt")
#decldescript("\
This function casts a linear list-value to a nonlinear list-value.
")

(* ****** ****** *)

#declnamesynop("list_mergesort")
#decldescript('\

Mergesort is of time-complexity O(n(log(n))), and it is a stable sorting
algorithm.  This function mergesorts its first argument according to the
ordering implemented by #dyncode("list_quicksort__cmp") and returns a
linear list that is a sorted permutation of the first argument.

')
#declexample('\

#pats2xhtmld('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val xs = $lst{int}(9, 2, 7, 4, 5, 6, 3, 8)
val () = fprint_list_sep (stdout_ref, xs, ", ")
//
implement
list_mergesort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys_inc = list_mergesort<int> (xs)
val () = fprint_list_vt_sep (stdout_ref, ys_inc, ", ")
val () = list_vt_free (ys_inc)
//
implement
list_mergesort__cmp<int> (x1, x2) = ~compare_val<int> (x1, x2)
//
val ys_dec = list_mergesort<int> (xs)
val () = fprint_list_vt_sep (stdout_ref, ys_dec, ", ")
val () = list_vt_free (ys_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

#declnamesynop("list_quicksort")
#decldescript('\

Quicksort is of time-complexity O(n(log(n))) on average (but can be O(n^2)
in the worse case), and it is not a stable sorting algorithm.  This
function quicksorts its first argument according to the ordering implemented
by #dyncode("list_quicksort__cmp") and returns a linear list that is a sorted
permutation of the first argument.

')
#declexample('\

#pats2xhtmld('\
staload
"contrib/atshwxi/testing/SATS/fprint.sats"
staload _(*anon*) =
"contrib/atshwxi/testing/DATS/fprint.dats"
implement
main () = let
//
val N = 10
val xs = $lst{int}(9, 2, 7, 4, 5, 6, 3, 8)
val () = fprint_list_sep (stdout_ref, xs, ", ")
//
implement
list_quicksort__cmp<int> (x1, x2) = compare_val<int> (x1, x2)
//
val ys_inc = list_quicksort<int> (xs)
val () = fprint_list_vt_sep (stdout_ref, ys_inc, ", ")
val () = list_vt_free (ys_inc)
//
implement
list_quicksort__cmp<int> (x1, x2) = ~compare_val<int> (x1, x2)
//
val ys_dec = list_quicksort<int> (xs)
val () = fprint_list_vt_sep (stdout_ref, ys_dec, ", ")
val () = list_vt_free (ys_dec)
//
in
  0(*normal*)
end // end of [main]
')')

(* ****** ****** *)

(* end of [list.atxt] *)
